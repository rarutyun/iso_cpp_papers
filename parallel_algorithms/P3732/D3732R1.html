<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-09-09" />
  <title>Numeric range algorithms</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
</style>
  <style>
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ background-color: #f6f8fa; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { } 
code span.al { color: #ff0000; } 
code span.an { } 
code span.at { } 
code span.bn { color: #9f6807; } 
code span.bu { color: #9f6807; } 
code span.cf { color: #00607c; } 
code span.ch { color: #9f6807; } 
code span.cn { } 
code span.co { color: #008000; font-style: italic; } 
code span.cv { color: #008000; font-style: italic; } 
code span.do { color: #008000; } 
code span.dt { color: #00607c; } 
code span.dv { color: #9f6807; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #9f6807; } 
code span.fu { } 
code span.im { } 
code span.in { color: #008000; } 
code span.kw { color: #00607c; } 
code span.op { color: #af1915; } 
code span.ot { } 
code span.pp { color: #6f4e37; } 
code span.re { } 
code span.sc { color: #9f6807; } 
code span.ss { color: #9f6807; } 
code span.st { color: #9f6807; } 
code span.va { } 
code span.vs { color: #9f6807; } 
code span.wa { color: #008000; font-weight: bold; } 
code.diff {color: #898887}
code.diff span.va {color: #00AA00}
code.diff span.st {color: #bf0303}
</style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Numeric range
algorithms</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>P3732R1</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2025-09-09</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      SG1,SG9<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Ruslan Arutyunyan<br>&lt;<a href="mailto:ruslan.arutyunyan@intel.com" class="email">ruslan.arutyunyan@intel.com</a>&gt;<br>
      Mark Hoemmen<br>&lt;<a href="mailto:mhoemmen@nvidia.com" class="email">mhoemmen@nvidia.com</a>&gt;<br>
      Alexey Kukanov<br>&lt;<a href="mailto:alexey.kukanov@intel.com" class="email">alexey.kukanov@intel.com</a>&gt;<br>
      Bryce Adelstein Lelbach<br>&lt;<a href="mailto:brycelelbach@gmail.com" class="email">brycelelbach@gmail.com</a>&gt;<br>
      Abhilash Majumder<br>&lt;<a href="mailto:abmajumder@nvidia.com" class="email">abmajumder@nvidia.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#revision-history" id="toc-revision-history"><span class="toc-section-number">1</span> Revision history</a>
<ul>
<li><a href="#r0-to-be-submitted-2025-07-15" id="toc-r0-to-be-submitted-2025-07-15"><span class="toc-section-number">1.1</span> R0 to be submitted
2025-07-15</a></li>
<li><a href="#r1-in-preparation" id="toc-r1-in-preparation"><span class="toc-section-number">1.2</span> R1 in preparation</a></li>
</ul></li>
<li><a href="#what-we-propose" id="toc-what-we-propose"><span class="toc-section-number">2</span> What we propose</a></li>
<li><a href="#design" id="toc-design"><span class="toc-section-number">3</span> Design</a>
<ul>
<li><a href="#what-algorithms-to-include" id="toc-what-algorithms-to-include"><span class="toc-section-number">3.1</span> What algorithms to include?</a>
<ul>
<li><a href="#current-set-of-numeric-algorithms" id="toc-current-set-of-numeric-algorithms"><span class="toc-section-number">3.1.1</span> Current set of numeric
algorithms</a></li>
<li><a href="#we-propose-to-include-all-_reduce-and-_scan-algorithms" id="toc-we-propose-to-include-all-_reduce-and-_scan-algorithms"><span class="toc-section-number">3.1.2</span> We propose to include all
<code>*_reduce</code> and <code>*_scan</code> algorithms</a></li>
<li><a href="#add-reduce_into-and-transform_reduce_into" id="toc-add-reduce_into-and-transform_reduce_into"><span class="toc-section-number">3.1.5</span> Add <code>reduce_into</code> and
<code>transform_reduce_into</code></a></li>
<li><a href="#we-propose-convenience-wrappers-to-replace-some-algorithms" id="toc-we-propose-convenience-wrappers-to-replace-some-algorithms"><span class="toc-section-number">3.1.6</span> We propose convenience wrappers
to replace some algorithms</a></li>
<li><a href="#other-existing-algorithms-can-be-replaced-with-views" id="toc-other-existing-algorithms-can-be-replaced-with-views"><span class="toc-section-number">3.1.7</span> Other existing algorithms can be
replaced with views</a></li>
<li><a href="#we-dont-propose-the-lost-algorithm-noncommutative-parallel-reduce" id="toc-we-dont-propose-the-lost-algorithm-noncommutative-parallel-reduce"><span class="toc-section-number">3.1.8</span> We don’t propose “the lost
algorithm” (noncommutative parallel reduce)</a></li>
<li><a href="#no-reduce-with-iter" id="toc-no-reduce-with-iter"><span class="toc-section-number">3.1.9</span> We don’t propose
<code>reduce_with_iter</code></a></li>
<li><a href="#we-dont-propose-reduce_first" id="toc-we-dont-propose-reduce_first"><span class="toc-section-number">3.1.10</span> We don’t propose
<code>reduce_first</code></a></li>
</ul></li>
<li><a href="#range-categories-and-return-types" id="toc-range-categories-and-return-types"><span class="toc-section-number">3.2</span> Range categories and return
types</a></li>
<li><a href="#constexpr-parallel-algorithms" id="toc-constexpr-parallel-algorithms"><span class="toc-section-number">3.3</span> Constexpr parallel
algorithms?</a></li>
<li><a href="#initial-value-vs-identity" id="toc-initial-value-vs-identity"><span class="toc-section-number">3.4</span> Specifying an identity for
reductions and scans</a>
<ul>
<li><a href="#summary-1" id="toc-summary-1"><span class="toc-section-number">3.4.1</span> Summary</a></li>
<li><a href="#initial-value-of-a-reduction-or-scan" id="toc-initial-value-of-a-reduction-or-scan"><span class="toc-section-number">3.4.2</span> Initial value of a reduction or
scan</a></li>
<li><a href="#identity-value-of-a-reduction-or-scans-binary-operator" id="toc-identity-value-of-a-reduction-or-scans-binary-operator"><span class="toc-section-number">3.4.3</span> Identity value of a reduction or
scan’s binary operator</a></li>
<li><a href="#identity-may-not-exist-or-may-be-unknown" id="toc-identity-may-not-exist-or-may-be-unknown"><span class="toc-section-number">3.4.4</span> Identity may not exist or may be
unknown</a></li>
<li><a href="#initial-value-matters-most-for-sequential-reduction" id="toc-initial-value-matters-most-for-sequential-reduction"><span class="toc-section-number">3.4.5</span> Initial value matters most for
sequential reduction</a></li>
<li><a href="#identity-matters-most-for-parallel-reduction" id="toc-identity-matters-most-for-parallel-reduction"><span class="toc-section-number">3.4.6</span> Identity matters most for
parallel reduction</a></li>
<li><a href="#how-to-initialize-each-local-accumulator-without-an-identity" id="toc-how-to-initialize-each-local-accumulator-without-an-identity"><span class="toc-section-number">3.4.7</span> How to initialize each local
accumulator without an identity</a></li>
<li><a href="#other-parallel-programming-models" id="toc-other-parallel-programming-models"><span class="toc-section-number">3.4.8</span> Other parallel programming
models</a></li>
<li><a href="#implementations-may-use-a-default-identity-value-via-as-if-rule" id="toc-implementations-may-use-a-default-identity-value-via-as-if-rule"><span class="toc-section-number">3.4.9</span> Implementations may use a
default identity value via as-if rule</a></li>
<li><a href="#interface-for-specifying-identity" id="toc-interface-for-specifying-identity"><span class="toc-section-number">3.4.10</span> Interface for specifying
identity</a></li>
<li><a href="#other-designs" id="toc-other-designs"><span class="toc-section-number">3.4.11</span> Other designs</a></li>
<li><a href="#if-users-can-define-an-identity-value-do-they-need-an-initial-value" id="toc-if-users-can-define-an-identity-value-do-they-need-an-initial-value"><span class="toc-section-number">3.4.12</span> If users can define an identity
value, do they need an initial value?</a></li>
<li><a href="#conclusions-2" id="toc-conclusions-2"><span class="toc-section-number">3.4.13</span> Conclusions</a></li>
</ul></li>
<li><a href="#rangesreduce-design" id="toc-rangesreduce-design"><span class="toc-section-number">3.5</span> <code>ranges::reduce</code>
design</a>
<ul>
<li><a href="#no-default-binary-operation-or-initial-value" id="toc-no-default-binary-operation-or-initial-value"><span class="toc-section-number">3.5.1</span> No default binary operation or
initial value</a></li>
<li><a href="#for-return-type-imitate-rangesfold_left-not-stdreduce" id="toc-for-return-type-imitate-rangesfold_left-not-stdreduce"><span class="toc-section-number">3.5.2</span> For return type, imitate
<code>ranges::fold_left</code>, not <code>std::reduce</code></a></li>
</ul></li>
<li><a href="#constraining-numeric-ranges-algorithms" id="toc-constraining-numeric-ranges-algorithms"><span class="toc-section-number">3.6</span> Constraining numeric ranges
algorithms</a></li>
<li><a href="#enabling-list-initialization-for-proposed-algorithms" id="toc-enabling-list-initialization-for-proposed-algorithms"><span class="toc-section-number">3.7</span> Enabling list-initialization for
proposed algorithms</a></li>
</ul></li>
<li><a href="#implementation" id="toc-implementation"><span class="toc-section-number">4</span> Implementation</a></li>
<li><a href="#wording" id="toc-wording"><span class="toc-section-number">5</span> Wording</a>
<ul>
<li><a href="#update-feature-test-macro" id="toc-update-feature-test-macro"><span class="toc-section-number">5.1</span> Update feature test macro</a></li>
<li><a href="#add-sized-forward-range-to-range.refinements" id="toc-add-sized-forward-range-to-range.refinements"><span class="toc-section-number">5.2</span> Add
<em><code>sized-forward-range</code></em> to
[range.refinements]</a></li>
<li><a href="#change-numeric.ops.overview" id="toc-change-numeric.ops.overview"><span class="toc-section-number">5.3</span> Change <span class="unnumbered sref">numeric.ops.overview</span></a>
<ul>
<li><a href="#add-declaration-of-exposition-only-concepts" id="toc-add-declaration-of-exposition-only-concepts"><span class="toc-section-number">5.3.1</span> Add declaration of
exposition-only concepts</a></li>
<li><a href="#add-declarations-of-reduce-sum-product-and-their-_into-variants" id="toc-add-declarations-of-reduce-sum-product-and-their-_into-variants"><span class="toc-section-number">5.3.2</span> Add declarations of
<code>reduce</code>, <code>sum</code>, <code>product</code>, and their
<code>*_into</code> variants</a></li>
<li><a href="#add-declarations-of-ranges-transform_reduce-dot-and-dot_into" id="toc-add-declarations-of-ranges-transform_reduce-dot-and-dot_into"><span class="toc-section-number">5.3.3</span> Add declarations of ranges
<code>transform_reduce</code>, <code>dot</code>, and
<code>dot_into</code></a></li>
<li><a href="#add-declarations-of-ranges-exclusive_scan" id="toc-add-declarations-of-ranges-exclusive_scan"><span class="toc-section-number">5.3.4</span> Add declarations of ranges
<code>exclusive_scan</code></a></li>
<li><a href="#add-declarations-of-ranges-inclusive_scan" id="toc-add-declarations-of-ranges-inclusive_scan"><span class="toc-section-number">5.3.5</span> Add declarations of ranges
<code>inclusive_scan</code></a></li>
<li><a href="#todo-what-about-transform_exclusive_scan" id="toc-todo-what-about-transform_exclusive_scan"><span class="toc-section-number">5.3.6</span> TODO What about
<code>transform_exclusive_scan</code>?</a></li>
<li><a href="#todo-what-about-transform_inclusive_scan" id="toc-todo-what-about-transform_inclusive_scan"><span class="toc-section-number">5.3.7</span> TODO What about
<code>transform_inclusive_scan</code>?</a></li>
<li><a href="#add-wording-for-algorithms" id="toc-add-wording-for-algorithms"><span class="toc-section-number">5.3.8</span> Add wording for
algorithms</a></li>
</ul></li>
</ul></li>
<li><a href="#references" id="toc-references"><span class="toc-section-number">6</span> References</a></li>
</ul>
</div>
<h1 class="unnumbered unlisted" id="abstract">Abstract<a href="#abstract" class="self-link"></a></h1>
<p>We propose <code>ranges</code> algorithm overloads (both parallel and
non-parallel) for the <code>&lt;numeric&gt;</code> header.</p>
<h1 class="unnumbered unlisted" id="authors">Authors<a href="#authors" class="self-link"></a></h1>
<ul>
<li><p>Ruslan Arutyunyan (Intel)</p></li>
<li><p>Mark Hoemmen (NVIDIA)</p></li>
<li><p>Alexey Kukanov (Intel)</p></li>
<li><p>Bryce Adelstein Lelbach (NVIDIA)</p></li>
<li><p>Abhilash Majumder (NVIDIA)</p></li>
</ul>
<h1 data-number="1" id="revision-history"><span class="header-section-number">1</span> Revision history<a href="#revision-history" class="self-link"></a></h1>
<h2 data-number="1.1" id="r0-to-be-submitted-2025-07-15"><span class="header-section-number">1.1</span> R0 to be submitted 2025-07-15<a href="#r0-to-be-submitted-2025-07-15" class="self-link"></a></h2>
<p>R0 is the original draft prepared before the June 2025 Sofia WG21
meeting. SG1 reviewed this draft during the Sofia meeting with the
following feedback.</p>
<ul>
<li><p>SG1 agrees (via poll 4/5/1/0/0) that users should have a way to
specify an identity value. SG1 asks whether there is any need to specify
this as a compile-time value, or whether a run-time-only interface would
suffice. One concern is the potential cost of broadcasting an identity
value at run time to all threads, versus initializing each thread’s
accumulator to a value known at compile time.</p></li>
<li><p>SG1 has no objection to adding <code>transform_*</code> variants
of algorithms.</p></li>
<li><p>SG1 asks us to add <code>reduce_into</code> and
<code>transform_reduce_into</code> (via poll 4/4/0/0/0), that is,
versions of <code>reduce</code> and <code>transform_reduce</code> that
write the reduction result to an output range of one element. (We asked
SG1 to take this poll because LEWG rejected an analogous design for
std::linalg reduction-like algorithms such as dot product and
norms.)</p></li>
<li><p>SG1 members would like separate proposals on fixing
<em><code>movable-box</code></em> trivial copyability, and fixing
performance issues with views in general.</p></li>
</ul>
<h2 data-number="1.2" id="r1-in-preparation"><span class="header-section-number">1.2</span> R1 in preparation<a href="#r1-in-preparation" class="self-link"></a></h2>
<ul>
<li><p>Revise non-wording sections</p>
<ul>
<li><p>Explain <code>reduce_into</code> and
<code>transform_reduce_into</code></p></li>
<li><p>Show different designs for specifying identity value</p></li>
</ul></li>
<li><p>Add <code>sum_into</code>, <code>product_into</code>, and
<code>dot_into</code> (special cases of <code>reduce_into</code> or
<code>transform_reduce_into</code>)</p></li>
</ul>
<h1 data-number="2" id="what-we-propose"><span class="header-section-number">2</span> What we propose<a href="#what-we-propose" class="self-link"></a></h1>
<p>We propose <code>ranges</code> overloads (both parallel and
non-parallel) of the following algorithms:</p>
<ul>
<li><p><code>reduce</code>, unary <code>transform_reduce</code>, and
binary <code>transform_reduce</code>;</p></li>
<li><p><code>inclusive_scan</code> and
<code>transform_inclusive_scan</code>; and</p></li>
<li><p><code>exclusive_scan</code> and
<code>transform_exclusive_scan</code>.</p></li>
</ul>
<p>These correspond to existing algorithms with the same names in the
<code>&lt;numeric&gt;</code> header. Therefore, we called them “numeric
range(s) algorithms.”</p>
<p>We also propose adding “<code>_into</code>” versions of
<code>reduce</code> and <code>transform_reduce</code>, that write the
reduction result into a size-one range.</p>
<p>Finally, we propose parallel and non-parallel convenience
wrappers:</p>
<ul>
<li><p><code>ranges::sum</code> and <code>ranges::product</code> for
special cases of <code>reduce</code> with addition and multiplication,
respectively;</p></li>
<li><p><code>ranges::dot</code> for the special case of binary
<code>transform_reduce</code> with transform <code>multiplies{}</code>
and reduction <code>plus{}</code>; and</p></li>
<li><p><code>ranges::sum_into</code>, <code>ranges::product_into</code>,
and <code>ranges::dot_into</code> (the “<code>_into</code>” versions of
<code>sum</code>, <code>product</code>, and <code>dot</code>).</p></li>
</ul>
<p>The following sections explain why we propose these algorithms and
not others. This relates to other aspects of the design besides
algorithm selection, such as whether to include optional projection
parameters.</p>
<h1 data-number="3" id="design"><span class="header-section-number">3</span> Design<a href="#design" class="self-link"></a></h1>
<h2 data-number="3.1" id="what-algorithms-to-include"><span class="header-section-number">3.1</span> What algorithms to include?<a href="#what-algorithms-to-include" class="self-link"></a></h2>
<p>We propose providing parallel and non-parallel ranges versions of the
following algorithms.</p>
<ol type="1">
<li><p><code>reduce</code>, <code>transform_reduce</code>,
<code>{ex,in}clusive_scan</code>, and
<code>transform_{ex,in}clusive_scan</code>, but <em>not</em> with
projection parameters</p></li>
<li><p><code>reduce_into</code> and <code>transform_reduce_into</code>,
that write the reduction result into a nonempty sized forward
range</p></li>
<li><p><code>sum</code> and <code>product</code> for special cases of
<code>reduce</code> with addition resp. multiplication, and
<code>dot</code> for the special case of binary
<code>transform_reduce</code> with transform <code>multiplies{}</code>
and reduction <code>plus{}</code></p></li>
<li><p>“<code>_into</code>” versions of (3): <code>sum_into</code>,
<code>product_into</code>, and <code>dot_into</code></p></li>
</ol>
<h3 data-number="3.1.1" id="current-set-of-numeric-algorithms"><span class="header-section-number">3.1.1</span> Current set of numeric
algorithms<a href="#current-set-of-numeric-algorithms" class="self-link"></a></h3>
<p><span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span>, “C++
Parallel Range Algorithms,” was voted into the Working Draft for C++26
during the June 2025 Sofia meeting. <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> explicitly
defers adding <code>ranges</code> versions of the numeric algorithms.
This proposal does that. As such, we focus on the 11 algorithms in <span class="unnumbered sref">numeric.ops</span>.</p>
<ul>
<li><p><code>iota</code></p></li>
<li><p><code>accumulate</code></p></li>
<li><p><code>inner_product</code></p></li>
<li><p><code>partial_sum</code></p></li>
<li><p><code>adjacent_difference</code></p></li>
<li><p><code>reduce</code></p></li>
<li><p><code>inclusive_scan</code></p></li>
<li><p><code>exclusive_scan</code></p></li>
<li><p><code>transform_reduce</code></p></li>
<li><p><code>transform_inclusive_scan</code></p></li>
<li><p><code>transform_exclusive_scan</code></p></li>
</ul>
<p>We don’t have to add ranges versions of all these algorithms. Several
already have a ranges version in C++23, possibly with a different name.
Some others could be omitted because they have straightforward
replacements using existing views and other <code>ranges</code>
algorithms. We carefully read the two proposals <span class="citation" data-cites="P2214R2">[<a href="#ref-P2214R2" role="doc-biblioref"><strong>P2214R2?</strong></a>]</span>, “A Plan for
C++23 Ranges,” and <span class="citation" data-cites="P2760R1">[<a href="#ref-P2760R1" role="doc-biblioref"><strong>P2760R1?</strong></a>]</span>, “A Plan for
C++26 Ranges,” in order to inform our algorithm selections. In some
cases that we will explain below, usability and performance concerns led
us to disagree with their conclusions.</p>
<h3 data-number="3.1.2" id="we-propose-to-include-all-_reduce-and-_scan-algorithms"><span class="header-section-number">3.1.2</span> We propose to include all
<code>*_reduce</code> and <code>*_scan</code> algorithms<a href="#we-propose-to-include-all-_reduce-and-_scan-algorithms" class="self-link"></a></h3>
<h4 data-number="3.1.2.1" id="summary"><span class="header-section-number">3.1.2.1</span> Summary<a href="#summary" class="self-link"></a></h4>
<p>We propose</p>
<ul>
<li><p>providing both unary and binary
<code>ranges::transform_reduce</code> as well as
<code>ranges::reduce</code>,</p></li>
<li><p>providing <code>ranges::transform_{in,ex}clusive_scan</code> as
well as <code>ranges::{in,ex}clusive_scan</code>, and</p></li>
<li><p><em>not</em> providing projections for any of these
algorithms.</p></li>
</ul>
<h4 data-number="3.1.2.2" id="do-we-want-transform_-algorithms-andor-projections"><span class="header-section-number">3.1.2.2</span> Do we want
<code>transform_*</code> algorithms and/or projections?<a href="#do-we-want-transform_-algorithms-andor-projections" class="self-link"></a></h4>
<p>We start with two questions.</p>
<ol type="1">
<li>Should the existing C++17 algorithms <code>transform_reduce</code>,
<code>transform_inclusive_scan</code>, and
<code>transform_exclusive_scan</code> have ranges versions, or does it
suffice to have ranges versions of <code>reduce</code>,
<code>inclusive_scan</code>, and <code>exclusive_scan</code>?</li>
<li>Should ranges versions of <code>reduce</code>,
<code>inclusive_scan</code>, and <code>exclusive_scan</code> take
optional projections, just like <code>ranges::for_each</code> and other
<code>ranges</code> algorithms do?</li>
</ol>
<p>We use words like “should” because the ranges library doesn’t
actually <em>need</em> <code>transform_*</code> algorithms or
projections for functional completeness. These questions are about
usability and optimization, including the way that certain kinds of
ranges constructs can hinder parallelization on different kinds of
hardware.</p>
<h4 data-number="3.1.2.3" id="unary-transforms-projections-and-transform_view-are-functionally-equivalent"><span class="header-section-number">3.1.2.3</span> Unary transforms,
projections, and <code>transform_view</code> are functionally
equivalent<a href="#unary-transforms-projections-and-transform_view-are-functionally-equivalent" class="self-link"></a></h4>
<p>The above two questions are related, since a projection can have the
same effect as a <code>transform_*</code> function. This aligns with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html#algorithms-should-take-invokable-projections">Section
13.2 of N4128</a>, which explains why <code>ranges</code> algorithms
take optional projections “everywhere it makes sense.”</p>
<blockquote>
<p>Wherever appropriate, algorithms should optionally take
<em><code>INVOKE</code></em>-able <em>projections</em> that are applied
to each element in the input sequence(s). This, in effect, allows users
to trivially transform each input sequence for the sake of that single
algorithm invocation.</p>
</blockquote>
<p>Projecting the input of <code>reduce</code> has the same effect as
unary <code>transform_reduce</code>. Here is an example, in which
<code>get_element</code> is a customization point object like the one
proposed in <span class="citation" data-cites="P2769R3">[<a href="#ref-P2769R3" role="doc-biblioref"><strong>P2769R3?</strong></a>]</span>, such that
<code>get_element&lt;k&gt;</code> gets the <code>k</code>-th element of
an object that participates in the tuple or structured binding
protocol.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_proj <span class="op">=</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span>v1, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_proj <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_xform <span class="op">=</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span>v1, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_xform <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span></code></pre></div>
<p>Even without projections, the <code>transform_*</code> algorithms can
be replaced by a combination of <code>transform_view</code> and the
non-<code>transform</code> algorithm.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_tv <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>, init, std<span class="op">::</span>plus<span class="op">{})</span>;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_tv <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span></code></pre></div>
<p>This applies to scan algorithms as well. <span class="citation" data-cites="P2214R2">[<a href="#ref-P2214R2" role="doc-biblioref"><strong>P2214R2?</strong></a>]</span> points out
that <code>ranges::transform_inclusive_scan(r, o, f, g)</code> can be
rewritten as
<code>ranges::inclusive_scan(r | views::transform(g), o, f)</code>. The
latter formulation saves users from needing to remember which of
<code>f</code> and <code>g</code> is the transform (unary) operation,
and which is the binary operation. Making the ranges version of the
algorithm take an optional projection would be exactly equivalent to
adding a <code>transform_*</code> version that does not take a
projection: e.g., <code>ranges::inclusive_scan(r, o, f, g)</code> with
<code>g</code> as the projection would do exactly the same thing as
<code>ranges::transform_inclusive_scan(r, o, f, g)</code> with
<code>g</code> as the transform operation.</p>
<h4 data-number="3.1.2.4" id="binary-transform_reduce-is-functionally-equivalent-to-reduce-and-zip_transform_view"><span class="header-section-number">3.1.2.4</span> Binary
<code>transform_reduce</code> is functionally equivalent to
<code>reduce</code> and <code>zip_transform_view</code><a href="#binary-transform_reduce-is-functionally-equivalent-to-reduce-and-zip_transform_view" class="self-link"></a></h4>
<p>The binary variant of <code>transform_reduce</code> is different.
Unlike <code>reduce</code> and most other numeric algorithms, it takes
two input sequences and applies a binary function to the pairs of
elements from both sequences. Projections, being unary functions, cannot
replace the binary transform function of the algorithm. Likewise,
<code>transform_view</code> by itself cannot replace the binary
transform function unless it is combined with <code>zip_view</code> and
operates on tuples of elements. <code>zip_transform_view</code> is a
convenient way to express this combination; applying <code>reduce</code>
to <code>zip_transform_view</code> gives the necessary result (code
examples are shown below).</p>
<h4 data-number="3.1.2.5" id="study-rangestransform-for-design-hints"><span class="header-section-number">3.1.2.5</span> Study
<code>ranges::transform</code> for design hints<a href="#study-rangestransform-for-design-hints" class="self-link"></a></h4>
<p>Questions about transforms and projections suggest studying
<code>ranges::transform</code> for design hints. This leads us to two
more questions.</p>
<ol type="1">
<li>If transforms and projections are equivalent, then why does
<code>std::ranges::transform</code> take an optional projection?</li>
<li>If binary transform is equivalent to unary transform of a
<code>zip_transform_view</code>, then why does binary
<code>std::ranges::transform</code> exist?</li>
</ol>
<h5 data-number="3.1.2.5.1" id="binary-transform"><span class="header-section-number">3.1.2.5.1</span> Binary transform<a href="#binary-transform" class="self-link"></a></h5>
<p>It can help to look at examples. The code below shows the same binary
transform computation done in two different ways: without projections
and with projections.</p>
<div class="cmptable">
<blockquote>
<p><code>transform</code> without and with projections</p>
</blockquote>
<h3 data-number="3.1.3" id="without-projections"><span class="header-section-number">3.1.3</span> Without projections<a href="#without-projections" class="self-link"></a></h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span><span class="dt">int</span>, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v2<span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">13</span>, <span class="st">&quot;thirteen&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">17</span>, <span class="st">&quot;seventeen&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">19</span>, <span class="st">&quot;nineteen&quot;</span><span class="op">}}</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span>std<span class="op">::</span>from_range, std<span class="op">::</span>views<span class="op">::</span>repeat<span class="op">(</span><span class="dv">0</span>, <span class="dv">3</span><span class="op">))</span>;;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> expected<span class="op">{</span><span class="dv">65</span>, <span class="dv">119</span>, <span class="dv">209</span><span class="op">}</span>;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Without projections: Big, opaque lambda</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, v2, out<span class="op">.</span>begin<span class="op">()</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x, <span class="kw">auto</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>x<span class="op">)</span> <span class="op">*</span> get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>y<span class="op">)</span>; <span class="op">})</span>;</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span></code></pre></div>
<h3 data-number="3.1.4" id="with-projections"><span class="header-section-number">3.1.4</span> With projections<a href="#with-projections" class="self-link"></a></h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span><span class="dt">int</span>, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v2<span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">13</span>, <span class="st">&quot;thirteen&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">17</span>, <span class="st">&quot;seventeen&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">19</span>, <span class="st">&quot;nineteen&quot;</span><span class="op">}}</span>;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span>std<span class="op">::</span>from_range, std<span class="op">::</span>views<span class="op">::</span>repeat<span class="op">(</span><span class="dv">0</span>, <span class="dv">3</span><span class="op">))</span>;;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> expected<span class="op">{</span><span class="dv">65</span>, <span class="dv">119</span>, <span class="dv">209</span><span class="op">}</span>;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">// With projections: More readable</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, v2, out<span class="op">.</span>begin<span class="op">()</span>,</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>multiplies<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out2 <span class="op">==</span> expected<span class="op">)</span>;</span></code></pre></div>
</div>
<p>The code without projections uses a single big lambda to express the
binary operation. Users have to read the big lambda to see what it does.
So does the compiler, which can hinder optimization if it’s not good at
inlining. In contrast, the version with projections lets users read out
loud what it does. It also separates the “selection” or “query” part of
the transform from the “arithmetic” or “computation” part. The power of
the ranges abstraction is that users can factor computation on a range
from the logic to iterate over that range. It’s natural to extend this
separation to selection logic as well.</p>
<h5 data-number="3.1.4.0.1" id="unary-transform"><span class="header-section-number">3.1.4.0.1</span> Unary transform<a href="#unary-transform" class="self-link"></a></h5>
<p>In the unary <code>transform</code> case, it’s harder to avoid using
a lambda. Most of the named C++ Standard Library arithmetic function
objects are binary. Currying them into unary functions in C++ requires
either making a lambda (which defeats the purpose somewhat) or using
something like <code>std::bind_front</code> (which is verbose). On the
other hand, using a projection still has the benefit of separating the
“selection” part of the transform from the “computation” part.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span>std<span class="op">::</span>from_range, std<span class="op">::</span>views<span class="op">::</span>repeat<span class="op">(</span><span class="dv">0</span>, <span class="dv">3</span><span class="op">))</span>;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> expected<span class="op">{</span><span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">12</span><span class="op">}</span>;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Unary transform without projection</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, out<span class="op">.</span>begin<span class="op">()</span>, <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>x<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span>; <span class="op">})</span>;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Unary transform with projection</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, out<span class="op">.</span>begin<span class="op">()</span>, <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span>; <span class="op">}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Unary transform with projection and &quot;curried&quot; plus</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, out<span class="op">.</span>begin<span class="op">()</span>, std<span class="op">::</span>bind_front<span class="op">(</span>std<span class="op">::</span>plus<span class="op">{}</span>, <span class="dv">1</span><span class="op">)</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span></code></pre></div>
<h4 data-number="3.1.4.1" id="reduce-transforms-and-projections"><span class="header-section-number">3.1.4.1</span> <code>reduce</code>:
transforms and projections<a href="#reduce-transforms-and-projections" class="self-link"></a></h4>
<p>We return to the <code>reduce</code> examples we showed above, but
this time, we focus on their readability.</p>
<h5 data-number="3.1.4.1.1" id="unary-transform_reduce"><span class="header-section-number">3.1.4.1.1</span> Unary
<code>transform_reduce</code><a href="#unary-transform_reduce" class="self-link"></a></h5>
<p>A <code>ranges::reduce</code> that takes a projection is functionally
equivalent to unary <code>transform_reduce</code> without a projection.
If <code>ranges</code> algorithms take projections whenever possible,
then the name <code>transform_reduce</code> is redundant here. Readers
should know that any extra function argument of a ranges algorithm is
most likely a projection. Either way – <code>reduce</code> with
projection, or unary <code>transform_reduce</code> – is straightforward
to read, and separates selection (<code>get_element&lt;0&gt;</code>)
from computation (<code>std::plus</code>).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">// reduce with projection get_element&lt;0&gt;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_proj <span class="op">=</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span>v1, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_proj <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">// transform_reduce with unary transform get_element&lt;0&gt;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_xform <span class="op">=</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span>v1, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_xform <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">// reduce with transform_view (no projection)</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_xv <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>, init, std<span class="op">::</span>plus<span class="op">{})</span>;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_xv <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span></code></pre></div>
<p>On the other hand, <code>ranges</code> algorithms take projections
whenever possible, and <code>std::ranges::transform</code> takes a
projection. Why can’t <code>transform_reduce</code> take a projection?
For unary <code>transform_reduce</code>, this arguably makes the order
of operations less clear. The projection happens first, but most users
would have to think about that. A lambda or named function would improve
readability.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> bar <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>string s;</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, std<span class="op">::</span>string, bar<span class="op">&gt;&gt;</span> v<span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <span class="dv">5</span>,   <span class="st">&quot;five&quot;</span>, <span class="op">{</span><span class="st">&quot;x&quot;</span>, <span class="dv">13</span><span class="op">}}</span>,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <span class="dv">7</span>,  <span class="st">&quot;seven&quot;</span>, <span class="op">{</span><span class="st">&quot;y&quot;</span>, <span class="dv">17</span><span class="op">}}</span>,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">11</span>, <span class="st">&quot;eleven&quot;</span>, <span class="op">{</span><span class="st">&quot;z&quot;</span>, <span class="dv">19</span><span class="op">}}}</span>;</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">// first get bar, then get bar::i</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  v, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{}</span>, get_element<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;{})</span>;</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_proj <span class="op">==</span> <span class="dv">52</span><span class="op">)</span>;</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">// first get bar, then get bar::i</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> getter <span class="op">=</span> <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{}(</span>get_element<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;{}(</span>t<span class="op">))</span>; <span class="co">// imagine that get_element works for structs</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_no_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  v, init, std<span class="op">::</span>plus<span class="op">{}</span>, getter<span class="op">)</span>;</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_no_proj <span class="op">==</span> <span class="dv">52</span><span class="op">)</span>;</span></code></pre></div>
<h5 data-number="3.1.4.1.2" id="binary-transform_reduce"><span class="header-section-number">3.1.4.1.2</span> Binary
<code>transform_reduce</code><a href="#binary-transform_reduce" class="self-link"></a></h5>
<p>As we explained above, expressing the functionality of binary
<code>transform_reduce</code> using only <code>reduce</code> requires
<code>zip_transform_view</code> or something like it. This makes the
<code>reduce</code>-only version more verbose. Users may also find it
troublesome that <code>zip_view</code> and
<code>zip_transform_view</code> are not pipeable: there is no
<code>{v1, v2} | views::zip</code> syntax, for example. On the other
hand, it’s a toss-up which version is easier to understand. Users either
need to learn what <code>zip_transform_view</code> does, or they need to
learn about <code>transform_reduce</code> and know which of the two
function arguments does what.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span>std<span class="op">::</span>string, <span class="dt">int</span><span class="op">&gt;&gt;</span> v2<span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="st">&quot;thirteen&quot;</span>, <span class="dv">13</span><span class="op">}</span>, <span class="op">{</span><span class="st">&quot;seventeen&quot;</span>, <span class="dv">17</span><span class="op">}</span>, <span class="op">{</span><span class="st">&quot;nineteen&quot;</span>, <span class="dv">19</span><span class="op">}}</span>;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">// reduce with zip_transform_view</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_bztv <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>zip_transform<span class="op">(</span>std<span class="op">::</span>multiplies<span class="op">{}</span>,</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>,</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v2, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{}))</span>,</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  init, std<span class="op">::</span>plus<span class="op">{})</span>;</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_bztv <span class="op">==</span> <span class="dv">396</span><span class="op">)</span>;</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">// binary transform_reduce</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_no_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>,</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v2, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{})</span>,</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  init, std<span class="op">::</span>plus<span class="op">{}</span>, std<span class="op">::</span>multiplies<span class="op">{})</span>;</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_no_proj <span class="op">==</span> <span class="dv">396</span><span class="op">)</span>;</span></code></pre></div>
<p>C++17 binary <code>transform_reduce</code> does not take projections.
Instead, it takes a binary transform function, that combines elements
from the two input ranges into a single value. The algorithm then
reduces these values using the binary reduce function and the initial
value. It’s perhaps misleading that this binary function is called a
“transform”; it’s really a kind of “inner” reduction on corresponding
elements of the two input ranges.</p>
<p>One can imagine a ranges analog of C++17 binary
<code>transform_reduce</code> that takes two projection functions, as in
the example below. The result has four consecutive function arguments in
a row, which is more than for any other algorithm in the Standard
Library. Without projections, users need to resort to
<code>transform_view</code>, but this more verbose syntax makes it more
clear which functions do what.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span>std<span class="op">::</span>string, <span class="dt">int</span><span class="op">&gt;&gt;</span> v2<span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="st">&quot;thirteen&quot;</span>, <span class="dv">13</span><span class="op">}</span>, <span class="op">{</span><span class="st">&quot;seventeen&quot;</span>, <span class="dv">17</span><span class="op">}</span>, <span class="op">{</span><span class="st">&quot;nineteen&quot;</span>, <span class="dv">19</span><span class="op">}}</span>;</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">// With projections: 4 functions in a row</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span>v1, v2, init,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>plus<span class="op">{}</span>, std<span class="op">::</span>multiplies<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{}</span>, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{})</span>;</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_proj <span class="op">==</span> <span class="dv">396</span><span class="op">)</span>;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Without projections: more clear where get_element&lt;k&gt; happens</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_no_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>,</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v2, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{})</span>,</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  init, std<span class="op">::</span>plus<span class="op">{}</span>, std<span class="op">::</span>multiplies<span class="op">{})</span>;</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_no_proj <span class="op">==</span> <span class="dv">396</span><span class="op">)</span>;</span></code></pre></div>
<h4 data-number="3.1.4.2" id="mixed-guidance-from-the-current-ranges-library"><span class="header-section-number">3.1.4.2</span> Mixed guidance from the
current ranges library<a href="#mixed-guidance-from-the-current-ranges-library" class="self-link"></a></h4>
<p>The current ranges library offers only mixed guidance for deciding
whether <code>*reduce</code> algorithms should take projections.</p>
<p>The various <code>fold_*</code> algorithms take no projections.
Section 4.6 of <span class="citation" data-cites="P2322R6">[<a href="#ref-P2322R6" role="doc-biblioref"><strong>P2322R6?</strong></a>]</span> explains that
the <code>fold_left_first</code> algorithm does not take a projection in
order to avoid an extra copy of the leftmost value, that would be
required in order to support projections with a range whose iterators
yield proxy reference types like <code>tuple&lt;T&amp;&gt;</code> (as
<code>views::zip</code> does). <span class="citation" data-cites="P2322R6">[<a href="#ref-P2322R6" role="doc-biblioref"><strong>P2322R6?</strong></a>]</span> clarifies
that <code>fold_left_first</code>, <code>fold_right_last</code>, and
<code>fold_left_first_with_iter</code> all have this issue. However, the
remaining two <code>fold_*</code> algorithms <code>fold_left</code> and
<code>fold_right</code> do not. This is because they never need to
materialize an input value; they can just project each element at
iterator <code>iter</code> via <code>invoke(proj, *iter)</code>, and
feed that directly into the binary operation. The author of <span class="citation" data-cites="P2322R6">[<a href="#ref-P2322R6" role="doc-biblioref"><strong>P2322R6?</strong></a>]</span> has elected
to omit projections for all five <code>fold_*</code> algorithms, so that
they have a consistent interface.</p>
<p>A ranges version of <code>reduce</code> does not have
<code>fold_left_first</code>’s design issue. C++17 algorithms in the
<code>reduce</code> family can copy results as much as they like, so
that would be less of a concern here. However, if we ever wanted a
<code>ranges::reduce_first</code> algorithm, then the consistency
argument would arise.</p>
<h4 data-number="3.1.4.3" id="transform_view-not-always-trivially-copyable-even-when-function-object-is"><span class="header-section-number">3.1.4.3</span>
<code>*transform_view</code> not always trivially copyable even when
function object is<a href="#transform_view-not-always-trivially-copyable-even-when-function-object-is" class="self-link"></a></h4>
<p>Use of <code>transform_view</code> and
<code>zip_transform_view</code> can make it harder for implementations
to parallelize <code>ranges</code> algorithms. The problem is that both
views might not necessarily be trivially copyable, even if their
function object is. If a range isn’t trivially copyable, then the
implementation must do more work beyond just a <code>memcpy</code> or
equivalent in order to get copies of the range to different parallel
execution units.</p>
<p>Here is an example (available on <a href="https://godbolt.org/z/vYnzGd3js">Compiler Explorer</a> as
well).</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Function object type that acts just like f2 below.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> F3 <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y;</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>vector v<span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span>;</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// operator= is defaulted; lambda type is trivially copyable</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> f1 <span class="op">=</span> <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span>;</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>f1<span class="op">)&gt;)</span>;</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Capture means that lambda&#39;s operator= is deleted,</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// but lambda type is still trivially copyable</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> f2 <span class="op">=</span> <span class="op">[</span>y <span class="op">=</span> <span class="dv">1</span><span class="op">]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y;</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>f2<span class="op">)&gt;)</span>;</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">// decltype(view1) is trivially copyable</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> view1 <span class="op">=</span> v <span class="op">|</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>f1<span class="op">)</span>;</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>view1<span class="op">)&gt;)</span>;</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">// decltype(view2) is NOT trivially copyable, even though f2 is</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> view2 <span class="op">=</span> v <span class="op">|</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>f2<span class="op">)</span>;</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(!</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>view2<span class="op">)&gt;)</span>;</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">// view3 is trivally copyable, though it behaves just like view2.</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>  F3 f3<span class="op">{}</span>;</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> view3 <span class="op">=</span> v <span class="op">|</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>f3<span class="op">)</span>;</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>view3<span class="op">)&gt;)</span>;</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Both lambdas <code>f1</code> and <code>f2</code> are trivially
copyable, but <code>std::views::transform(f2)</code> is <em>not</em>
trivally copyable. The wording for both <code>transform_view</code> and
<code>zip_transform_view</code> expresses the input function object of
type <code>F</code> as stored in an exposition-only
<em><code>movable-box&lt;F&gt;</code></em> member. <code>f2</code> has a
capture that gives it a <code>=delete</code>d copy assignment operator.
Nevertheless, <code>f2</code> is still trivially copyable, because each
of its default copy and move operations is either trivial or deleted,
and its destructor is nontrivial and deleted.</p>
<p>The problem is <em><code>movable-box</code></em>. As <span class="unnumbered sref">range.move.wrap</span> 1.3 explains, since
<code>copyable&lt;decltype(f2)&gt;</code> is not modeled,
<em><code>movable-box</code></em><code>&lt;decltype(f2)&gt;</code>
provides a nontrivial, not deleted copy assignment operator. This makes
<em><code>movable-box</code></em><code>&lt;decltype(f2)&gt;</code>, and
therefore <code>transform_view</code> and
<code>zip_transform_view</code>, not trivially copyable.</p>
<p>This feels like a wording bug. <code>f2</code> is a struct with one
member, an <code>int</code>, and a call operator. Why can’t I
<code>memcpy</code> <code>views::transform(f2)</code> wherever I need it
to go? Even worse, <code>f3</code> is a struct just like
<code>f2</code>, yet <code>views::transform(f3)</code> is trivially
copyable.</p>
<p>Implementations can work around this in different ways. For example,
an implementation of <code>std::ranges::reduce</code> could have a
specialization for the range being
<code>zip_transform_view&lt;F, V1, V2&gt;</code> that reaches inside the
<code>zip_transform_view</code>, pulls out the function object and
views, and calls the equivalent of binary <code>transform_reduce</code>
with them. However, the ranges library generally wasn’t designed to make
such transformations easy to implement in portable C++. Views generally
don’t expose their members – an issue that hinders all kinds of
optimizations. (For instance, it should be possible for compilers to
transform <code>cartesian_product_view</code> of bounded
<code>iota_view</code> into OpenACC or OpenMP multidimensional nested
loops for easier optimization, but <code>cartesian_product_view</code>
does not have a standard way to get at its member view(s).) As a result,
an approach based on specializing algorithms for specific view types
means that implementations cannot straightforwardly depend on a
third-party ranges implementation for their views. Parallel algorithm
implementers generally prefer to minimize coupling of actual parallel
algorithms with Standard Library features that don’t directly relate to
parallel execution.</p>
<h4 data-number="3.1.4.4" id="review"><span class="header-section-number">3.1.4.4</span> Review<a href="#review" class="self-link"></a></h4>
<p>Let’s review what we learned from the above discussion.</p>
<ul>
<li><p>Projections improve readability of
<code>ranges::transform</code>.</p></li>
<li><p>Projections expose optimization potential, by separating the
selection part of an algorithm from the computation part.</p></li>
<li><p>None of the existing <code>fold_*</code> <code>ranges</code>
algorithms (the closest things the Standard Library currently has to
<code>ranges::reduce</code>) take projections.</p></li>
<li><p>Ranges <code>reduce</code> with a projection and unary
<code>transform_reduce</code> without a projection have the same
functionality, without much usability or implementation difference.
Ditto for <code>{in,ex}clusive_scan</code> with a projection and
<code>transform_{in,ex}clusive_scan</code> without.</p></li>
<li><p>Expressing binary <code>transform_reduce</code> using only
<code>reduce</code> requires <code>zip_transform_view</code>
<em>always</em>, even if the two input ranges are contiguous ranges of
<code>int</code>. This hinders readability and potentially also
performance.</p></li>
<li><p>A ranges version of binary <code>transform_reduce</code> that
takes projections is harder to use and read than a version without
projections. However, a version without projections would need
<code>transform_view</code> in order to offer the same functionality.
This potentially hinders performance.</p></li>
</ul>
<h4 data-number="3.1.4.5" id="conclusions"><span class="header-section-number">3.1.4.5</span> Conclusions<a href="#conclusions" class="self-link"></a></h4>
<p>We propose</p>
<ul>
<li>providing both unary and binary
<code>ranges::transform_reduce</code> as well as
<code>ranges::reduce</code>,</li>
<li>providing <code>ranges::transform_{in,ex}clusive_scan</code> as well
as <code>ranges::{in,ex}clusive_scan</code>, and</li>
<li><em>not</em> providing projections for any of these algorithms.</li>
</ul>
<p>We conclude this based on a chain of reasoning, starting with binary
<code>transform_reduce</code>.</p>
<ol type="1">
<li>We want binary <code>transform_reduce</code> for usability and
performance reasons. (The “transform” of a binary
<code>transform_reduce</code> is <em>not</em> the same thing as a
projection.)</li>
<li>It’s inconsistent to have binary <code>transform_reduce</code>
without unary <code>transform_reduce</code>.</li>
<li>Projections tend to hinder usability of both unary and binary
<code>transform_reduce</code>. If we have unary
<code>transform_reduce</code>, we don’t need <code>reduce</code> with a
projection.</li>
<li>We already have <code>fold_*</code> (effectively special cases of
<code>reduce</code>) without projections, even though some of the
<code>fold_*</code> algorithms <em>could</em> have had projections.</li>
<li>If we have other <code>*reduce</code> algorithms without projections
as well, then the most consistent thing would be for <em>no</em>
reduction algorithms to have projections.</li>
<li>It’s more consistent for the various <code>*scan</code> algorithms
to look and act like their <code>*reduce</code> counterparts, so we
provide <code>ranges::transform_{in,ex}clusive_scan</code> as well as
<code>ranges::{in,ex}clusive_scan</code>, and do not provide projections
for any of them.</li>
</ol>
<h3 data-number="3.1.5" id="add-reduce_into-and-transform_reduce_into"><span class="header-section-number">3.1.5</span> Add <code>reduce_into</code>
and <code>transform_reduce_into</code><a href="#add-reduce_into-and-transform_reduce_into" class="self-link"></a></h3>
<p>We propose new parallel and non-parallel algorithms
<code>reduce_into</code> and <code>transform_reduce_into</code>. These
work like <code>reduce</code> and <code>transform_reduce</code>, except
that instead of returning the reduction result by value, they write it
to the first element of an output range. We include both unary and
binary versions of <code>transform_reduce_into</code>. We also provide
convenience wrappers <code>sum_into</code>, <code>product_into</code>,
and <code>dot_into</code> that are the “<code>_into</code>” analogues of
<code>sum</code>, <code>product</code>, and <code>dot</code>.</p>
<h4 data-number="3.1.5.1" id="justification"><span class="header-section-number">3.1.5.1</span> Justification<a href="#justification" class="self-link"></a></h4>
<p>The <code>reduce_into</code> algorithm has <a href="https://nvidia.github.io/cccl/thrust/api_docs/algorithms/reductions.html">precedent
in the Thrust library</a>. Its performance advantange is that the
algorithm can write its result directly to special memory associated
with parallel execution, such as accelerator memory or a NUMA
(Non-Uniform Memory Access) domain where the algorithm’s threads
run.</p>
<h4 data-number="3.1.5.2" id="provide-both-parallel-and-non-parallel-versions-of-these-algorithms"><span class="header-section-number">3.1.5.2</span> Provide both parallel and
non-parallel versions of these algorithms<a href="#provide-both-parallel-and-non-parallel-versions-of-these-algorithms" class="self-link"></a></h4>
<p>C++17 offers both parallel and non-parallel <code>reduce</code>,
<code>transform_reduce</code>, <code>inclusive_scan</code>, and
<code>exclusive_scan</code>. The main benefit of the non-parallel
versions is that they permit reordering terms in the reduction or sum.
For example, an implementation of
<code>reduce(x.begin(), x.end(), std::plus{})</code> for a forward range
of <code>float</code> is permitted to copy the range into contiguous
storage and perform a parallel- and SIMD-accelerated reduction there. We
want our non-parallel <code>ranges</code> numeric algorithms to have the
same implementation freedom.</p>
<h4 data-number="3.1.5.3" id="output-should-be-a-nonempty-sized-forward-range-not-an-iterator"><span class="header-section-number">3.1.5.3</span> Output should be a nonempty
sized forward range, not an iterator<a href="#output-should-be-a-nonempty-sized-forward-range-not-an-iterator" class="self-link"></a></h4>
<p>P3179 (parallel ranges algorithms) always specifies output ranges as
sized ranges, instead of as a single iterator. However, in the case of
<code>*reduce_into</code>, the output range only needs to have one
element. Thus, the interface could represent the output range either as
a single iterator to that element, or as a nonempty range. We propose
representing the output as a nonempty sized forward range.</p>
<p>There are two parts to this.</p>
<ol type="1">
<li><p><em>Nonempty</em> and <em>sized</em>: we define this as
<code>sized_range</code> with nonzero
<code>ranges::size(r)</code></p></li>
<li><p><em>Forward range</em>: in the sense of
<code>forward_range</code></p></li>
</ol>
<p>We propose making the output a nonempty range instead of just an
iterator because this lets the <code>*reduce_into</code> algorithms
simply do nothing if the output range is empty. This would make their
behavior consistent with <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span>’s parallel
ranges algorithms that were adopted into the Working Draft for
C++26.</p>
<p>Unlike other algorithms in <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span>, the
<code>*reduce_into</code> algorithms don’t need to know the size of the
output range; they just need to know that it has at least one element.
Ranges provides three different ways to say that a range <code>r</code>
has at least one element.</p>
<ol type="a">
<li><p>The range is a <code>sized_range</code> (meaning that
<code>ranges::size(r)</code> has constant complexity) and
<code>ranges::size(r)</code> is nonzero;</p></li>
<li><p><code>ranges::empty(r)</code> is <code>false</code>; or,</p></li>
<li><p>iterator comparison:
<code>ranges::begin(r) != ranges::end(r)</code>.</p></li>
</ol>
<p>We choose Option (a) because</p>
<ol type="i">
<li><p>it’s consistent with <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span>’s output
ranges;</p></li>
<li><p>the Standard currently has no concept to express algorithmic
complexity constraints on <code>ranges::empty(r)</code>
([range.prim.empty]), while <code>ranges::size(r)</code> on a
<code>sized_range</code> always has constant complexity; and</p></li>
<li><p><code>sized_range</code> permits evaluation of
<code>ranges::size(r)</code> before <code>ranges::begin(r)</code>
without invalidating the range, even if the range is not a
<code>forward_range</code>. This would enable future proposals that
generalize the output to be a <code>sized_range</code> that is not a
<code>forward_range</code>.</p></li>
</ol>
<p>We propose making the output a <code>forward_range</code> because the
intention of these algorithms is that once they return, users read from
the output range. If the algorithm itself invalidates the range by
writing to it, then users can’t use the output range to get back the
result. This requirement applies to both the parallel and the
non-parallel algorithms. Specifically for the parallel algorithms, the
output range must be copyable. The Standard does not currently have an
iterator category to express “single-pass but copyable.” This, again,
would limit the iterator category to be at least forward.</p>
<h4 data-number="3.1.5.4" id="use-case-comparing-range-and-iterator-interface-options"><span class="header-section-number">3.1.5.4</span> Use case comparing range
and iterator interface options<a href="#use-case-comparing-range-and-iterator-interface-options" class="self-link"></a></h4>
<p>The motivating use case for <code>*reduce_into</code> is that both
input and output live in special memory associated with parallel
execution. Users of accelerators may want to avoid implicitly
reallocating data structures like <code>std::vector</code>, and instead
make all allocations explicit, like this.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate num_bytes bytes of special memory</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="dt">void</span><span class="op">*</span> accelerator_malloc<span class="op">(</span><span class="dt">size_t</span> num_bytes<span class="op">)</span>;</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Free an allocation created by accelerator_malloc</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="dt">void</span> accelerator_free<span class="op">(</span><span class="dt">void</span><span class="op">*</span> ptr<span class="op">)</span>;</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">// unique_ptr deleter for special memory</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> accelerator_deleter <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span>T<span class="op">*</span> ptr<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    accelerator_free<span class="op">(</span>ptr<span class="op">)</span>;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Dynamic allocation of special memory for an array</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="dt">size_t</span> Extent <span class="op">=</span> std<span class="op">::</span>dynamic_extent<span class="op">&gt;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> accelerator_array <span class="op">{</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  accelerator_array<span class="op">(</span><span class="dt">size_t</span> num_elements<span class="op">)</span> <span class="op">:</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    num_elements_<span class="op">(</span>num_elements<span class="op">)</span>,</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    alloc_<span class="op">((</span><span class="dt">float</span><span class="op">*)</span> accelerator_malloc<span class="op">(</span>num_elements <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>T<span class="op">))</span>, <span class="op">{})</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">{}</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>span<span class="op">&lt;</span>T, Extent<span class="op">&gt;</span> get_span<span class="op">()</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>Extent <span class="op">==</span> std<span class="op">::</span>dynamic_extent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="op">{</span>alloc_<span class="op">.</span>get<span class="op">()</span>, num_elements_<span class="op">}</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="op">{</span>alloc_<span class="op">.</span>get<span class="op">()}</span>;</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> std<span class="op">::</span>extents<span class="op">&lt;</span><span class="dt">size_t</span>, Extent<span class="op">&gt;</span> num_elements_;</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>unique_ptr<span class="op">&lt;</span>T<span class="op">[]</span>, accelerator_deleter<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> alloc_;</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="co">// Dynamic allocation of special memory for a single value</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> accelerator_value <span class="op">{</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>  accelerator_value<span class="op">()</span> <span class="op">:</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>    alloc_<span class="op">((</span><span class="dt">float</span><span class="op">*)</span> accelerator_malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">))</span>, <span class="op">{})</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>  <span class="op">{}</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>  T<span class="op">*</span> get<span class="op">()</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alloc_<span class="op">.</span>get<span class="op">()</span>;</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>unique_ptr<span class="op">&lt;</span>T, accelerator_deleter<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> alloc_;</span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a><span class="co">// Fill x with some values</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="dt">void</span> user_fill_span<span class="op">(</span>std<span class="op">::</span>span<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> x<span class="op">)</span>;</span></code></pre></div>
<p>If <code>reduce_into</code> takes a range for the output, users would
use it like this. Note that the output value needs to be a range. We do
that here by making it a size-1 <code>span</code>, but there are other
options.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create input range, reduce over input into output,</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">// and return output allocation.</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>accelerator_array<span class="op">&lt;</span><span class="dt">float</span>, <span class="dv">1</span><span class="op">&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>user_fill_and_reduce<span class="op">(</span><span class="dt">size_t</span> num_elements<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  accelerator_array<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> input<span class="op">(</span>num_elements<span class="op">)</span>;</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  user_fill_span<span class="op">(</span>input<span class="op">.</span>get_span<span class="op">())</span>;</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  accelerator_value<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> output;</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>reduce_into<span class="op">(</span>std<span class="op">::</span>execution<span class="op">::</span>par,</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    input<span class="op">.</span>get_span<span class="op">()</span>,</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>span<span class="op">&lt;</span><span class="dt">float</span>, <span class="dv">1</span><span class="op">&gt;(</span>output<span class="op">.</span>get<span class="op">())</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*, other arguments */</span><span class="op">)</span>;</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> std<span class="op">::</span>move<span class="op">(</span>output<span class="op">)</span>;</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If <code>reduce_into</code> takes an iterator for the output, users
would use it like this.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create input range, reduce over input into output,</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">// and return output allocation.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>accelerator_value<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>user_fill_and_reduce<span class="op">(</span><span class="dt">size_t</span> num_elements<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  accelerator_array<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> input<span class="op">(</span>num_elements<span class="op">)</span>;</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  user_fill_span<span class="op">(</span>input<span class="op">.</span>get_span<span class="op">())</span>;</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  accelerator_value<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> output;</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>reduce_into<span class="op">(</span>std<span class="op">::</span>execution<span class="op">::</span>par,</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    input<span class="op">.</span>get_span<span class="op">()</span>,</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    output<span class="op">.</span>get<span class="op">()</span> <span class="co">// pointer is an iterator</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*, other arguments */</span><span class="op">)</span>;</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> std<span class="op">::</span>move<span class="op">(</span>output<span class="op">)</span>;</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The above examples represent the intended and likely most common use
case for <code>*reduce_into</code>. If users already have a
<code>float result;</code> on the stack, they don’t need to fuss with
pointers or <code>span</code>; they can just call <code>reduce</code>
and assign to <code>result</code>. Thus, users probably won’t be writing
code like this.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> input_range<span class="op">{</span><span class="fl">3.0</span><span class="bu">f</span>, <span class="fl">5.0</span><span class="bu">f</span>, <span class="fl">7.0</span><span class="bu">f</span><span class="op">}</span>;</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> output_value<span class="op">{}</span>;</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>ranges<span class="op">::</span>reduce_into<span class="op">(</span>std<span class="op">::</span>execution<span class="op">::</span>par,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  input_range,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  span<span class="op">&lt;</span><span class="dt">float</span>, <span class="dv">1</span><span class="op">&gt;{&amp;</span>output_value<span class="op">}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">/*, other arguments */</span><span class="op">)</span>;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out_value <span class="op">==</span> out<span class="op">[</span><span class="dv">0</span><span class="op">])</span>;</span></code></pre></div>
<h4 data-number="3.1.5.5" id="add-sum_into-product_into-and-dot_into"><span class="header-section-number">3.1.5.5</span> Add <code>sum_into</code>,
<code>product_into</code>, and <code>dot_into</code><a href="#add-sum_into-product_into-and-dot_into" class="self-link"></a></h4>
<p>We provide convenience wrappers <code>ranges::sum</code> and
<code>ranges::product</code> for special cases of <code>reduce</code>
with addition resp. multiplication, and <code>ranges::dot</code> for the
special case of binary <code>transform_reduce</code> with transform
<code>multiplies{}</code> and reduction <code>plus{}</code>. As a
result, we also need to provide <code>_into</code> versions:
<code>sum_into</code>, <code>product_into</code>, and
<code>dot_into</code>. Otherwise, users who want reductions for these
special cases would have to write them by hand and call
<code>reduce_into</code> or <code>transform_reduce_into</code>.</p>
<h4 data-number="3.1.5.6" id="conclusions-1"><span class="header-section-number">3.1.5.6</span> Conclusions<a href="#conclusions-1" class="self-link"></a></h4>
<ol type="1">
<li><p>Include both parallel and non-parallel versions of
<code>reduce_into</code> and
<code>transform_reduce_into</code>.</p></li>
<li><p>Represent the output as a nonempty <code>sized_range</code> +
<code>forward_range</code>.</p></li>
<li><p>Include both parallel and non-parallel versions of
<code>sum_into</code>, <code>product_into</code>, and
<code>dot_into</code>.</p></li>
</ol>
<h3 data-number="3.1.6" id="we-propose-convenience-wrappers-to-replace-some-algorithms"><span class="header-section-number">3.1.6</span> We propose convenience
wrappers to replace some algorithms<a href="#we-propose-convenience-wrappers-to-replace-some-algorithms" class="self-link"></a></h3>
<h4 data-number="3.1.6.1" id="accumulate"><span class="header-section-number">3.1.6.1</span> <code>accumulate</code><a href="#accumulate" class="self-link"></a></h4>
<p>The <code>accumulate</code> algorithm performs operations
sequentially. Users who want that left-to-right sequential behavior can
call C++23’s <code>fold_left</code>. For users who are not concerned
about the order of operations and who want <code>accumulate</code>’s
default binary operation, we propose parallel and non-parallel
convenience wrappers <code>ranges::sum</code>.</p>
<h4 data-number="3.1.6.2" id="inner_product"><span class="header-section-number">3.1.6.2</span>
<code>inner_product</code><a href="#inner_product" class="self-link"></a></h4>
<p>The <code>inner_product</code> algorithm performs operations
sequentially. Users who want that left-to-right sequential behavior can
call <code>fold_left</code>. Note that <span class="citation" data-cites="P2214R2">[<a href="#ref-P2214R2" role="doc-biblioref"><strong>P2214R2?</strong></a>]</span> argues
specifically against adding a ranges analog of
<code>inner_product</code>, because it is less fundamental than other
algorithms.</p>
<p>For users who are not concerned about the order of operations and who
want the default binary operations used by <code>inner_product</code>,
we propose parallel and non-parallel convenience wrappers
<code>ranges::dot</code>. We call them <code>dot</code> and not
<code>inner_product</code> because inner products are mathematically
more general. We specifically mean not just any inner product, but the
inner product that is the dot product. Calling them <code>dot</code> has
the added benefit that they represent the same mathematical computation
as <code>std::linalg::dot</code>.</p>
<h3 data-number="3.1.7" id="other-existing-algorithms-can-be-replaced-with-views"><span class="header-section-number">3.1.7</span> Other existing algorithms can
be replaced with views<a href="#other-existing-algorithms-can-be-replaced-with-views" class="self-link"></a></h3>
<h4 data-number="3.1.7.1" id="iota"><span class="header-section-number">3.1.7.1</span> <code>iota</code><a href="#iota" class="self-link"></a></h4>
<p>C++20 has <code>iota_view</code>, the view version of
<code>iota</code>. One can replace the <code>iota</code> algorithm with
<code>iota_view</code> and <code>ranges::copy</code>. In fact, one could
argue that <code>iota_view</code> is the perfect use case for a view:
instead of storing the entire range, users can represent it compactly
with two integers. There also should be no optimization concerns with
parallel algorithms over an <code>iota_view</code>. For example, the
Standard specifies <code>iota_view</code> in a way that does not hinder
it from being trivially copyable, as long as its input types are. The
iterator type of <code>iota_view</code> is a random access iterator for
reasonable lower bound types (e.g., integers).</p>
<p>However, <code>ranges::iota</code> algorithm was added since C++23,
later than<code>iota_view</code>. For the sake of completeness we might
want to add a parallel variation of it as well. It’s only going to give
a syntactic advantage: if users already have <code>ranges::iota</code>
in their code, parallelizing it would be as simple as adding an
execution policy (assuming the iterator/range categories are
satisfied).</p>
<p>We do not propose parallel <code>ranges::iota</code> in R0. We are
seeking for SG9 (Ranges Study Group) feedback.</p>
<h4 data-number="3.1.7.2" id="adjacent_difference"><span class="header-section-number">3.1.7.2</span>
<code>adjacent_difference</code><a href="#adjacent_difference" class="self-link"></a></h4>
<p>The <code>adjacent_difference</code> algorithm can be replaced with a
combination of <code>adjacent_transform_view</code> (which was adopted
in C++23) and <code>ranges::copy</code>. We argue elsewhere in this
proposal that views (such as <code>adjacent_transform_view</code>) that
use a <em><code>movable-box</code></em><code>&lt;F&gt;</code> member to
represent a function object may have performance issues, due to
<em><code>movable-box</code></em><code>&lt;F&gt;</code> being not
trivially copyable even for some cases where <code>F</code> is trivially
copyable. On the other hand, the existing
<code>adjacent_difference</code> with the default binary operation
(subtraction) could be covered with the trivially copyable
<code>std::minus</code> function object.</p>
<p>In our experience, adjacent differences or their generalization are
often used in combination with other ranges. For example,
finite-difference methods (such as Runge-Kutta schemes) for solving
time-dependent differential equations may need to add together multiple
ranges, each of which is an adjacent difference possibly composed with
other functions. If users want to express that as a one-pass algorithm,
they might need to combine more than two input ranges, possibly using a
combination of <code>transform_view</code>s and
<code>adjacent_transform_view</code>s. This ultimately would be hard to
express as a single “<code>ranges::adjacent_transform</code>” algorithm
invocation. Furthermore, <code>ranges::adjacent_transform</code> is
necessarily single-dimensional. It could not be used straightforwardly
for finite-difference methods for solving partial differential
equations, for example. All this makes an
<code>adjacent_transform</code> algorithm a lower-priority task.</p>
<p>We do not propose <code>adjacent_transform</code> for the reasons
described above.</p>
<h4 data-number="3.1.7.3" id="partial_sum"><span class="header-section-number">3.1.7.3</span> <code>partial_sum</code><a href="#partial_sum" class="self-link"></a></h4>
<p>The <code>partial_sum</code> algorithm combines elements
sequentially, from left to right. It behaves like an order-constrained
version of <code>inclusive_scan</code>.</p>
<p>Our proposal focuses on algorithms that permit reordering binary
operations. For users who want an order-constrained partial sum, <span class="citation" data-cites="P3351R2">[<a href="#ref-P3351R2" role="doc-biblioref"><strong>P3351R2?</strong></a>]</span>,
“<code>views::scan</code>,” proposes a view with the same left-to-right
behavior. This paper is currently in SG9 (Ranges Study Group)
review.</p>
<p>Users of <code>partial_sum</code> who are not concerned about the
order of operations can call the <code>inclusive_scan</code> algorithm
(proposed here) instead. We considered adding a convenience wrapper for
the same special case of an inclusive prefix plus-scan that
<code>partial_sum</code> supports. However, names like
<code>partial_sum</code> or <code>prefix_sum</code> would obscure
whether this is an inclusive or exclusive scan. Also, the existing
<code>partial_sum</code> algorithm operates left-to-right. A new
algorithm with the same name and almost the same interface, but with a
different order of operations, could be misleading. We think it’s not a
very convenient convenience wrapper if users have to look up its
behavior every time they use it.</p>
<p>If WG21 did want a convenience wrapper, one option would be to give
this common use case a longer but more explicit name, like
<code>inclusive_sum_scan</code>.</p>
<h3 data-number="3.1.8" id="we-dont-propose-the-lost-algorithm-noncommutative-parallel-reduce"><span class="header-section-number">3.1.8</span> We don’t propose “the lost
algorithm” (noncommutative parallel reduce)<a href="#we-dont-propose-the-lost-algorithm-noncommutative-parallel-reduce" class="self-link"></a></h3>
<p>The Standard lacks an analog of <code>reduce</code> that can assume
associativity but not commutativity of binary operations. One author of
this proposal refers to this as “the lost algorithm.” (Please refer to
<a href="https://adspthepodcast.com/2021/05/14/Episode-25.html">Episode
25 of “ASDP: The Podcast”</a>.) We do not propose this algorithm, but we
would welcome a separate proposal to do so.</p>
<p>The current numeric algorithms express a variety of permissions to
reorder binary operations.</p>
<ul>
<li><code>accumulate</code> and <code>partial_sum</code> both precisely
specify the order of binary operations as sequential, from left to
right. This works even if the binary operation is neither associative
nor commutative.</li>
<li>The various <code>*_scan</code> algorithms can reorder binary
operations as if they are associative (they may replace
<code>a + (b + c)</code> with <code>(a + b) + c</code>), but not as if
they are commutative (they may replace <code>a + b</code> with
<code>b + a</code>).</li>
<li><code>reduce</code> can reorder binary operations as if they are
both associative and commutative.</li>
</ul>
<p>What’s missing here is a parallel analog of <code>reduce</code> with
the assumptions of <code>*_scan</code>, that is, a reduction that can
assume associativity but not commutativity of binary operations.
Parallel reduction operations with these assumptions exist in other
programming models. For example, MPI (the Message Passing Interface for
distributed-memory parallel communication) has a function
<code>MPI_Create_op</code> for defining custom reduction operators from
a user’s function. <code>MPI_Create_op</code> has a parameter that
specifies whether MPI may assume that the user’s function is
commutative.</p>
<p>Users could get that parallel algorithm by calling
<code>*_scan</code> with an extra output sequence, and using only the
last element. However, this requires extra storage.</p>
<p>A concepts-based approach like <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span>’s could permit specializing
<code>reduce</code> on whether the user asserts that the binary
operation is commutative. <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span> does not attempt to do this; it
merely specializes <code>reduce</code> on whether the associative and
commutative operation has a two-sided identity element. Furthermore,
<span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span> does not offer a way for users
to assert that an operation is associative or commutative, because the
<code>magma</code> (nonassociative) and <code>semigroup</code>
(associative) concepts do not differ syntactically. One could imagine a
refinement of this design that includes a trait for users to specialize
on the type of their binary operation, say
<code>is_commutative&lt;BinaryOp&gt;</code>. This would be analogous to
the <code>two_sided_identity</code> trait in <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span> that lets users declare that
their set forms a monoid, a refinement of <code>semigroup</code> with a
two-sided identity element.</p>
<p>This proposal leaves the described algorithm out of scope. We think
the right way would be to propose a new algorithm with a distinct name.
A reasonable choice of name would be <code>fold</code> (just
<code>fold</code> by itself, not <code>fold_left</code> or
<code>fold_right</code>).</p>
<h3 data-number="3.1.9" id="no-reduce-with-iter"><span class="header-section-number">3.1.9</span> We don’t propose
<code>reduce_with_iter</code><a href="#no-reduce-with-iter" class="self-link"></a></h3>
<p>A hypothetical <code>reduce_with_iter</code> algorithm would look
like <code>fold_left_with_iter</code>, but would permit reordering of
binary operations. It would return both an iterator to one past the last
input element, and the computed value. The only reason for a reduction
to return an iterator would be if the input range is single-pass.
However, users who have a single-pass input range really should be using
one of the <code>fold*</code> algorithms instead of
<code>reduce*</code>. As a result, we do not propose the analogous
<code>reduce_with_iter</code> here.</p>
<p>Note that the previous paragraph effectively argues for
<code>*reduce</code> to require at least forward ranges.</p>
<p>Just like <code>fold_left</code>, the <code>reduce</code> algorithm
should return just the computed value. Section 4.4 of <span class="citation" data-cites="P2322R6">[<a href="#ref-P2322R6" role="doc-biblioref"><strong>P2322R6?</strong></a>]</span> argues that
this makes it easier to use, and improves consistency with other
<code>ranges</code> algorithms like <code>ranges::count</code> and
<code>ranges::any_of</code>. It is also consistent with <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span>. Furthermore,
even if a <code>reduce_with_iter</code> algorithm were to exist,
<code>reduce</code> should not be specified in terms of it. This is for
performance reasons, as Section 4.4 of <span class="citation" data-cites="P2322R6">[<a href="#ref-P2322R6" role="doc-biblioref"><strong>P2322R6?</strong></a>]</span> elaborates
for <code>fold_left</code> and <code>fold_left_with_iter</code>.</p>
<h3 data-number="3.1.10" id="we-dont-propose-reduce_first"><span class="header-section-number">3.1.10</span> We don’t propose
<code>reduce_first</code><a href="#we-dont-propose-reduce_first" class="self-link"></a></h3>
<p>Section 5.1 of <span class="citation" data-cites="P2760R1">[<a href="#ref-P2760R1" role="doc-biblioref"><strong>P2760R1?</strong></a>]</span> asks whether
the Standard Library should have a <code>reduce_first</code> algorithm.
Analogously to <code>fold_left_first</code>, <code>reduce_first</code>
would use the first element of the range as the initial value of the
reduction operation. One application of <code>reduce_first</code> is to
support binary operations that lack a natural identity element to serve
as the initial value. An example would be <code>min</code> on a range of
<code>int</code> values, where callers would have no way to tell if
<code>INT_MAX</code> represents an actual value in the range, or a fake
“identity” element (that callers may get as a result when the range is
empty).</p>
<p>We do not propose <code>reduce_first</code> here; we just outline
arguments against and for adding it.</p>
<h4 data-number="3.1.10.1" id="arguments-against-reduce_first"><span class="header-section-number">3.1.10.1</span> Arguments against
<code>reduce_first</code><a href="#arguments-against-reduce_first" class="self-link"></a></h4>
<ol type="1">
<li><span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> already
proposes parallel ranges overloads of <code>min_element</code>,
<code>max_element</code>, and <code>minmax_element</code>. Minima and
maxima are the main use cases that lack a natural identity element.</li>
<li>Users could always implement <code>reduce_first</code> themselves,
by extracting the first element from the sequence and using it as the
initial value in <code>reduce</code>.</li>
<li>In practice, most custom binary operations have some value that can
work like a neutral initial value, even if it’s not mathematically the
identity.</li>
<li>Unlike <code>fold_left_first*</code> and
<code>fold_right_last</code>, the <code>*reduce</code> algorithms are
unordered. As a result, there is no reason to privilege the first (or
last) element of the range. One could imagine an algorithm
<code>reduce_any</code> that uses any element of the range as its
initial value.</li>
<li>For parallel execution, <code>reduce_first</code> does not fully
address lack of identity, and potentially creates a suboptimal execution
flow. See <a href="#initial-value-vs-identity"></a> for more detailed
analysis.</li>
</ol>
<h4 data-number="3.1.10.2" id="arguments-for-reduce_first"><span class="header-section-number">3.1.10.2</span> Arguments for
<code>reduce_first</code><a href="#arguments-for-reduce_first" class="self-link"></a></h4>
<ol type="1">
<li>Some equivalent of <code>reduce_first</code> can be used as a
building block for parallel reduction with unknown identity, if no other
solution is proposed.</li>
<li>Even though <code>min_element</code>, <code>max_element</code>, and
<code>minmax_element</code> exist, users may still want to combine
multiple reductions into a single pass, where some of the reductions are
min and/or max, while others have a natural identity.</li>
</ol>
<p>As an example of combining multiple reductions into a single pass,
users may want the minimum of an array of integers (with no natural
identity), along with the least index of the array element with the
minimum value (whose natural identity is zero). This happens often
enough that MPI (the Message Passing Interface for distributed-memory
parallel computing) has predefined reduction operations for minimum and
its index (<code>MINLOC</code>) and maximum and its index
(<code>MAXLOC</code>). On the other hand, even <code>MINLOC</code> and
<code>MAXLOC</code> have reasonable choices of fake “identity” elements
that work in practice, e.g., for <code>MINLOC</code>,
<code>INT_MAX</code> for the minimum value and <code>INT_MAX</code> for
the least array index (where users are responsible for testing that the
returned array index is in bounds).</p>
<h2 data-number="3.2" id="range-categories-and-return-types"><span class="header-section-number">3.2</span> Range categories and return
types<a href="#range-categories-and-return-types" class="self-link"></a></h2>
<p>We propose the following.</p>
<ul>
<li><p>Our parallel algorithms take sized random access ranges (except
for output ranges of “<code>_into</code>” algorithms, which are sized
forward ranges; see above).</p></li>
<li><p>Our non-parallel algorithms take sized forward ranges.</p></li>
<li><p>Our scans’ return type is an alias of
<code>in_out_result</code>.</p></li>
<li><p>Our reductions just return the reduction value, not
<code>in_value_result</code> with an input iterator.</p></li>
</ul>
<p><span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> does not aim
for perfect consistency with the range categories accepted by existing
<code>ranges</code> algorithms. The algorithms proposed by <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> differ in the
following ways.</p>
<ol type="1">
<li><span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> uses a range,
not an iterator, as the output parameter (see Section 2.7).</li>
<li><span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> requires that
the ranges be sized (see Section 2.8).</li>
<li><span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> requires
random access ranges (see Section 2.6).</li>
</ol>
<p>Of these differences, (1) and (2) could apply generally to all
<code>ranges</code> algorithms, so we adopt them for this proposal.</p>
<p>Regarding (1), this would make our proposal the first to add
non-parallel range-as-output <code>ranges</code> algorithms to the
Standard. For arguments in favor of non-parallel algorithms taking a
range as output, please refer to <span class="citation" data-cites="P3490R0">[<a href="#ref-P3490R0" role="doc-biblioref"><strong>P3490R0?</strong></a>]</span>,
“Justification for ranges as the output of parallel range algorithms.”
(Despite the title, it has things to say about non-parallel algorithms
too.) Taking a range as output would prevent use of existing output-only
iterators that do not have a separate sized sentinel type, like
<code>std::back_insert_iterator</code>. However, all the algorithms we
propose require at least forward iterators (see below). <span class="citation" data-cites="P3490R0">[<a href="#ref-P3490R0" role="doc-biblioref"><strong>P3490R0?</strong></a>]</span> shows that it
is possible for both iterator-as-output and range-as-output overloads to
coexist, so we follow <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> by not
proposing iterator-as-output algorithms here.</p>
<p>Regarding (2), we make the parallel algorithms proposed here take
sized random access ranges, as <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> does. For
consistency, we also propose that the output ranges model
<code>sized_range</code>. As a result, any parallel algorithms with an
output range need to return both an iterator to one past the last
element of the output, and an iterator to one past the last element of
the input. This tells callers whether there was enough room in the
output, and if not, where to start when processing the rest of the
input. This includes all the <code>*{ex,in}clusive_scan</code>
algorithms we propose.</p>
<p>Difference (3) relates to <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> only
proposing parallel algorithms. It would make sense for us to relax this
requirement for the non-parallel algorithms we propose. This leaves us
with two possibilities:</p>
<ol type="1">
<li><p>(single-pass) input and output ranges, the most general;
or</p></li>
<li><p>(multipass) forward ranges.</p></li>
</ol>
<p>We believe there is no value in <code>*reduce</code> and
<code>*_scan</code> taking single-pass input ranges, because these
algorithms can combine the elements of their input range(s) in any
order. Suppose that an algorithm had that freedom to rearrange
operations, yet was constrained to read the input ranges exactly once,
in left-to-right order. The only way such an algorithm could exploit
that freedom would be for it to copy the input ranges into temporary
storage. Users who want that could just copy the input ranges into
contiguous storage themselves.</p>
<p>For this reason, we make the non-parallel algorithms take (multipass)
forward ranges, even though this is not consistent with the existing
non-parallel <code>&lt;numeric&gt;</code> algorithms. If users have
single-pass iterators, they should just call one of the
<code>fold_*</code> algorithms, or use <code>views::scan</code> proposed
in <span class="citation" data-cites="P3351R2">[<a href="#ref-P3351R2" role="doc-biblioref"><strong>P3351R2?</strong></a>]</span>. This has the
benefit of letting us specify <code>ranges::reduce</code> to return just
the value. We don’t propose a separate <code>reduce_with_iter</code>
algorithm to return both the value and the one-past-the-input iterator,
as we explain <a href="#no-reduce-with-iter">in the relevant
section</a>.</p>
<h2 data-number="3.3" id="constexpr-parallel-algorithms"><span class="header-section-number">3.3</span> Constexpr parallel
algorithms?<a href="#constexpr-parallel-algorithms" class="self-link"></a></h2>
<p><span class="citation" data-cites="P2902R2">[<a href="#ref-P2902R2" role="doc-biblioref"><strong>P2902R2?</strong></a>]</span> proposes to
add <code>constexpr</code> to the parallel algorithms. <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> does not
object to this; see Section 2.10. We continue the approach of <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> in not
opposing <span class="citation" data-cites="P2902R2">[<a href="#ref-P2902R2" role="doc-biblioref"><strong>P2902R2?</strong></a>]</span>’s approach,
but also not depending on it.</p>
<h2 data-number="3.4" id="initial-value-vs-identity"><span class="header-section-number">3.4</span> Specifying an identity for
reductions and scans<a href="#initial-value-vs-identity" class="self-link"></a></h2>
<h3 data-number="3.4.1" id="summary-1"><span class="header-section-number">3.4.1</span> Summary<a href="#summary-1" class="self-link"></a></h3>
<p>We propose adding a way for users to <em>specify an identity
value</em> (or pseudoidentity value; see below) of a binary operation
for reductions and scans. This would give parallel implementations a
value to use for initializing each execution agent’s accumulator.</p>
<p>Parallel reductions and scans don’t <em>need</em> an identity. Their
C++17 versions work fine without it. Not every (mathematically
associative and commutative) binary operator has an identity, and
figuring out a pseudoidentity may be difficult or impossible. Thus, we
propose that the <em>identity be optional</em>.</p>
<p>All C++17 reductions and scans have an initial value parameter. It’s
optional for all algorithms except <code>exclusive_scan</code> and
<code>transform_exclusive_scan</code>, as they require it in order to
make mathematical sense. It has performance benefits for
<code>inclusive_scan</code> and <code>transform_inclusive_scan</code>.
Thus, we propose that the ranges versions of scans take <em>both an
initial value</em> (optional for inclusive scans, required for exclusive
scans) <em>and an identity</em> (always optional).</p>
<p>For reductions, if an identity is not available, then users need a
way to provide an initial value in order to control the return type,
which is also the type used for intermediate computations. Also, given
that the identity is an optimization hint rather than something needed
for functionality, reductions should behave in the same way (assuming
that the binary operator is associative and commutative) whether or not
an identity is available. This implies that <em>users should be allowed
to provide</em> <em>both an initial value and an identity</em>. In order
to avoid ambiguity in determining the return type, we propose that if
ranges <code>reduce</code> and <code>transform_reduce</code> get both an
initial value and an identity, then</p>
<ul>
<li><p>either the identity and the initial value type are the
same,</p></li>
<li><p>or the identity and the range value type are the same.</p></li>
</ul>
<p>Given that we permit both reductions and scans to accept both an
initial value and an identity, the interface for providing an identity
must help users distinguish it from the initial value. It should also
help users see the connection between the identity and the binary
operator to which it applies. This matters especially for binary
<code>transform_reduce</code>, as it takes two binary operators, but the
identity would only apply to one of them. We propose</p>
<ul>
<li><p>a <em>trait for determining whether a binary operator</em>
<em>has a known identity value</em>,</p></li>
<li><p>a <em>trait for extracting an identity value</em>, if it exists,
from the binary operator, and</p></li>
<li><p>a <em>“wrapper binary operator”</em> that attaches an identity
value to the user’s binary operator (which may be a lambda or some other
type that the user does not control).</p></li>
</ul>
<p>Users may want to specify a <em>compile-time identity value</em>,
that is, a value that is guaranteed to be known at compile time because
it results from a <code>static constexpr</code> member function of the
parameter’s type. Examples include the conversion operator of
<code>constant_wrapper</code> and <code>integral_constant</code>.<br />
The above interface works with this no differently than with a “run-time
identity value,” because we deduce the return type like
<code>fold_first</code> does, rather than just making the initial value
type the return type like C++17’s <code>std::reduce</code>.</p>
<h3 data-number="3.4.2" id="initial-value-of-a-reduction-or-scan"><span class="header-section-number">3.4.2</span> Initial value of a reduction
or scan<a href="#initial-value-of-a-reduction-or-scan" class="self-link"></a></h3>
<p>C++17’s <code>reduce</code>, <code>transform_reduce</code>, and
<code>*_scan</code> algorithms all take an initial value parameter
<code>T init</code>. This exists for two reasons.</p>
<ol type="1">
<li><p>For <code>reduce</code> and <code>transform_reduce</code>, it
defines the algorithm’s return type, and also the type that the
implementation uses for intermediate results.</p></li>
<li><p>For <code>*_scan</code>, it is included in the terms of every
partial sum. This can save a pass over the range.</p></li>
<li><p>For <code>reduce</code> and <code>transform_reduce</code>, it
lets users express a “running reduction” where the whole range is not
available all at once and users need to call <code>reduce</code>
repeatedly.</p></li>
</ol>
<p>Both <code>exclusive_scan</code> and
<code>transform_exclusive_scan</code> require an initial value. This is
because the first element of the output range is just the initial value.
For the other algorithms, the initial value is optional and defaults to
<code>T{}</code>, a value-initialized <code>T</code> value.</p>
<h3 data-number="3.4.3" id="identity-value-of-a-reduction-or-scans-binary-operator"><span class="header-section-number">3.4.3</span> Identity value of a reduction
or scan’s binary operator<a href="#identity-value-of-a-reduction-or-scans-binary-operator" class="self-link"></a></h3>
<p>The initial value of a reduction or scan is not necessarily the same
as an identity value of the reduction’s or scan’s binary operator. An
<em>identity value</em> <code>id</code> of a binary operator
<code>bop</code> is a value such that <code>bop(x, id)</code> equals
<code>bop(id, x)</code> equals <code>x</code> for all valid arguments
<code>x</code> of <code>bop</code>. Including an identity value an
arbitrary number of times in a reduction does not change the reduction’s
result.</p>
<p>We say “an” identity value because it need not be unique. The
identity value can serve as an initial value, but not vice versa. The
following example illustrates.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> v<span class="op">{</span><span class="fl">5.0</span><span class="bu">f</span>, <span class="fl">7.0</span><span class="bu">f</span>, <span class="fl">11.0</span><span class="bu">f</span><span class="op">}</span>;</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Default initial value is float{}, which is 0.0f.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">// It is also the identity for std::plus&lt;&gt;, the default operation.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> result <span class="op">=</span> std<span class="op">::</span>reduce<span class="op">(</span>v<span class="op">.</span>begin<span class="op">()</span>, v<span class="op">.</span>end<span class="op">())</span>;</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result <span class="op">==</span> <span class="fl">23.0</span><span class="bu">f</span><span class="op">)</span>;</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Initial value happens to be the identity in this case.</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> std<span class="op">::</span>reduce<span class="op">(</span>v<span class="op">.</span>begin<span class="op">()</span>, v<span class="op">.</span>end<span class="op">()</span>, <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span>;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result <span class="op">==</span> <span class="fl">23.0</span><span class="bu">f</span><span class="op">)</span>;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Initial value is NOT the identity in this case.</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> result_plus_3 <span class="op">=</span> std<span class="op">::</span>reduce<span class="op">(</span>v<span class="op">.</span>begin<span class="op">()</span>, v<span class="op">.</span>end<span class="op">()</span>, <span class="fl">3.0</span><span class="bu">f</span><span class="op">)</span>;</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_plus_3 <span class="op">==</span> <span class="fl">26.0</span><span class="bu">f</span><span class="op">)</span>;</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Including arbitrarily many copies of the identity element</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="co">// does not change the reduction result.</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> v2<span class="op">{</span><span class="fl">5.0</span><span class="bu">f</span>, <span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">7.0</span><span class="bu">f</span>, <span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">11.0</span><span class="bu">f</span>, <span class="fl">0.0</span><span class="bu">f</span><span class="op">}</span>;</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> std<span class="op">::</span>reduce<span class="op">(</span>v<span class="op">.</span>begin<span class="op">()</span>, v<span class="op">.</span>end<span class="op">())</span>;</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result <span class="op">==</span> <span class="fl">23.0</span><span class="bu">f</span><span class="op">)</span>;</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> std<span class="op">::</span>reduce<span class="op">(</span>v<span class="op">.</span>begin<span class="op">()</span>, v<span class="op">.</span>end<span class="op">()</span>, <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span>;</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result <span class="op">==</span> <span class="fl">23.0</span><span class="bu">f</span><span class="op">)</span>;</span></code></pre></div>
<h3 data-number="3.4.4" id="identity-may-not-exist-or-may-be-unknown"><span class="header-section-number">3.4.4</span> Identity may not exist or may
be unknown<a href="#identity-may-not-exist-or-may-be-unknown" class="self-link"></a></h3>
<p>Not every binary operator has an identity. For instance, integers
have no identity for the maximum operation. (For floating-point numbers,
<code>-Inf</code> serves as an identity for maximum.) Adoption of
<code>ranges::max_element</code> in <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> mitigates
this, but only partially. This is because users commonly compose
multiple binary operations into a single reduction. If one of those
binary operations has no identity, then the composed operation does not
either. The following <code>max_and_sum</code> operation that computes
the maximum and sum of a range of integers is an example.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> max_and_sum_result <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int64_t</span> max <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int64_t</span> sum <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> max_and_sum <span class="op">{</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  max_and_sum_result</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span>max_and_sum_result u, max_and_sum_result v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>std<span class="op">::</span>max<span class="op">(</span>u<span class="op">.</span>max, v<span class="op">.</span>max<span class="op">)</span>, u<span class="op">.</span>sum <span class="op">+</span> v<span class="op">.</span>sum<span class="op">}</span>;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  max_and_sum_result</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span>max_and_sum_result u, <span class="dt">int32_t</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">)(</span>u, max_and_sum_result<span class="op">{</span>y, y<span class="op">})</span>;</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>  max_and_sum_result</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span><span class="dt">int32_t</span> x, max_and_sum_result v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">)(</span>max_and_sum_result<span class="op">{</span>x, x<span class="op">}</span>, v<span class="op">)</span>;</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>  max_and_sum_result <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span><span class="dt">int32_t</span> x, <span class="dt">int32_t</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">)(</span>max_and_sum_result<span class="op">{</span>x, x<span class="op">}</span>,</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>                   max_and_sum_result<span class="op">{</span>y, y<span class="op">})</span>;</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>forward_range Range<span class="op">&gt;</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>max_and_sum_result inf_and_one_norm<span class="op">(</span>Range<span class="op">&amp;&amp;</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ranges<span class="op">::</span>reduce<span class="op">(</span>in, max_and_sum<span class="op">{})</span>;</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The binary operator <code>max_and_sum</code> has no identity, because
integers have no identity for the maximum operation. However, if a range
is nonempty and its first element is <code>x_0</code>,
<code>max_and_sum_result{x_0, 0}</code> works like an identity for the
range, even though it is not an identity for the binary operator
<code>max_and_sum</code>. We call this value a <em>pseudoidentity</em>
of the binary operator and range. It’s an interesting mathematical
question whether every (mathematically associative and commutative)
binary operator and nonempty range together have a pseudoidentity. Even
if it does, determining a pseudoidentity might not be obvious to users.
Users also might not want to access elements of the range outside of a
parallel algorithm, for performance reasons.</p>
<h4 data-number="3.4.4.1" id="do-not-assume-that-t-value-initialized-t-is-an-identity"><span class="header-section-number">3.4.4.1</span> Do not assume that
<code>T{}</code> (value-initialized <code>T</code>) is an identity<a href="#do-not-assume-that-t-value-initialized-t-is-an-identity" class="self-link"></a></h4>
<p>The identity value of a binary operator that returns <code>T</code>
need not necessarily be <code>T{}</code> (a value-constructed
<code>T</code>) for all operators and types.</p>
<ul>
<li><p>For <code>std::multiplies{}</code> it’s
<code>T(1)</code>.</p></li>
<li><p>For “addition” in the max-plus (“tropical”) semiring it’s
<code>-Inf</code>.</p></li>
</ul>
<p>We don’t want to force users to wrap reduction result types so that
<code>T{}</code> defines the identity (if it exists) for
<code>operator+(T, T)</code>.</p>
<ul>
<li><p>What if there is no identity or the user does not know
it?</p></li>
<li><p>What if <code>T</code> differs from the input range’s value
type?</p></li>
<li><p>What if users want to use the same value type for different
binary operators, such as <code>double</code> as the value type for
<code>plus</code>, <code>multiplies</code>, and
<code>ranges::max</code>?</p></li>
<li><p>If we make users write a nondefaulted default constructor for
<code>T</code>, they are more likely to make <code>T</code> not
trivially constructible, and thus hinder optimizations.</p></li>
</ul>
<p>Note that this differs from std::linalg’s algorithms, where “[a]
value-initialized object of linear algebra value type shall act as the
additive identity” ([linalg.reqs.val] 3). However, std::linalg does not
take user-defined binary operators; it always uses
<code>operator+</code> for reductions. Also, std::linalg needs “zero”
for reasons other than reductions, e.g., for supporting user-defined
complex number types (<em><code>imag-if-needed</code></em>). For these
reasons, we think it’s reasonable to make a different design choice for
numeric range algorithms than for <code>std::linalg</code>.</p>
<h3 data-number="3.4.5" id="initial-value-matters-most-for-sequential-reduction"><span class="header-section-number">3.4.5</span> Initial value matters most
for sequential reduction<a href="#initial-value-matters-most-for-sequential-reduction" class="self-link"></a></h3>
<p>Users who never use parallel reductions may miss the importance of
the reduction identity. Let’s consider typical code that sums elements
of an indexed array.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> sum<span class="op">(</span>std<span class="op">::</span>span<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> s <span class="op">=</span> <span class="fl">0.0</span><span class="bu">f</span>;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span>; i <span class="op">&lt;</span> a<span class="op">.</span>size<span class="op">()</span>; <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> a<span class="op">[</span>i<span class="op">]</span>;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> s;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The identity element <code>0.0f</code> is used to initialize the
<em>accumulator</em> into which the array’s values are summed. It
defines both the type of the accumulator (<code>float</code>, in this
case), and its initial value. If an initial value for the reduction is
provided, it replaces the identity in the code above. A serial
implementation of <code>reduce</code> therefore does not need to know
its binary operation’s identity when an initial value is provided.</p>
<p>The initial value parameter of <code>reduce</code> also lets users
express a “running reduction” where the whole range is not available all
at once and users need to call <code>reduce</code> repeatedly. However,
this is not so useful, because users already have the binary operator
and the reduction result; they can always include more terms themselves
without additional cost.</p>
<h3 data-number="3.4.6" id="identity-matters-most-for-parallel-reduction"><span class="header-section-number">3.4.6</span> Identity matters most for
parallel reduction<a href="#identity-matters-most-for-parallel-reduction" class="self-link"></a></h3>
<p>The situation is different for parallel execution, because more than
one accumulator must be initialized. Any parallel reduction somehow
distributes the data over multiple threads of execution, where each
thread uses a local accumulator for its part of the job. The initial
value can be used to initialize at most one of those accumulators; for
the others, something else is needed.</p>
<p>If an identity <code>id</code> for a binary operator <code>op</code>
is known, then here is a natural way to parallelize
<code>reduce(</code><span class="math inline"><em>R</em></span><code>, init, op)</code> over <span class="math inline"><em>P</em></span> processors using the serial
version as a building block.</p>
<ol type="1">
<li>Partition the range <span class="math inline"><em>R</em></span> into
<span class="math inline"><em>P</em></span> distinct subsequences <span class="math inline"><em>S</em><sub><em>p</em></sub></span>.</li>
<li>On each processor <span class="math inline"><em>p</em></span>
compute a local result <span class="math inline"><em>L</em><sub><em>p</em></sub></span>
<code>= reduce(</code><span class="math inline"><em>S</em><sub><em>p</em></sub></span><code>, id, op)</code>
(with <code>id</code> as the initial value).</li>
<li>Reduce over the local results <span class="math inline"><em>L</em><sub><em>p</em></sub></span> with
<code>init</code> as the initial value.</li>
</ol>
<p>It’s not the only and not necessarily the best way though. For
example, a SIMD-based implementation for the <code>unseq</code> policy
likely would not call the serial algorithm, yet it would need to
initialize a local accumulator for each SIMD lane.</p>
<h3 data-number="3.4.7" id="how-to-initialize-each-local-accumulator-without-an-identity"><span class="header-section-number">3.4.7</span> How to initialize each local
accumulator without an identity<a href="#how-to-initialize-each-local-accumulator-without-an-identity" class="self-link"></a></h3>
<p>What if the identity is unknown or does not exist? What happens to a
parallel implementation of C++17 <code>std::reduce</code> with a
user-defined binary operation? There are two other ways to initialize
each local accumulator.</p>
<ol type="1">
<li>With some value from that subsequence, such as the first one. (For
example, one could use a hypothetical <code>reduce_first</code>
algorithm as a sequential building block of parallel
<code>reduce</code>.)</li>
<li>With the result of applying the binary operation to two values from
the subsequence.</li>
</ol>
<p>The type requirements of <code>std::reduce</code> seem to assume the
second approach, as the type of the result is not required to be
copy-constructible.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// using random access iterators for simplicity</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sum <span class="op">=</span> std<span class="op">::</span>move<span class="op">(</span>op<span class="op">(</span>first<span class="op">[</span><span class="dv">0</span><span class="op">]</span>, first<span class="op">[</span><span class="dv">1</span><span class="op">])))</span>;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> sz <span class="op">=</span> last <span class="op">-</span> first;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">2</span>; i <span class="op">&lt;</span> sz; <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  sum <span class="op">=</span> std<span class="op">::</span>move<span class="op">(</span>op<span class="op">(</span>sum, first<span class="op">[</span>i<span class="op">]))</span>;</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>While technically doable, this approach may be suboptimal. In many
use cases, the iteration space and the data storage are aligned (e.g.,
to <code>std::hardware_constructive_interference_size</code> or to the
SIMD width) to allow for more efficient hardware use. The loop bound
changes shown above break this alignment. This may affect code
efficiency.</p>
<h3 data-number="3.4.8" id="other-parallel-programming-models"><span class="header-section-number">3.4.8</span> Other parallel programming
models<a href="#other-parallel-programming-models" class="self-link"></a></h3>
<p>Other parallel programming models provide all combinations of design
options. Some compute only <code>reduce_first</code>, some only
<code>reduce</code>, and some compute both. Some have a way to specify
only an identity element, some only an initial value, and some both.</p>
<p>MPI (the Message Passing Interface for distributed-memory parallel
communication) has reductions and lets users define custom binary
operations. MPI’s reductions compute the analog of
<code>reduce_first</code>. Users have no way to specify either an
initial value or an identity for their custom operations.</p>
<p>In the <a href="https://j3-fortran.org/doc/year/23/23-007r1.pdf">Draft Fortran
2023 Standard</a>, the <code>REDUCE</code> clause permits specification
of an identity element.</p>
<p>OpenMP lets users specify the identity value (via an
<em>initializer-clause</em>
<code>initializer(</code><em>initializer-expr</em><code>)</code>), which
is “used as the initializer for private copies of reduction list items”
(see Section 7.6.2 of the <a href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-6-0.pdf">OpenMP
6.0 specification</a>). Per Section 7.6.6, the identity’s type must
satisfy one of the following two concepts: either</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span><span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  T<span class="op">()</span>;</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  t <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span><span class="op">()</span> <span class="op">{</span> T<span class="op">(</span><span class="dv">0</span><span class="op">)</span>; <span class="op">}</span>;</span></code></pre></div>
<p>Kokkos lets users define the identity value for custom reduction
result types, by giving the reducer class an
<code>init(value_type&amp; value)</code> member function that sets
<code>value</code> to the identity (see the <a href="https://kokkos.org/kokkos-core-wiki/ProgrammingGuide/Custom-Reductions-Custom-Reducers.html">section
on custom reducers in the Kokkos Programming Guide</a>).</p>
<p>The oneTBB specification asks users to specify the identity value as
an argument to <code>parallel_reduce</code> function template (see the
<a href="https://oneapi-spec.uxlfoundation.org/specifications/oneapi/latest/elements/onetbb/source/algorithms/functions/parallel_reduce_func">relevant
oneTBB specification page</a>).</p>
<p>SYCL lets users specify the identity value by specializing
<code>sycl::known_identity</code> class template for a custom reduction
operation (see the <a href="https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:reduction">relevant
section of the SYCL specification</a>).</p>
<p>The <code>std::linalg</code> linear algebra library in the Working
Draft for C++26 says, “A value-initialized object of linear algebra
value type shall act as the additive identity” (<span class="unnumbered sref">linalg.reqs.val</span> 3).</p>
<p>In Python’s NumPy library, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ufunc.reduce.html"><code>numpy.ufunc.reduce</code></a>
takes optional initial values. If not provided and the binary operation
(a “universal function” (ufunc), effectively an elementwise binary
operation on a possibly multidimensional array) has an identity, then
the initial values default to the identity. If the binary operation has
no identity or the initial values are <code>None</code>, then this works
like <code>reduce_first</code>.</p>
<h3 data-number="3.4.9" id="implementations-may-use-a-default-identity-value-via-as-if-rule"><span class="header-section-number">3.4.9</span> Implementations may use a
default identity value via as-if rule<a href="#implementations-may-use-a-default-identity-value-via-as-if-rule" class="self-link"></a></h3>
<p>Implementations may use a default identity value for known cases,
like <code>std::plus</code> or <code>std::multiplies</code> with
arithmetic types.</p>
<h3 data-number="3.4.10" id="interface-for-specifying-identity"><span class="header-section-number">3.4.10</span> Interface for specifying
identity<a href="#interface-for-specifying-identity" class="self-link"></a></h3>
<h4 data-number="3.4.10.1" id="design-goals"><span class="header-section-number">3.4.10.1</span> Design goals<a href="#design-goals" class="self-link"></a></h4>
<ol type="1">
<li><p>Identity is an optional optimization</p></li>
<li><p>Avoid confusion with C++17 algorithms’ initial value</p></li>
<li><p>Let users specify a different binary operation and identity for
the same reduction result type</p></li>
<li><p>Let users specify an identity even if their binary operation is a
lambda</p></li>
<li><p>Let users specify a nondefault identity value “in line” with
invoking the algorithm, without needing to specialize a class</p></li>
</ol>
<p>Items 1 and 2 suggest that the identity should not be a separate
parameter <code>T id</code> of the algorithms. That would overly
emphasize an optimization hint, and it could result in confusion between
C++17 numeric algorithms and our new ranges numeric algorithms.</p>
<p>Items 3, 4, and 5 strongly suggest that we should not rely solely on
a compile-time trait for getting the identity value. Users need a way to
provide the identity value at run time. (For an example of a
compile-time trait system, please see the <a href="https://github.khronos.org/SYCL_Reference/iface/reduction-variables.html">“Reduction
Variables”</a> section of the SYCL Reference. SYCL requires users to
specify the identity as a <code>static constexpr</code> member of a
specialization of <code>known_identity</code> for their binary operator
type.)</p>
<h4 data-number="3.4.10.2" id="design-outline"><span class="header-section-number">3.4.10.2</span> Design outline<a href="#design-outline" class="self-link"></a></h4>
<p><a href="https://godbolt.org/z/hYq16PTob">Here is a prototype</a>
that shows three different designs, including this one.</p>
<ol type="1">
<li><p>Algorithms use a trait and a customization point to look for an
optional identity in the binary operator itself.</p>
<ol type="a">
<li><p>If <code>has_identity_value&lt;BinaryOperator&gt;</code> is
<code>true</code>, the algorithm can use
<code>identity_value&lt;range_value_t&lt;InRange&gt;&gt;(BinaryOperator)</code>
to get the operator’s identity.</p></li>
<li><p><code>identity_value</code> has an explicit template parameter so
that it can change its behavior based on the input range’s value type.
For example, <code>binary_operation&lt;Op, void&gt;</code> (see below)
returns a value-initialized value of the input range’s value
type.</p></li>
</ol></li>
<li><p>We provide a binary operator wrapper
<code>binary_operation</code> that lets users</p>
<ol type="a">
<li>specify the identity value,</li>
<li>say that the algorithm should assume that the identity does not
exist, or</li>
<li>let the algorithm pick a reasonable default.</li>
</ol></li>
<li><p>Users can also define their own binary operation types and
customizations of <code>identity_value</code>.</p></li>
</ol>
<p>The <code>binary_operation</code> wrapper is also a binary operation,
just like std::linalg’s <code>layout_transpose</code> is a valid mdspan
layout.</p>
<h5 data-number="3.4.10.2.1" id="no_identity_t-express-that-an-identity-doesnt-exist"><span class="header-section-number">3.4.10.2.1</span>
<code>no_identity_t</code>: Express that an identity doesn’t exist<a href="#no_identity_t-express-that-an-identity-doesnt-exist" class="self-link"></a></h5>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> no_identity_t <span class="op">{}</span>;</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> no_identity_t no_identity<span class="op">{}</span>;</span></code></pre></div>
<p>The <code>no_identity</code> tag expresses that an identity value
doesn’t exist or isn’t known for the given binary operator. Min and max
on integers both have this problem (as integers lack representations of
positive and negative infinity).</p>
<p>Having this lets us implement <code>ranges::min_element</code> and
<code>ranges::max_element</code> using <code>ranges::reduce</code>.</p>
<h5 data-number="3.4.10.2.2" id="binary_operation-binary-operation-wrapper-that-can-hold-identity-too"><span class="header-section-number">3.4.10.2.2</span>
<code>binary_operation</code>: Binary operation wrapper that can hold
identity too<a href="#binary_operation-binary-operation-wrapper-that-can-hold-identity-too" class="self-link"></a></h5>
<p>The <code>binary_operation</code> struct holds both the binary
operation, and an identity value, if the user provides one. Users can
construct it in three different ways.</p>
<ol type="1">
<li>Via CTAD, by providing a binary operator and identity value</li>
</ol>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>binary_operation bop<span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x, <span class="kw">auto</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> y; <span class="op">}</span>,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="fl">0.0</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<ol start="2" type="1">
<li>By specifying the template arguments and using <code>void</code> as
the identity type, which tells algorithms to use a value-initialized
<code>ranges_value_t&lt;R&gt;</code> as the identity</li>
</ol>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>binary_operation<span class="op">&lt;</span>std<span class="op">::</span>plus<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span>, <span class="dt">void</span><span class="op">&gt;</span> bop_void<span class="op">{}</span>;</span></code></pre></div>
<ol start="3" type="1">
<li>By specifying the binary operation and the <code>no_identity</code>
tag value, to indicate that the user wants the algorithm to assume that
the binary operation has no known identity</li>
</ol>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>binary_operation bop_no_id<span class="op">{</span>my_op, no_identity<span class="op">}</span>;</span></code></pre></div>
<p>A key feature of <code>binary_operation</code> is that it is a
working binary operation. That is, it has a call operator and it
forwards calls to the user’s binary operation. This is because the
identity is an optional optimization. Algorithms <em>could</em> just
call <code>binary_operation</code>’s call operator and ignore the
identity value, and they would get a correct answer.</p>
<p>Here is a sketch of the implementation of
<code>binary_operation</code>. We start with a base class
<code>binary_operation_base</code> that implements call operator
forwarding. It prefers the user’s const call operator if it exists; this
makes use of <code>binary_operation</code> in parallel algorithms
easier.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BinaryOp<span class="op">&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> binary_operation_base <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Arg0, <span class="kw">class</span> Arg1<span class="op">&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span>Arg0<span class="op">&amp;&amp;</span> arg0, Arg1<span class="op">&amp;&amp;</span> arg1<span class="op">)</span> <span class="kw">const</span> </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> std<span class="op">::</span>invocable<span class="op">&lt;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>add_const_t<span class="op">&lt;</span>BinaryOp<span class="op">&gt;</span>,</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>forward<span class="op">&lt;</span>Arg0<span class="op">&gt;(</span>arg0<span class="op">))</span>,</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>forward<span class="op">&lt;</span>Arg1<span class="op">&gt;(</span>arg1<span class="op">))&gt;</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> std<span class="op">::</span>as_const<span class="op">(</span>op<span class="op">)(</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>forward<span class="op">&lt;</span>Arg0<span class="op">&gt;(</span>arg0<span class="op">)</span>,</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>forward<span class="op">&lt;</span>Arg1<span class="op">&gt;(</span>arg1<span class="op">))</span>;</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Arg0, <span class="kw">class</span> Arg1<span class="op">&gt;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span>Arg0<span class="op">&amp;&amp;</span> arg0, Arg1<span class="op">&amp;&amp;</span> arg1<span class="op">)</span> </span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="op">(!</span> std<span class="op">::</span>invocable<span class="op">&lt;</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>add_const_t<span class="op">&lt;</span>BinaryOp<span class="op">&gt;</span>,</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>forward<span class="op">&lt;</span>Arg0<span class="op">&gt;(</span>arg0<span class="op">))</span>,</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>forward<span class="op">&lt;</span>Arg1<span class="op">&gt;(</span>arg1<span class="op">))&gt;)</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> op<span class="op">(</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>forward<span class="op">&lt;</span>Arg0<span class="op">&gt;(</span>arg0<span class="op">)</span>,</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>      std<span class="op">::</span>forward<span class="op">&lt;</span>Arg1<span class="op">&gt;(</span>arg1<span class="op">))</span>;</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> BinaryOp op;</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>The <code>binary_operation</code> struct has two template parameters:
the type of the binary operator, and the type of the identity.
<code>Identity</code> can be, say, <code>constant_wrapper</code> of the
value, not the actual value. This works because the accumulator type is
deduced from the operator result.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BinaryOp, <span class="kw">class</span> Identity<span class="op">&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> binary_operation <span class="op">:</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> binary_operation_base<span class="op">&lt;</span>BinaryOp<span class="op">&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> Identity id;</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>We value-initialize the identity by default, if its type supports
that. <code>Identity=no_identity_t</code> means that the binary operator
does not have an identity, or the user does not know an identity value.
It still gets “stored” in the struct so that the struct can remain an
aggregate. Otherwise, it would need a one-parameter constructor for that
case.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BinaryOp, <span class="kw">class</span> Identity<span class="op">&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span> <span class="kw">requires</span> <span class="op">{</span> Identity<span class="op">{}</span>; <span class="op">}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> binary_operation<span class="op">&lt;</span>BinaryOp, Identity<span class="op">&gt;</span> <span class="op">:</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> binary_operation_base<span class="op">&lt;</span>BinaryOp<span class="op">&gt;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> Identity id<span class="op">{}</span>;</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>As with <code>std::plus&lt;void&gt;</code>,
<code>Identity=void</code> means “the algorithm needs to deduce the
identity type and value.”</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BinaryOp<span class="op">&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> binary_operation<span class="op">&lt;</span>BinaryOp, <span class="dt">void</span><span class="op">&gt;</span> <span class="op">:</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> binary_operation_base<span class="op">&lt;</span>BinaryOp<span class="op">&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> BinaryOp op;</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>We define deduction guides so that algorithms by default do not
assume the existence of an identity.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BinaryOp, <span class="kw">class</span> Identity<span class="op">&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>binary_operation<span class="op">(</span>BinaryOp, Identity<span class="op">)</span> <span class="op">-&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  binary_operation<span class="op">&lt;</span>BinaryOp, Identity<span class="op">&gt;</span>;</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BinaryOp<span class="op">&gt;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>binary_operation<span class="op">(</span>BinaryOp<span class="op">)</span> <span class="op">-&gt;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  binary_operation<span class="op">&lt;</span>BinaryOp, no_identity_t<span class="op">&gt;</span>;</span></code></pre></div>
<p>Finally, we specialize <code>has_identity_value</code> and overload
<code>identity_value</code>. <code>Identity=void</code> means that
<code>binary_operation</code> itself does not specify the identity type
or value; rather, the algorithm must supply the type, and
<code>identity_value</code> returns a value-initialized object of that
type. This is why <code>identity_value</code> has a required
<code>InputRangeValueType</code> template parameter.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BinaryOp, <span class="kw">class</span> Identity<span class="op">&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> has_identity_value<span class="op">&lt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  binary_operation<span class="op">&lt;</span>BinaryOp, Identity<span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="kw">true</span>;</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BinaryOp<span class="op">&gt;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> has_identity_value<span class="op">&lt;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  binary_operation<span class="op">&lt;</span>BinaryOp, no_identity_t<span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="kw">false</span>;</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>std<span class="op">::</span>default_initializable InputRangeValueType,</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>         <span class="kw">class</span> BinaryOp<span class="op">&gt;</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>identity_value<span class="op">(</span><span class="kw">const</span> binary_operation<span class="op">&lt;</span>BinaryOp, <span class="dt">void</span><span class="op">&gt;&amp;)</span> <span class="op">{</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> InputRangeValueType<span class="op">{}</span>;</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> InputRangeValueType,</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>         <span class="kw">class</span> BinaryOp, <span class="kw">class</span> Identity<span class="op">&gt;</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(!</span> std<span class="op">::</span>is_same_v<span class="op">&lt;</span>Identity, no_identity_t<span class="op">&gt;)</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>identity_value<span class="op">(</span><span class="kw">const</span> binary_operation<span class="op">&lt;</span>BinaryOp, Identity<span class="op">&gt;&amp;</span> bop<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> bop<span class="op">.</span>id;</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h5 data-number="3.4.10.2.3" id="algorithm-overloads"><span class="header-section-number">3.4.10.2.3</span> Algorithm overloads<a href="#algorithm-overloads" class="self-link"></a></h5>
<p>The above infrastructure means that algorithms only need a
<code>BinaryOp</code> template parameter and <code>binary_op</code>
function parameter for the binary operator. Ability to use an identity
value if available does not increase the number of overloads. The
definitions of algorithms can use
<code>if constexpr(has_identity_value&lt;BinaryOp&gt;)</code> to
dispatch at compile time between code that uses the identity value and
code that does not.</p>
<h3 data-number="3.4.11" id="other-designs"><span class="header-section-number">3.4.11</span> Other designs<a href="#other-designs" class="self-link"></a></h3>
<h4 data-number="3.4.11.1" id="separate-wrapped-identity-parameter-op_identitytvalue"><span class="header-section-number">3.4.11.1</span> Separate wrapped identity
parameter: <code>op_identity&lt;T&gt;{value}</code><a href="#separate-wrapped-identity-parameter-op_identitytvalue" class="self-link"></a></h4>
<p>In this design, users supply an identity value by wrapping it in a
named struct <code>op_identity</code> and passing it in as a separate
optional argument that immediately follows the binary operator to which
it applies.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Identity<span class="op">=</span><span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> op_identity;</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Identity<span class="op">&gt;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> op_identity <span class="op">{</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> Identity id;</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>std<span class="op">::</span>default_initializable Identity<span class="op">&gt;</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> op_identity<span class="op">&lt;</span>Identity<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> Identity id<span class="op">{}</span>;</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> op_identity<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> <span class="op">{}</span>;</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> op_identity<span class="op">&lt;</span>no_identity_t<span class="op">&gt;</span> <span class="op">{}</span>;</span></code></pre></div>
<p>The <code>Identity</code> template parameter can be
<code>constant_wrapper</code> of the value, not the actual value. This
works because the accumulator type is deduced from the operator result.
The default template argument permits using <code>op_identity{}</code>
as an argument of <code>exclusive_scan</code>. As with
<code>binary_operation&lt;BinaryOp, void&gt;</code> above,
<code>Identity=void</code> tells the algorithm to deduce the identity
value as a value-initialized object of the input range’s value type.</p>
<p>It should be rare that users need to spell out
<code>op_identity&lt;no_identity_t&gt;</code>. Nevertheless, we include
an abbreviation <code>no_op_identity</code> to avoid duplicate
typing.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> op_identity<span class="op">&lt;</span>no_identity_t<span class="op">&gt;</span> no_op_identity<span class="op">{}</span>;</span></code></pre></div>
<p>We define a customization point <code>identity_value</code>
analogously to the way we defined it with the
<code>binary_operation</code> design above.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> InputRangeValueType, <span class="kw">class</span> Identity<span class="op">&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(!</span> std<span class="op">::</span>is_same_v<span class="op">&lt;</span>Identity, no_identity_t<span class="op">&gt;)</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> identity_value<span class="op">(</span>op_identity<span class="op">&lt;</span>Identity<span class="op">&gt;</span> op_id<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> op_id<span class="op">.</span>id;</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>std<span class="op">::</span>default_initializable InputRangeValueType<span class="op">&gt;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> identity_value<span class="op">(</span>op_identity<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> InputRangeValueType<span class="op">{}</span>;</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Users would have two ways to provide a nondefault identity value.</p>
<ol type="1">
<li><p>Construct <code>op_identity</code> with a default value using
aggregate initialization:
<code>op_identity{nondefault_value}</code></p></li>
<li><p>Specialize <code>op_identity&lt;T&gt;</code> so
<code>declval&lt;op_identity&lt;T&gt;&gt;().value</code> is the
value</p></li>
</ol>
<p>For example, users could inherit their specialization from
<code>constant_wrapper</code>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> impl <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="kw">constexpr</span> my_number some_value <span class="op">=</span> <span class="co">/* value goes here */</span>;</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> op_identity<span class="op">&lt;</span>my_number<span class="op">&gt;</span> <span class="op">:</span> </span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  constant_wrapper<span class="op">&lt;</span>impl<span class="op">::</span>some_value<span class="op">&gt;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="op">{}</span>;</span></code></pre></div>
<p>Here are some use cases.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">// User explicitly opts into &quot;most negative integer&quot;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">// as the identity for min.  This should not be the default,</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">// as the C++ Standard Library has no way to know</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">// whether this represents a valid input value.</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> lowest <span class="op">=</span> std<span class="op">::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>lowest<span class="op">()</span>;</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result5 <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span>exec_policy, range,</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>min, reduce_identity<span class="op">{</span>lowest<span class="op">})</span>;</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="co">// range_value_t&lt;R&gt; is float, but identity value is double</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="co">// (even though it&#39;s otherwise the default value, zero).</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co">// std::plus&lt;void&gt; should use operator()(double, double) -&gt; double</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result6 <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span>exec_policy, range,</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>plus<span class="op">{}</span>, reduce_identity<span class="op">{</span><span class="fl">0.0</span><span class="op">})</span>;</span></code></pre></div>
<p>Advantages of this approach:</p>
<ul>
<li><p>Users would see in plain text the purpose of this function
argument</p></li>
<li><p>Algorithms could overload on it without risk of
ambiguity</p></li>
<li><p>The struct is an aggregate, which would maximize potential for
optimizations</p></li>
<li><p>It would not impose requirements on the user’s binary
function</p></li>
</ul>
<p>Disadvantages:</p>
<ul>
<li><p>The algorithm could not use this to deduce a default identity
value from a binary operation</p></li>
<li><p>A specialization of <code>op_identity&lt;T&gt;</code> would take
effect for all binary operations on <code>T</code></p></li>
</ul>
<h3 data-number="3.4.12" id="if-users-can-define-an-identity-value-do-they-need-an-initial-value"><span class="header-section-number">3.4.12</span> If users can define an
identity value, do they need an initial value?<a href="#if-users-can-define-an-identity-value-do-they-need-an-initial-value" class="self-link"></a></h3>
<h4 data-number="3.4.12.1" id="reduce-algorithms-should-not-take-both"><span class="header-section-number">3.4.12.1</span> <code>*reduce</code>
algorithms should not take both<a href="#reduce-algorithms-should-not-take-both" class="self-link"></a></h4>
<ul>
<li><p>Providing both would confuse users and would specify the result
type redundantly.</p></li>
<li><p>There is no performance benefit for providing an initial value,
if an identity value is known.</p></li>
</ul>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">5</span>, <span class="dv">11</span>, <span class="dv">7</span><span class="op">}</span>;</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> max_identity <span class="op">=</span> std<span class="op">::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>lowest<span class="op">()</span>;</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">// identity as initial value</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result1 <span class="op">=</span> ranges<span class="op">::</span>reduce<span class="op">(</span>v, max_identity, ranges<span class="op">::</span>max<span class="op">{})</span>;</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result1 <span class="op">==</span> <span class="dv">11</span><span class="op">)</span>;</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">// identity as, well, identity</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result2 <span class="op">=</span> ranges<span class="op">::</span>reduce<span class="op">(</span>v,</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>  reduce_operation<span class="op">{</span>ranges<span class="op">::</span>max<span class="op">{}</span>, max_identity<span class="op">})</span>;</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result2 <span class="op">==</span> <span class="dv">11</span><span class="op">)</span>;</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> empty_vec;</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result3 <span class="op">=</span> ranges<span class="op">::</span>reduce<span class="op">(</span>empty_vec,</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>  reduce_operation<span class="op">{</span>ranges<span class="op">::</span>max<span class="op">{}</span>, max_identity<span class="op">})</span>;</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result3 <span class="op">==</span> max_identity<span class="op">)</span>;</span></code></pre></div>
<h4 data-number="3.4.12.2" id="scan-algorithms-would-benefit-from-an-initial-value"><span class="header-section-number">3.4.12.2</span> <code>*_scan</code>
algorithms would benefit from an initial value<a href="#scan-algorithms-would-benefit-from-an-initial-value" class="self-link"></a></h4>
<ul>
<li><p>Initial value affects every element of output</p></li>
<li><p>Without it, would need extra <code>transform</code> pass over
output</p></li>
<li><p>For exclusive scan, can’t use
<code>transform_exclusive_scan</code> to work around non-identity
initial value</p></li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> in<span class="op">{</span><span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">13</span>, <span class="dv">17</span><span class="op">}</span>;</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span><span class="dt">size_t</span><span class="op">(</span><span class="dv">5</span><span class="op">))</span>;</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> binary_op <span class="op">=</span> plus<span class="op">{}</span>;</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">// out: 8, 15, 26, 39, 56</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>ranges<span class="op">::</span>inclusive_scan<span class="op">(</span>in, out, binary_op, init<span class="op">)</span>;</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="co">// out: 3, 8, 15, 26, 39</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Yes, init and binary_op have reversed order.</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>ranges<span class="op">::</span>exclusive_scan<span class="op">(</span>in, out, init, binary_op<span class="op">)</span>;</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="co">// out: 8, 15, 26, 39, 56</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> unary_op <span class="op">=</span> <span class="op">[</span>op <span class="op">=</span> binary_op<span class="op">]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> op<span class="op">(</span>x, <span class="dv">3</span><span class="op">)</span>; <span class="op">}</span>;</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>ranges<span class="op">::</span>transform_inclusive_scan<span class="op">(</span><span class="dt">int</span>, out, binary_op, unary_op<span class="op">)</span>;</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="co">// out: 0, 8, 15, 26, 39</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>ranges<span class="op">::</span>transform_exclusive_scan<span class="op">(</span>in, out, binary_op, unary_op<span class="op">)</span>;</span></code></pre></div>
<h4 data-number="3.4.12.3" id="avoid-mixing-up-identity-and-initial-value"><span class="header-section-number">3.4.12.3</span> Avoid mixing up identity
and initial value<a href="#avoid-mixing-up-identity-and-initial-value" class="self-link"></a></h4>
<p>C++17 <code>*reduce</code> and <code>*_scan</code> take initial value
<code>T init</code>, undecorated.</p>
<p>If new algorithms take <code>T identity</code>, then users could be
confused when switching from C++17 to new algorithms.</p>
<p>“Decorating” identity by wrapping it in a struct prevents confusion.
It also lets algorithms provide both initial value and identity.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> in<span class="op">{-</span><span class="dv">8</span>, <span class="dv">6</span>, <span class="op">-</span><span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="op">-</span><span class="dv">12</span><span class="op">}</span>;</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span><span class="dt">size_t</span><span class="op">(</span><span class="dv">7</span><span class="op">))</span>;</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">7</span>;</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> binary_op <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>max<span class="op">{}</span>;</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co">// inclusive_scan doesn&#39;t need an initial value.</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">// out: -8, 6, 6, 6, 6, 10, 10</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>inclusive_scan<span class="op">(</span>in, out, binary_op<span class="op">)</span>;</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="co">// out: 7, 7, 7, 7, 7, 10, 10</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>inclusive_scan<span class="op">(</span>in, out, binary_op, init<span class="op">)</span>;</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Suppose the user knows that they</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="co">// will never see values smaller than -9.</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> identity_value <span class="op">=</span> <span class="op">-</span><span class="dv">10</span>;</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a><span class="co">// out: 7, 7, 7, 7, 7, 10, 10</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>inclusive_scan<span class="op">(</span>in, out,</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>  reduce_operation<span class="op">{</span>binary_op, identity_value<span class="op">}</span>,</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>  init<span class="op">)</span>;</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a><span class="co">// exclusive scan needs an initial value.</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a><span class="co">// Identity is a reasonable default initial value,</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a><span class="co">// if you have it.</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a><span class="co">// C++17 *exclusive_scan puts init left of binary_op,</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a><span class="co">// while inclusive_scan puts init right of binary_op.</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a><span class="co">// We find this weird so we don&#39;t do it.</span></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a><span class="co">// out: 7, 7, 7, 7, 7, 7, 10</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>exclusive_scan<span class="op">(</span>in, out, binary_op, init<span class="op">)</span>;</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a><span class="co">// out: -10, -8, 6, 6, 6, 6, 10</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>exclusive_scan<span class="op">(</span>in, out,</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>  reduce_operation<span class="op">{</span>binary_op, identity_value<span class="op">})</span>;</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a><span class="co">// out: 7, 7, 7, 7, 7, 7, 7, 10</span></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>exclusive_scan<span class="op">(</span>in, out,</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>  reduce_operation<span class="op">{</span>binary_op, identity_value<span class="op">}</span>, init<span class="op">)</span>;</span></code></pre></div>
<h3 data-number="3.4.13" id="conclusions-2"><span class="header-section-number">3.4.13</span> Conclusions<a href="#conclusions-2" class="self-link"></a></h3>
<p>It’s important for both performance and functionality that users be
able to specify an identity value for parallel reductions. Designs for
this should avoid confusion when switching from C++17 parallel numeric
algorithms to the new ranges versions. We would like feedback from SG9
and LEWG on their preferred design.</p>
<p>Our proposed <code>*reduce</code> algorithms do not need an initial
value parameter. For our proposed <code>*_scan</code> algorithms, an
initial value could improve performance in some cases by avoiding an
additional pass over all the output elements. The
<code>*exclusive_scan</code> algorithms need an initial value because it
defines the first element of the output range. The initial value could
default to the identity, if it exists and is known.</p>
<h2 data-number="3.5" id="rangesreduce-design"><span class="header-section-number">3.5</span> <code>ranges::reduce</code>
design<a href="#rangesreduce-design" class="self-link"></a></h2>
<p>In this section, we focus on <code>ranges::reduce</code>’s design.
The discussion here applies generally to the other algorithms we
propose.</p>
<h3 data-number="3.5.1" id="no-default-binary-operation-or-initial-value"><span class="header-section-number">3.5.1</span> No default binary operation
or initial value<a href="#no-default-binary-operation-or-initial-value" class="self-link"></a></h3>
<p>Section 5.1 of <span class="citation" data-cites="P2760R1">[<a href="#ref-P2760R1" role="doc-biblioref"><strong>P2760R1?</strong></a>]</span> states:</p>
<blockquote>
<p>One thing is clear: <code>ranges::reduce</code> should <em>not</em>
take a default binary operation <em>nor</em> a default initial [value]
parameter. The user needs to supply both.</p>
</blockquote>
<p>This motivates the following convenience wrappers:</p>
<ul>
<li><code>ranges::sum(r)</code> for <code>ranges::reduce</code> with
<code>init = range_value_t&lt;R&gt;()</code> and <code>plus{}</code> as
the reduce operation;</li>
<li><code>ranges::product(r)</code> for <code>ranges::reduce</code> with
<code>init = range_value_t&lt;R&gt;(1))</code> and
<code>multiplies{}</code> as the reduce operation; and</li>
<li><code>ranges::dot(x, y)</code> for binary
<code>ranges::transform_reduce</code> with <code>init = T()</code> where
<code>T = decltype(declval&lt;range_value_t&lt;X&gt;&gt;() * declval&lt;range_value_t&lt;Y&gt;&gt;())</code>,
<code>multiplies{}</code> is the transform operation, and
<code>plus{}</code> is the reduce operation.</li>
</ul>
<p>One argument <em>for</em> a default initial value in
<code>std::reduce</code> is that <code>int</code> literals like
<code>0</code> or <code>1</code> do not behave in the expected way with
a sequence of <code>float</code> or <code>double</code>. For
<code>ranges::reduce</code>, however, making its return value type
imitate <code>ranges::fold_left</code> instead of
<code>std::reduce</code> fixes that.</p>
<h3 data-number="3.5.2" id="for-return-type-imitate-rangesfold_left-not-stdreduce"><span class="header-section-number">3.5.2</span> For return type, imitate
<code>ranges::fold_left</code>, not <code>std::reduce</code><a href="#for-return-type-imitate-rangesfold_left-not-stdreduce" class="self-link"></a></h3>
<p>Both <code>std::reduce</code> and <code>std::ranges::fold_left</code>
return the reduction result as a single value. However, they deduce the
return type differently. For <code>ranges::reduce</code>, we deduce the
return type like <code>std::ranges::fold_left</code> does, instead of
always returning the initial value type <code>T</code> like
<code>std::reduce</code>.</p>
<p><span class="citation" data-cites="P2322R6">[<a href="#ref-P2322R6" role="doc-biblioref"><strong>P2322R6?</strong></a>]</span>,
“<code>ranges::fold</code>,” added the various <code>fold_*</code>
<code>ranges</code> algorithms to C++23. This proposal explains why
<code>std::ranges::fold_left</code> may return a different reduction
type than <code>std::reduce</code> for the same input range, initial
value, and binary operation. Consider the following example, adapted
from Section 3 of <span class="citation" data-cites="P2322R6">[<a href="#ref-P2322R6" role="doc-biblioref"><strong>P2322R6?</strong></a>]</span> (<a href="https://godbolt.org/z/3q71EMTPa">Compiler Explorer link</a>).</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="fl">0.25</span>, <span class="fl">0.75</span><span class="op">}</span>;</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>reduce<span class="op">(</span>v<span class="op">.</span>begin<span class="op">()</span>, v<span class="op">.</span>end<span class="op">()</span>, <span class="dv">1</span>, std<span class="op">::</span>plus<span class="op">())</span>;</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)</span>, <span class="dt">int</span><span class="op">&gt;)</span>;</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>r <span class="op">==</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>fold_left<span class="op">(</span>v, <span class="dv">1</span>, std<span class="op">::</span>plus<span class="op">())</span>;</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)</span>, <span class="dt">double</span><span class="op">&gt;)</span>;</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>r <span class="op">==</span> <span class="fl">2.0</span><span class="op">)</span>;</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>std::reduce</code> part of the example expresses a common
user error. <code>ranges::fold_*</code> instead returns “the decayed
result of invoking the binary operation with <code>T</code> (the initial
value) and the reference type of the range.” For the above example, this
likely expresses what the user meant. It also works for other common
cases, like proxy reference types with an unambiguous conversion to a
common type with the initial value.</p>
<p>It’s notable that <code>reduce</code>-like <code>mdspan</code>
algorithms in <span class="unnumbered sref">linalg</span> –
<code>dot</code>, <code>vector_sum_of_squares</code>,
<code>vector_two_norm</code>, <code>vector_abs_sum</code>,
<code>matrix_frob_norm</code>, <code>matrix_one_norm</code>, and
<code>matrix_inf_norm</code> – all have the same return type behavior as
C++17 <code>std::reduce</code>. However, the authors of <span class="unnumbered sref">linalg</span> expect typical users of their
library to prefer complete control of the return type, even if it means
they have to type <code>1.0</code> instead of <code>1</code>. These
<span class="unnumbered sref">linalg</span> algorithms also have more
precise wording about precision of intermediate terms in sums when the
element types and the initial value are all floating-point types or
specializations of <code>complex</code>. (See e.g., <span class="unnumbered sref">linalg.algs.blas1.dot</span> 7.) For ranges
reduction algorithms, we expect a larger audience of users and thus
prefer consistency with <code>fold_*</code>’s return type.</p>
<h2 data-number="3.6" id="constraining-numeric-ranges-algorithms"><span class="header-section-number">3.6</span> Constraining numeric ranges
algorithms<a href="#constraining-numeric-ranges-algorithms" class="self-link"></a></h2>
<p>In summary,</p>
<ul>
<li>We use the same constraints as <code>fold_left</code> and
<code>fold_right</code> to constrain the binary operator of
<code>reduce</code> and <code>*_scan</code>.</li>
<li>We imitate C++17 parallel algorithms and <span class="unnumbered sref">linalg</span> (<span class="citation" data-cites="P1673R13">[<a href="#ref-P1673R13" role="doc-biblioref"><strong>P1673R13?</strong></a>]</span>) by using
<em>GENERALIZED_NONCOMMUTATIVE_SUM</em> and <em>GENERALIZED_SUM</em> to
describe the behavior of <code>reduce</code> and
<code>*_scan</code>.</li>
<li>Otherwise, we follow the approach of <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> (“C++
Parallel Range Algorithms”).</li>
</ul>
<p><span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span>, which has
been voted into the Working Draft for C++26, defines parallel versions
of many <code>ranges</code> algorithms in the C++ Standard Library. (The
“parallel version of an algorithm” is an overload of an algorithm whose
first parameter is an execution policy.) That proposal restricts itself
to adding parallel versions of existing <code>ranges</code> algorithms.
<span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> explicitly
defers adding overloads to the numeric algorithms in <span class="unnumbered sref">numeric.ops</span>, because these do not yet
have ranges versions. Our proposal fills that gap.</p>
<p>WG21 did not have time to propose ranges-based numeric algorithms
with the initial set of <code>ranges</code> algorithms in C++20. <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span>, “A Concept Design for the
Numeric Algorithms,” points out the challenge of defining ranges
versions of the existing parallel numeric algorithms. What makes this
task less straightforward is that the specification of the parallel
numeric algorithms permits them to reorder binary operations like
addition. This matters because many useful number types do not have
associative addition. Lack of associativity is not just a floating-point
rounding error issue; one example is saturating integer arithmetic.
<code>Ranges</code> algorithms are constrained by concepts, but it’s not
clear even if it’s a good idea to define concepts that can express
permission to reorder terms in a sum.</p>
<p>C++17 takes the approach of saying that parallel numeric algorithms
can reorder the binary operations however they like, but does not say
whether any reordering would give the same results as any other
reordering. The Standard expresses this through the wording “macros”
<em>GENERALIZED_NONCOMMUTATIVE_SUM</em> and <em>GENERALIZED_SUM</em>. (A
wording macro is a parameterized abbreviation for a longer sequence of
wording in the Standard. We put “macros” in double quotes because they
are not necessarily preprocessor macros. They might not even be
implementable as such.) Algorithms become ill-formed, no diagnostic
required (IFNDR) if the element types do not define the required
operations. <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span> instead
defines C++ concepts that represent algebraic structures, all of which
involve a set with a closed binary operation. Some of the structures
require that the operation be associative and/or commutative. <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span> uses those concepts to
constrain the algorithms. This means that the algorithms will not be
selected for overload resolution if the element types do not define the
required operations. It further means that algorithms could (at least in
theory) dispatch based on properties like whether the element type’s
binary operation is commutative. The concepts include both syntactic and
semantic constraints.</p>
<p>WG21 has not expressed a consensus on <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span>’s approach. LEWGI reviewed
<span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span> at the Belfast meeting in
November 2019, but did not forward the proposal and wanted to see it
again. Two other proposals express something more like WG21’s consensus
on constraining the numeric algorithms: <span class="citation" data-cites="P2214R2">[<a href="#ref-P2214R2" role="doc-biblioref"><strong>P2214R2?</strong></a>]</span>, “A Plan for
C++23 Ranges,” <span class="citation" data-cites="P1673R13">[<a href="#ref-P1673R13" role="doc-biblioref"><strong>P1673R13?</strong></a>]</span>, “A free
function linear algebra interface based on the BLAS,” which defines
<code>mdspan</code>-based analogs of the numeric algorithms. Section
5.1.1 of <span class="citation" data-cites="P2214R2">[<a href="#ref-P2214R2" role="doc-biblioref"><strong>P2214R2?</strong></a>]</span> points out
that <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span>’s approach would overconstrain
<code>fold</code>; <span class="citation" data-cites="P2214R2">[<a href="#ref-P2214R2" role="doc-biblioref"><strong>P2214R2?</strong></a>]</span> instead
suggests just constraining the operation to be binary invocable. This
was ultimately the approach taken by the Standard through the
exposition-only concepts
<em><code>indirectly-binary-left-foldable</code></em> and
<em><code>indirectly-binary-right-foldable</code></em>. Section 5.1.2 of
<span class="citation" data-cites="P2214R2">[<a href="#ref-P2214R2" role="doc-biblioref"><strong>P2214R2?</strong></a>]</span> says that
<code>reduce</code> “calls for the kinds of constraints that <span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span> is proposing.”</p>
<p><span class="citation" data-cites="P1673R13">[<a href="#ref-P1673R13" role="doc-biblioref"><strong>P1673R13?</strong></a>]</span>, which was
adopted into the Working Draft for C++26 as <span class="unnumbered sref">linalg</span>, took an entirely different
approach for its set of <code>mdspan</code>-based numeric algorithms.
Section 10.8, “Constraining matrix and vector element types and
scalars,” explains the argument. Here is a summary.</p>
<ol type="1">
<li>Requirements like associativity are too strict to be useful for
practical types. The only number types in the Standard with associative
addition are unsigned integers. It’s not just a rounding error “epsilon”
issue; sums of saturating integers can have infinite error if one
assumes associativity.</li>
<li>“The algorithm may reorder sums” (which is what we want to say)
means something different than “addition on the terms in the sum is
associative” (which is not true for many number types of interest). That
is, permission for an algorithm to reparenthesize sums is not the same
as a concept constraining the terms in the sum.</li>
<li><span class="citation" data-cites="P1813R0">[<a href="#ref-P1813R0" role="doc-biblioref">P1813R0</a>]</span> defines concepts that
generalize a mathematical group. These are only useful for describing a
single set of numbers, that is, one type. This excludes useful features
like mixed precision (e.g., where the result type in <code>reduce</code>
differs from the range’s element type) and types that use expression
templates. One could imagine generalizing this to a set of types that
have a common type, but this can be too restrictive; Section 5.1.1 of
<span class="citation" data-cites="P2214R2">[<a href="#ref-P2214R2" role="doc-biblioref"><strong>P2214R2?</strong></a>]</span> gives an
example involving two types in a fold that do not have a common
type.</li>
</ol>
<p><span class="citation" data-cites="P1673R13">[<a href="#ref-P1673R13" role="doc-biblioref"><strong>P1673R13?</strong></a>]</span> says that
algorithms have complete freedom to create temporary copies or
value-initialized temporary objects, rearrange addends and partial sums
arbitrarily, or perform assignments in any order, as long as this would
produce the result specified by the algorithm’s <em>Effects</em> and
<em>Remarks</em> when operating on elements of a semiring. The
<code>linalg::dot</code> (<span class="unnumbered sref">linalg.algs.blas1.dot</span>) and
<code>linalg::vector_abs_sum</code> (<span class="unnumbered sref">linalg.algs.blas1.asum</span>) algorithms
specifically define the returned result(s) in terms of
<em>GENERALIZED_SUM</em>. Those algorithms do that because they need to
constrain the precision of intermediate terms in the sum (so they need
to define those terms). In our case, the Standard already uses
<em>GENERALIZED_SUM</em> and <em>GENERALIZED_NONCOMMUTATIVE_SUM</em> to
define iterator-based C++17 algorithms like <code>reduce</code>,
<code>inclusive_scan</code>, and <code>exclusive_scan</code>. We can
just adapt this wording to talk about ranges instead of iterators. This
lets us imitate the approach of <span class="citation" data-cites="P3179R9">[<a href="#ref-P3179R9" role="doc-biblioref"><strong>P3179R9?</strong></a>]</span> in adding
ranges overloads.</p>
<p>Our approach combines the syntactic constraints used for the
<code>fold_*</code> family of algorithms, with the semantic approach of
<span class="citation" data-cites="P1673R13">[<a href="#ref-P1673R13" role="doc-biblioref"><strong>P1673R13?</strong></a>]</span> and the
C++17 parallel numeric algorithms. For example, we constrain
<code>reduce</code>’s binary operation with
<em><code>indirectly-binary-foldable</code></em>, which is like saying
that it must be both
<em><code>indirectly-binary-left-foldable</code></em> and
<em><code>indirectly-binary-right-foldable</code></em>. (This expresses
that if the binary operation is called with an argument of the initial
value’s type <code>T</code>, then that argument can be in either the
first or second position.) We express what <code>reduce</code> does
using <em>GENERALIZED_SUM</em>.</p>
<h2 data-number="3.7" id="enabling-list-initialization-for-proposed-algorithms"><span class="header-section-number">3.7</span> Enabling list-initialization
for proposed algorithms<a href="#enabling-list-initialization-for-proposed-algorithms" class="self-link"></a></h2>
<p>Our proposal follows the same principles as described in <span class="citation" data-cites="P2248R8">[<a href="#ref-P2248R8" role="doc-biblioref"><strong>P2248R8?</strong></a>]</span>, “Enabling
list-initialization for algorithms.” We want to enable the use case
where users construct a nondefault initial value using curly braces
without naming the type.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="fl">0.25</span>, <span class="fl">0.75</span><span class="op">}</span>;</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span>v, <span class="op">{</span><span class="dv">1</span><span class="op">}</span>, std<span class="op">::</span>plus<span class="op">())</span>;</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>r <span class="op">==</span> <span class="fl">2.0</span><span class="op">)</span>;</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Supporting this use case requires that we add a default template
argument to <code>T init</code> in the proposed signatures. While <span class="citation" data-cites="P2248R8">[<a href="#ref-P2248R8" role="doc-biblioref"><strong>P2248R8?</strong></a>]</span> does not
propose a default template parameter for <code>init</code> in the
<code>&lt;numeric&gt;</code> header, we want to address this design
question from the beginning for the new set of algorithms because
<code>fold_</code> family already has this feature.</p>
<h1 data-number="4" id="implementation"><span class="header-section-number">4</span> Implementation<a href="#implementation" class="self-link"></a></h1>
<p>The oneAPI DPC++ library (<a href="https://github.com/uxlfoundation/oneDPL">oneDPL</a>) has
deployment experience. The implementation is done as experimental with
the following deviations from this proposal:</p>
<ul>
<li>Algorithms do not have constraints</li>
<li><code>reduce</code> has more overloads (without init and without
binary predicate)</li>
<li><code>*_scan</code> return type is not
<code>in_out_result</code></li>
<li>The convenience wrappers proposed in this paper are not implemented.
Their implementation is expected to be trivial, though.</li>
</ul>
<h1 data-number="5" id="wording"><span class="header-section-number">5</span> Wording<a href="#wording" class="self-link"></a></h1>
<blockquote>
<p>Text in blockquotes is not proposed wording, but rather instructions
for generating proposed wording.</p>
</blockquote>
<h2 data-number="5.1" id="update-feature-test-macro"><span class="header-section-number">5.1</span> Update feature test macro<a href="#update-feature-test-macro" class="self-link"></a></h2>
<blockquote>
<p>In <span class="unnumbered sref">version.syn</span>, increase the
value of the <code>__cpp_lib_parallel_algorithm</code> macro by
replacing YYYYMML below with the integer literal encoding the
appropriate year (YYYY) and month (MM).</p>
</blockquote>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define __cpp_lib_parallel_algorithm </span>YYYYMML<span class="pp"> </span><span class="co">// also in &lt;algorithm&gt;</span></span></code></pre></div>
<h2 data-number="5.2" id="add-sized-forward-range-to-range.refinements"><span class="header-section-number">5.2</span> Add
<em><code>sized-forward-range</code></em> to [range.refinements]<a href="#add-sized-forward-range-to-range.refinements" class="self-link"></a></h2>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span>
The <code>constant_range</code> concept specifies the requirements of a
<code>range</code> type whose elements are not modifiable.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>template&lt;class T&gt;</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  concept constant_range =</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    input_range&lt;T&gt; &amp;&amp; <em>constant-iterator</em>&lt;iterator_t&lt;T&gt;&gt;;</span></code></pre></div>
<div class="add" style="color: #00AA00">
<p><span class="marginalizedparent"><a class="marginalized">8</a></span>
The exposition-only concept <em><code>sized-forward-range</code></em>
specifies the requirements of a <code>range</code> type that is sized
and whose iterators model <code>forward_iterator</code>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>template&lt;class T&gt;</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  concept <em>sized-random-access-range</em> =           // <em>exposition only</em></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    random_access_range&lt;R&gt; &amp;&amp; sized_range&lt;R&gt;;</span></code></pre></div>

</div>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span>
The exposition-only concept
<em><code>sized-random-access-range</code></em> specifies the
requirements of a <code>range</code> type that is sized and allows
random access to its elements.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>template&lt;class T&gt;</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  concept <em>sized-random-access-range</em> =           // <em>exposition only</em></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    random_access_range&lt;R&gt; &amp;&amp; sized_range&lt;R&gt;;</span></code></pre></div>
<p>[<em>Note 1</em>: <span class="rm" style="color: #bf0303"><del>This
concept</del></span><span class="add" style="color: #00AA00"><ins>The
concepts <em><span><code>sized-forward-range</code></span></em> and
<em><span><code>sized-random-access-range</code></span></em></ins></span>
constrain<span class="rm" style="color: #bf0303"><del>s</del></span>
some parallel algorithm overloads; see [algorithms] <span class="add" style="color: #00AA00"><ins>and [numeric]</ins></span>. – <em>end
note</em>]</p>
<h2 data-number="5.3" id="change-numeric.ops.overview"><span class="header-section-number">5.3</span> Change <span class="unnumbered sref">numeric.ops.overview</span><a href="#change-numeric.ops.overview" class="self-link"></a></h2>
<blockquote>
<p>Change <span class="unnumbered sref">numeric.ops.overview</span> (the
<code>&lt;numeric&gt;</code> header synopsis) as follows.</p>
</blockquote>
<h3 data-number="5.3.1" id="add-declaration-of-exposition-only-concepts"><span class="header-section-number">5.3.1</span> Add declaration of
exposition-only concepts<a href="#add-declaration-of-exposition-only-concepts" class="self-link"></a></h3>
<blockquote>
<p>Add declarations of exposition-only concepts
<em><code>indirectly-binary-foldable-impl</code></em> and
<em><code>indirectly-binary-foldable</code></em> to <span class="unnumbered sref">numeric.ops.overview</span> (the
<code>&lt;numeric&gt;</code> header synopsis) as follows.</p>
<p>Note that the exposition-only concepts
<em><code>indirectly-binary-left-foldable</code></em> and
<em><code>indirectly-binary-right-foldable</code></em> live in the
<code>&lt;algorithm&gt;</code> header.</p>
</blockquote>
<div class="sourceCode" id="cb45"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>// mostly freestanding</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>namespace std {</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb46"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>namespace ranges {</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  template&lt;class F, class T, class I, class U&gt;</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    concept <em>indirectly-binary-foldable-impl</em> =       // <em>exposition only</em></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>      movable&lt;T&gt; &amp;&amp; movable&lt;U&gt; &amp;&amp;</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>      convertible_to&lt;T, U&gt; &amp;&amp;</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>      invocable&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>      assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>      invocable&lt;F&amp;, iter_reference_t&lt;I&gt;, U&gt; &amp;&amp;</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>      assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, U&gt;&gt;;</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>  template&lt;class F, class T, class I&gt;</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>    concept <em>indirectly-binary-foldable</em> =           // <em>exposition only</em></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>      copy_constructible&lt;F&gt; &amp;&amp; indirectly_readable&lt;I&gt; &amp;&amp;</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>      invocable&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>      convertible_to&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;,</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>        decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>      invocable&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt; &amp;&amp;</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>      convertible_to&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;,</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>        decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>      <em>indirectly-binary-foldable-impl</em>&lt;F, T, I,</span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>        decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;;</span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>

</div>
<div class="sourceCode" id="cb47"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>  // [accumulate], accumulate</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  template&lt;class InputIterator, class T&gt;</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    constexpr T accumulate(InputIterator first, InputIterator last, T init);</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  template&lt;class InputIterator, class T, class BinaryOperation&gt;</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    constexpr T accumulate(InputIterator first, InputIterator last, T init,</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>                           BinaryOperation binary_op);</span></code></pre></div>
<h3 data-number="5.3.2" id="add-declarations-of-reduce-sum-product-and-their-_into-variants"><span class="header-section-number">5.3.2</span> Add declarations of
<code>reduce</code>, <code>sum</code>, <code>product</code>, and their
<code>*_into</code> variants<a href="#add-declarations-of-reduce-sum-product-and-their-_into-variants" class="self-link"></a></h3>
<blockquote>
<p>Add declarations of ranges overloads of <code>reduce</code>,
<code>reduce_into</code>, <code>sum</code>, <code>sum_into</code>,
<code>product</code>, and <code>product_into</code> algorithms to <span class="unnumbered sref">numeric.ops.overview</span> (the
<code>&lt;numeric&gt;</code> header synopsis) as follows.</p>
</blockquote>
<div class="sourceCode" id="cb48"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>template&lt;class ExecutionPolicy, class ForwardIterator, class T, class BinaryOperation&gt;</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  T reduce(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>            ForwardIterator first, ForwardIterator last, T init, BinaryOperation binary_op);</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">namespace</span> ranges <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Non-parallel overloads of reduce</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span>forward_iterator I,</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S,</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> T <span class="op">=</span> iter_value_t<span class="op">&lt;</span>I<span class="op">&gt;</span>,</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em><span class="op">&lt;</span>T, I<span class="op">&gt;</span> F<span class="op">&gt;</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> reduce<span class="op">(</span>I first, S last, T init, F binary_op<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>sized-forward-range</em> R,</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> T <span class="op">=</span> range_value_t<span class="op">&lt;</span>R<span class="op">&gt;</span>,</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em><span class="op">&lt;</span>T, iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span> F<span class="op">&gt;</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> reduce<span class="op">(</span>R<span class="op">&amp;&amp;</span> r, T init, F binary_op<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Parallel overloads of reduce</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S,</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> T <span class="op">=</span> iter_value_t<span class="op">&lt;</span>I<span class="op">&gt;</span>,</span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em><span class="op">&lt;</span>T, I<span class="op">&gt;</span> F<span class="op">&gt;</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> reduce<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>                I first, S last, T init, F binary_op<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> T <span class="op">=</span> range_value_t<span class="op">&lt;</span>R<span class="op">&gt;</span>,</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em><span class="op">&lt;</span>T, iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span> F<span class="op">&gt;</span></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> reduce<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>                R<span class="op">&amp;&amp;</span> r, T init, F binary_op<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Non-parallel overloads of reduce_into</span></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span>forward_iterator I,</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> IS,</span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>           forward_iterator O,</span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>O<span class="op">&gt;</span> OS,</span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> T <span class="op">=</span> iter_value_t<span class="op">&lt;</span>I<span class="op">&gt;</span>,</span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em><span class="op">&lt;</span>T, I<span class="op">&gt;</span> F<span class="op">&gt;</span></span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> reduce_into<span class="op">(</span></span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>      I in_first, IS in_last,</span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>      O out_first, OS out_last,</span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>      T init,</span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>      F binary_op<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>sized-forward-range</em> IR,</span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>           <em>sized-forward-range</em> OR,</span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> T <span class="op">=</span> range_value_t<span class="op">&lt;</span>IR<span class="op">&gt;</span>,</span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em><span class="op">&lt;</span>T, iterator_t<span class="op">&lt;</span>IR<span class="op">&gt;&gt;</span> F<span class="op">&gt;</span></span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> reduce_into<span class="op">(</span></span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a>      IR<span class="op">&amp;&amp;</span> in_range,</span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>      OR<span class="op">&amp;&amp;</span> out_range,</span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a>      T init,</span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a>      F binary_op<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-53"><a href="#cb49-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-54"><a href="#cb49-54" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Parallel overloads of reduce_into</span></span>
<span id="cb49-55"><a href="#cb49-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-56"><a href="#cb49-56" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-57"><a href="#cb49-57" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb49-58"><a href="#cb49-58" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S,</span>
<span id="cb49-59"><a href="#cb49-59" aria-hidden="true" tabindex="-1"></a>           forward_iterator O,</span>
<span id="cb49-60"><a href="#cb49-60" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>O<span class="op">&gt;</span> OS,</span>
<span id="cb49-61"><a href="#cb49-61" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> T <span class="op">=</span> iter_value_t<span class="op">&lt;</span>I<span class="op">&gt;</span>,</span>
<span id="cb49-62"><a href="#cb49-62" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em><span class="op">&lt;</span>T, I<span class="op">&gt;</span> F<span class="op">&gt;</span></span>
<span id="cb49-63"><a href="#cb49-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> reduce_into<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-64"><a href="#cb49-64" aria-hidden="true" tabindex="-1"></a>      I in_first, S in_last,</span>
<span id="cb49-65"><a href="#cb49-65" aria-hidden="true" tabindex="-1"></a>      O out_first, OS out_last,</span>
<span id="cb49-66"><a href="#cb49-66" aria-hidden="true" tabindex="-1"></a>      T init,</span>
<span id="cb49-67"><a href="#cb49-67" aria-hidden="true" tabindex="-1"></a>      F binary_op<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-68"><a href="#cb49-68" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-69"><a href="#cb49-69" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> IR,</span>
<span id="cb49-70"><a href="#cb49-70" aria-hidden="true" tabindex="-1"></a>           <em>sized-forward-range</em> OR,</span>
<span id="cb49-71"><a href="#cb49-71" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> T <span class="op">=</span> range_value_t<span class="op">&lt;</span>IR<span class="op">&gt;</span>,</span>
<span id="cb49-72"><a href="#cb49-72" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em><span class="op">&lt;</span>T, iterator_t<span class="op">&lt;</span>IR<span class="op">&gt;&gt;</span> F<span class="op">&gt;</span></span>
<span id="cb49-73"><a href="#cb49-73" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> reduce_into<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-74"><a href="#cb49-74" aria-hidden="true" tabindex="-1"></a>      IR<span class="op">&amp;&amp;</span> in_range,</span>
<span id="cb49-75"><a href="#cb49-75" aria-hidden="true" tabindex="-1"></a>      OR<span class="op">&amp;&amp;</span> out_range,</span>
<span id="cb49-76"><a href="#cb49-76" aria-hidden="true" tabindex="-1"></a>      T init,</span>
<span id="cb49-77"><a href="#cb49-77" aria-hidden="true" tabindex="-1"></a>      F binary_op<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-78"><a href="#cb49-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-79"><a href="#cb49-79" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Non-parallel overloads of sum</span></span>
<span id="cb49-80"><a href="#cb49-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-81"><a href="#cb49-81" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span>forward_iterator I,</span>
<span id="cb49-82"><a href="#cb49-82" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb49-83"><a href="#cb49-83" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-84"><a href="#cb49-84" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> sum<span class="op">(</span>I first, S last<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-85"><a href="#cb49-85" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>sized-forward-range</em> R<span class="op">&gt;</span></span>
<span id="cb49-86"><a href="#cb49-86" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-87"><a href="#cb49-87" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> sum<span class="op">(</span>R<span class="op">&amp;&amp;</span> r<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-88"><a href="#cb49-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-89"><a href="#cb49-89" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Parallel overloads of sum</span></span>
<span id="cb49-90"><a href="#cb49-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-91"><a href="#cb49-91" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-92"><a href="#cb49-92" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb49-93"><a href="#cb49-93" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb49-94"><a href="#cb49-94" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-95"><a href="#cb49-95" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> sum<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-96"><a href="#cb49-96" aria-hidden="true" tabindex="-1"></a>               I first, S last<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-97"><a href="#cb49-97" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-98"><a href="#cb49-98" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R<span class="op">&gt;</span></span>
<span id="cb49-99"><a href="#cb49-99" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-100"><a href="#cb49-100" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> sum<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-101"><a href="#cb49-101" aria-hidden="true" tabindex="-1"></a>               R<span class="op">&amp;&amp;</span> r<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-102"><a href="#cb49-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-103"><a href="#cb49-103" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Non-parallel overloads of sum_into</span></span>
<span id="cb49-104"><a href="#cb49-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-105"><a href="#cb49-105" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span>forward_iterator I,</span>
<span id="cb49-106"><a href="#cb49-106" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> IS,</span>
<span id="cb49-107"><a href="#cb49-107" aria-hidden="true" tabindex="-1"></a>           forward_iterator O,</span>
<span id="cb49-108"><a href="#cb49-108" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>O<span class="op">&gt;</span> OS<span class="op">&gt;</span></span>
<span id="cb49-109"><a href="#cb49-109" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-110"><a href="#cb49-110" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> sum_into<span class="op">(</span>I in_first, S in_last,</span>
<span id="cb49-111"><a href="#cb49-111" aria-hidden="true" tabindex="-1"></a>        O out_first, OS out_last<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-112"><a href="#cb49-112" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>sized-forward-range</em> IR,</span>
<span id="cb49-113"><a href="#cb49-113" aria-hidden="true" tabindex="-1"></a>           <em>sized-forward-range</em> OR<span class="op">&gt;</span></span>
<span id="cb49-114"><a href="#cb49-114" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-115"><a href="#cb49-115" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> sum_into<span class="op">(</span>IR<span class="op">&amp;&amp;</span> input, OR<span class="op">&amp;&amp;</span> output<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-116"><a href="#cb49-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-117"><a href="#cb49-117" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Parallel overloads of sum_into</span></span>
<span id="cb49-118"><a href="#cb49-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-119"><a href="#cb49-119" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-120"><a href="#cb49-120" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb49-121"><a href="#cb49-121" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> IS,</span>
<span id="cb49-122"><a href="#cb49-122" aria-hidden="true" tabindex="-1"></a>           forward_iterator O,</span>
<span id="cb49-123"><a href="#cb49-123" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>O<span class="op">&gt;</span> OS<span class="op">&gt;</span></span>
<span id="cb49-124"><a href="#cb49-124" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-125"><a href="#cb49-125" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> sum_into<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-126"><a href="#cb49-126" aria-hidden="true" tabindex="-1"></a>        I in_first, IS in_last,</span>
<span id="cb49-127"><a href="#cb49-127" aria-hidden="true" tabindex="-1"></a>        O out_first, OS out_last<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-128"><a href="#cb49-128" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-129"><a href="#cb49-129" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> IR,</span>
<span id="cb49-130"><a href="#cb49-130" aria-hidden="true" tabindex="-1"></a>           <em>sized-forward-range</em> OR<span class="op">&gt;</span></span>
<span id="cb49-131"><a href="#cb49-131" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-132"><a href="#cb49-132" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> sum_into<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-133"><a href="#cb49-133" aria-hidden="true" tabindex="-1"></a>        OR<span class="op">&amp;&amp;</span> out,</span>
<span id="cb49-134"><a href="#cb49-134" aria-hidden="true" tabindex="-1"></a>        IR<span class="op">&amp;&amp;</span> in<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-135"><a href="#cb49-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-136"><a href="#cb49-136" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Non-parallel overloads of product</span></span>
<span id="cb49-137"><a href="#cb49-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-138"><a href="#cb49-138" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span>forward_iterator I,</span>
<span id="cb49-139"><a href="#cb49-139" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb49-140"><a href="#cb49-140" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-141"><a href="#cb49-141" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> product<span class="op">(</span>I first, S last<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-142"><a href="#cb49-142" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>sized-forward-range</em> R<span class="op">&gt;</span></span>
<span id="cb49-143"><a href="#cb49-143" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-144"><a href="#cb49-144" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> product<span class="op">(</span>R<span class="op">&amp;&amp;</span> r<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-145"><a href="#cb49-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-146"><a href="#cb49-146" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Parallel overloads of product</span></span>
<span id="cb49-147"><a href="#cb49-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-148"><a href="#cb49-148" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-149"><a href="#cb49-149" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb49-150"><a href="#cb49-150" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb49-151"><a href="#cb49-151" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-152"><a href="#cb49-152" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> product<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-153"><a href="#cb49-153" aria-hidden="true" tabindex="-1"></a>                   I first, S last<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-154"><a href="#cb49-154" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-155"><a href="#cb49-155" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R<span class="op">&gt;</span></span>
<span id="cb49-156"><a href="#cb49-156" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-157"><a href="#cb49-157" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> product<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-158"><a href="#cb49-158" aria-hidden="true" tabindex="-1"></a>                   R<span class="op">&amp;&amp;</span> r<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-159"><a href="#cb49-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-160"><a href="#cb49-160" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Non-parallel overloads of product_into</span></span>
<span id="cb49-161"><a href="#cb49-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-162"><a href="#cb49-162" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span>forward_iterator I,</span>
<span id="cb49-163"><a href="#cb49-163" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> IS,</span>
<span id="cb49-164"><a href="#cb49-164" aria-hidden="true" tabindex="-1"></a>           forward_iterator O,</span>
<span id="cb49-165"><a href="#cb49-165" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>O<span class="op">&gt;</span> OS<span class="op">&gt;</span></span>
<span id="cb49-166"><a href="#cb49-166" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-167"><a href="#cb49-167" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> product_into<span class="op">(</span></span>
<span id="cb49-168"><a href="#cb49-168" aria-hidden="true" tabindex="-1"></a>        I in_first, IS in_last,</span>
<span id="cb49-169"><a href="#cb49-169" aria-hidden="true" tabindex="-1"></a>        O out_first, OS out_last<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-170"><a href="#cb49-170" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>sized-forward-range</em> IR,</span>
<span id="cb49-171"><a href="#cb49-171" aria-hidden="true" tabindex="-1"></a>           <em>sized-forward-range</em><span class="op">&gt;</span></span>
<span id="cb49-172"><a href="#cb49-172" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-173"><a href="#cb49-173" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> product_into<span class="op">(</span></span>
<span id="cb49-174"><a href="#cb49-174" aria-hidden="true" tabindex="-1"></a>        IR<span class="op">&amp;&amp;</span> in,</span>
<span id="cb49-175"><a href="#cb49-175" aria-hidden="true" tabindex="-1"></a>        OR<span class="op">&amp;</span> out<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-176"><a href="#cb49-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-177"><a href="#cb49-177" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Parallel overloads of product_into</span></span>
<span id="cb49-178"><a href="#cb49-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-179"><a href="#cb49-179" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-180"><a href="#cb49-180" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb49-181"><a href="#cb49-181" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> IS,</span>
<span id="cb49-182"><a href="#cb49-182" aria-hidden="true" tabindex="-1"></a>           forward_iterator O,</span>
<span id="cb49-183"><a href="#cb49-183" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for<span class="op">&lt;</span>O<span class="op">&gt;</span> OS<span class="op">&gt;</span></span>
<span id="cb49-184"><a href="#cb49-184" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-185"><a href="#cb49-185" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> product_into<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-186"><a href="#cb49-186" aria-hidden="true" tabindex="-1"></a>        I in_first, IS in_last,</span>
<span id="cb49-187"><a href="#cb49-187" aria-hidden="true" tabindex="-1"></a>        O out_first, OS out_last<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-188"><a href="#cb49-188" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><em>execution-policy</em> Ep,</span>
<span id="cb49-189"><a href="#cb49-189" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> IR,</span>
<span id="cb49-190"><a href="#cb49-190" aria-hidden="true" tabindex="-1"></a>           <em>sized-forward-range</em> OR<span class="op">&gt;</span></span>
<span id="cb49-191"><a href="#cb49-191" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="co">/* <em>see below</em> */</span></span>
<span id="cb49-192"><a href="#cb49-192" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> product_into<span class="op">(</span>Ep<span class="op">&amp;&amp;</span> exec, <span class="co">// <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span></span>
<span id="cb49-193"><a href="#cb49-193" aria-hidden="true" tabindex="-1"></a>        IR<span class="op">&amp;&amp;</span> in,</span>
<span id="cb49-194"><a href="#cb49-194" aria-hidden="true" tabindex="-1"></a>        OR<span class="op">&amp;&amp;</span> out<span class="op">)</span> <span class="op">-&gt;</span> <span class="co">/* <em>see below</em> */</span>;</span>
<span id="cb49-195"><a href="#cb49-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-196"><a href="#cb49-196" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="co">// namespace ranges</span></span></code></pre></div>

</div>
<div class="sourceCode" id="cb50"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>// [inner.product], inner product</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>template&lt;class InputIterator1, class InputIterator2, class T&gt;</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>                            InputIterator2 first2, T init);</span></code></pre></div>
<h3 data-number="5.3.3" id="add-declarations-of-ranges-transform_reduce-dot-and-dot_into"><span class="header-section-number">5.3.3</span> Add declarations of ranges
<code>transform_reduce</code>, <code>dot</code>, and
<code>dot_into</code><a href="#add-declarations-of-ranges-transform_reduce-dot-and-dot_into" class="self-link"></a></h3>
<div class="sourceCode" id="cb51"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>  template&lt;class ExecutionPolicy, class ForwardIterator, class T,</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>           class BinaryOperation, class UnaryOperation&gt;</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    T transform_reduce(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>                       ForwardIterator first, ForwardIterator last, T init,</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>                       BinaryOperation binary_op, UnaryOperation unary_op);</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb52"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>  namespace ranges {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of unary transform_reduce</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of unary transform_reduce</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of unary transform_reduce_into</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of unary transform_reduce_into</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of binary transform_reduce</span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of binary transform_reduce</span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of binary transform_reduce_into</span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of binary transform_reduce_into</span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of dot</span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of dot</span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of dot_into</span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-45"><a href="#cb52-45" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-46"><a href="#cb52-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-47"><a href="#cb52-47" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of dot_into</span>
<span id="cb52-48"><a href="#cb52-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-49"><a href="#cb52-49" aria-hidden="true" tabindex="-1"></a>  // TODO</span>
<span id="cb52-50"><a href="#cb52-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-51"><a href="#cb52-51" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>

</div>
<div class="sourceCode" id="cb53"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>  // [partial.sum], partial sum</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  template&lt;class InputIterator, class OutputIterator&gt;</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    constexpr OutputIterator</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>      partial_sum(InputIterator first, InputIterator last,</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>                  OutputIterator result);</span></code></pre></div>
<h3 data-number="5.3.4" id="add-declarations-of-ranges-exclusive_scan"><span class="header-section-number">5.3.4</span> Add declarations of ranges
<code>exclusive_scan</code><a href="#add-declarations-of-ranges-exclusive_scan" class="self-link"></a></h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T,</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>           class BinaryOperation&gt;</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    ForwardIterator2</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>      exclusive_scan(ExecutionPolicy&amp;&amp; exec,                    // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>                     ForwardIterator1 first, ForwardIterator1 last,</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>                     ForwardIterator2 result, T init, BinaryOperation binary_op);</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb55"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>  namespace ranges {</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    // Non-parallel overloads of exclusive_scan</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    // TODO</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    // Parallel overloads of exclusive_scan</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    // TODO</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>

</div>
<div class="sourceCode" id="cb56"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>  // [inclusive.scan], inclusive scan</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  template&lt;class InputIterator, class OutputIterator&gt;</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    constexpr OutputIterator</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>      inclusive_scan(InputIterator first, InputIterator last,</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>                     OutputIterator result);</span></code></pre></div>
<h3 data-number="5.3.5" id="add-declarations-of-ranges-inclusive_scan"><span class="header-section-number">5.3.5</span> Add declarations of ranges
<code>inclusive_scan</code><a href="#add-declarations-of-ranges-inclusive_scan" class="self-link"></a></h3>
<div class="sourceCode" id="cb57"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>           class BinaryOperation, class T&gt;</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    ForwardIterator2</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>      inclusive_scan(ExecutionPolicy&amp;&amp; exec,                    // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>                     ForwardIterator1 first, ForwardIterator1 last,</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>                     ForwardIterator2 result, BinaryOperation binary_op, T init);</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb58"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>  namespace ranges {</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    // Non-parallel overloads of inclusive_scan</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    // TODO</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    // Parallel overloads of inclusive_scan</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    // TODO</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>

</div>
<div class="sourceCode" id="cb59"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  // [transform.exclusive.scan], transform exclusive scan</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  template&lt;class InputIterator, class OutputIterator, class T,</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>           class BinaryOperation, class UnaryOperation&gt;</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    constexpr OutputIterator</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>      transform_exclusive_scan(InputIterator first, InputIterator last,</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>                               OutputIterator result, T init,</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>                               BinaryOperation binary_op, UnaryOperation unary_op);</span></code></pre></div>
<h3 data-number="5.3.6" id="todo-what-about-transform_exclusive_scan"><span class="header-section-number">5.3.6</span> TODO What about
<code>transform_exclusive_scan</code>?<a href="#todo-what-about-transform_exclusive_scan" class="self-link"></a></h3>
<h3 data-number="5.3.7" id="todo-what-about-transform_inclusive_scan"><span class="header-section-number">5.3.7</span> TODO What about
<code>transform_inclusive_scan</code>?<a href="#todo-what-about-transform_inclusive_scan" class="self-link"></a></h3>
<h3 data-number="5.3.8" id="add-wording-for-algorithms"><span class="header-section-number">5.3.8</span> Add wording for algorithms<a href="#add-wording-for-algorithms" class="self-link"></a></h3>
<p>TODO</p>
<h1 data-number="6" id="references"><span class="header-section-number">6</span> References<a href="#references" class="self-link"></a></h1>
<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-P1813R0" class="csl-entry" role="listitem">
<div class="csl-left-margin">[P1813R0] </div><div class="csl-right-inline">Christopher Di Bella. 2019. A Concept Design
for the Numeric Algorithms. <a href="https://wg21.link/p1813r0"><div class="csl-block">https://wg21.link/p1813r0</div></a></div>
</div>
</div>
</div>
</div>
</body>
</html>
