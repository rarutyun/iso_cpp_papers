---
title: Add description for parallel `<memory>` algorithms
document: P0000R0
date: today
author:
    - name: Ruslan Arutyunyan
      email: <ruslan.arutyunyan@intel.com>
audience:
    - LWG
toc-depth: 4
---

<style>
@media screen {
    #TOC {
        position: fixed;
        width: min(20%, 30em);
        height: 100%;
        left: 0;
        top: 0;
        overflow-y: scroll;
        padding-left: 1em;
        padding-right: 1em;
        text-align: left;
        a {
            font-size: 110%;
        }
    }
    body {
        padding-left: min(21%, 32em);
    }
}
</style>

# Abstract # {- .unlisted}

This paper adds the algorithmic description for parallel `<memory>` algorithms.

# Motivation # {#motivation}

C++ standard has parallel `<memory>` algorithms since C++17. [@P3179R9] adds overloads for the parallel `<memory>`
algorithms for C++26. However, the problem is that those algorithms exist in `<memory>` header synopsis only (
[memory.syn]{- .sref} and were never described in [specialized.algorithms]{- .sref}, which is a dedicated place for
algorithmic description of `<memory>` algorithms (not only parallel).

This proposal aims to fix that.

# Formal wording # {#formal_wording}

## Modify [uninitialized.construct.default]{- .sref}

```diff
template<class NoThrowForwardIterator>
  constexpr void uninitialized_default_construct(NoThrowForwardIterator first,
                                                 NoThrowForwardIterator last);
+ template<class ExecutionPolicy, class NoThrowForwardIterator>
+   void uninitialized_default_construct(ExecutionPolicy&& exec,
+                                        NoThrowForwardIterator first,
+                                        NoThrowForwardIterator last);
```

[1]{.pnum} *Effects*: Equivalent to:
```cpp
  for (; first != last; ++first)
    ::new (voidify(*first))
      typename iterator_traits<NoThrowForwardIterator>::value_type;
```

```diff
namespace ranges {
  template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
    requires default_initializable<iter_value_t<I>>
    constexpr I uninitialized_default_construct(I first, S last);
  template<@_nothrow-forward-range_@ R>
    requires default_initializable<range_value_t<R>>
    constexpr borrowed_iterator_t<R> uninitialized_default_construct(R&& r);

+ template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I,
+          @_nothrow-sized-sentinel-for_@<I> S>
+   requires default_initializable<iter_value_t<I>>
+     I uninitialized_default_construct(Ep&& exec,
+                                       I first, S last);
+ template<@_execution-policy_@ Ep, @_nothrow-sized-random-access-range_@ R>
+   requires default_initializable<range_value_t<R>>
+     borrowed_iterator_t<R> uninitialized_default_construct(Ep&& exec
+                                                            R&& r);
}
```

[2]{.pnum} *Effects*: Equivalent to:
```cpp
  for (; first != last; ++first)
    ::new (voidify(*first)) remove_reference_t<iter_reference_t<I>>;
  return first;
```

```diff
template<class NoThrowForwardIterator, class Size>
  constexpr NoThrowForwardIterator
    uninitialized_default_construct_n(NoThrowForwardIterator first, Size n);
+ template<class ExecutionPolicy, class NoThrowForwardIterator, class Size>
+   NoThrowForwardIterator
+     uninitialized_default_construct_n(ExecutionPolicy&& exec,
+                                       NoThrowForwardIterator first,
+                                       Size n);
```

[3]{.pnum} *Effects*: Equivalent to:
```cpp
  for (; n > 0; (void)++first, --n)
    ::new (voidify(*first))
      typename iterator_traits<NoThrowForwardIterator>::value_type;
  return first;
```

```cpp
namespace ranges {
  template<@_nothrow-forward-iterator_@ I>
    requires default_initializable<iter_value_t<I>>
    constexpr I uninitialized_default_construct_n(I first, iter_difference_t<I> n);

}
```

[4]{.pnum} *Effects*: Equivalent to:
```cpp
  return uninitialized_default_construct(counted_iterator(first, n),
                                         default_sentinel).base();
```

::: add
```
namespace ranges {
  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
    requires default_initializable<iter_value_t<I>>
      I uninitialized_default_construct_n(Ep&& exec, I first,
                                          iter_difference_t<I> n);
}
```
[5]{.pnum} *Effects*: Equivalent to:
```cpp
  return uninitialized_default_construct(std::forward<Ep>(exec), counted_iterator(first, n),
                                         default_sentinel).base();
```
:::

## Modify [uninitialized.construct.value]{- .sref}

```diff
template<class NoThrowForwardIterator>
  constexpr void uninitialized_value_construct(NoThrowForwardIterator first,
                                               NoThrowForwardIterator last);
+ template<class ExecutionPolicy, class NoThrowForwardIterator>
+   void uninitialized_value_construct(ExecutionPolicy&& exec,
+                                      NoThrowForwardIterator first,
+                                      NoThrowForwardIterator last)
```

[1]{.pnum} *Effects*: Equivalent to:
```cpp
  for (; first != last; ++first)
    ::new (voidify(*first))
      typename iterator_traits<NoThrowForwardIterator>::value_type();
```

```diff
namespace ranges {
  template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
    requires default_initializable<iter_value_t<I>>
    constexpr I uninitialized_value_construct(I first, S last);
  template<@_nothrow-forward-range_@ R>
    requires default_initializable<range_value_t<R>>
    constexpr borrowed_iterator_t<R> uninitialized_value_construct(R&& r);

+ template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I,
+          @_nothrow-sized-sentinel-for<_@I> S>
+   requires default_initializable<iter_value_t<I>>
+     I uninitialized_value_construct(Ep&& exec,
+                                     I first, S last);
+ template<@_execution-policy_@ Ep, @_nothrow-sized-random-access-range_@ R>
+   requires default_initializable<range_value_t<R>>
+     borrowed_iterator_t<R> uninitialized_value_construct(Ep&& exec
+                                                          R&& r);
}
```

[2]{.pnum} *Effects*: Equivalent to:
```cpp
  for (; first != last; ++first)
    ::new (voidify(*first)) remove_reference_t<iter_reference_t<I>>();
  return first;
```

```diff
template<class NoThrowForwardIterator, class Size>
  constexpr NoThrowForwardIterator
    uninitialized_value_construct_n(NoThrowForwardIterator first, Size n);
+ template<class ExecutionPolicy, class NoThrowForwardIterator, class Size>
+   NoThrowForwardIterator
+     uninitialized_value_construct_n(ExecutionPolicy&& exec,
+                                     NoThrowForwardIterator first,
+                                     Size n);
```

[3]{.pnum} *Effects*: Equivalent to:
```cpp
  for (; n > 0; (void)++first, --n)
    ::new (voidify(*first))
      typename iterator_traits<NoThrowForwardIterator>::value_type();
  return first;
```

```cpp
namespace ranges {
  template<@_nothrow-forward-iterator_@ I>
    requires default_initializable<iter_value_t<I>>
    constexpr I uninitialized_value_construct_n(I first, iter_difference_t<I> n);
}
```

[4]{.pnum} *Effects*: Equivalent to:
```cpp
  return uninitialized_value_construct(counted_iterator(first, n),
                                       default_sentinel).base();
```

::: add
```
namespace ranges {
template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
  requires default_initializable<iter_value_t<I>>
    I uninitialized_value_construct_n(Ep&& exec, I first,
                                      iter_difference_t<I> n);
}
```

[5]{.pnum} *Effects*: Equivalent to:
```cpp
  return uninitialized_value_construct(std::forward<Ep>(exec), counted_iterator(first, n),
                                       default_sentinel).base();
```
:::

## Modify [uninitialized.copy]{- .sref}

```diff
template<class InputIterator, class NoThrowForwardIterator>
  constexpr NoThrowForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                                      NoThrowForwardIterator result);
+ template<class ExecutionPolicy, class ForwardIterator, class NoThrowForwardIterator>
+   NoThrowForwardIterator uninitialized_copy(ExecutionPolicy&& exec,
+                                             ForwardIterator first,
+                                             ForwardIterator last,
+                                             NoThrowForwardIterator result);
```

[1]{.pnum} *Preconditions*: `result` + [0, `(last - first)`) does not overlap with [`first`, `last`).

[2]{.pnum} *Effects*: Equivalent to:
```cpp
  for (; first != last; ++result, (void)++first)
    ::new (voidify(*result))
      typename iterator_traits<NoThrowForwardIterator>::value_type(*first);
```

[3]{.pnum} *Returns*: `result`.

```diff
namespace ranges {
  template<input_iterator I, sentinel_for<I> S1,
           @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for<O_@> S2>
    requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
    constexpr uninitialized_copy_result<I, O>
      uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
  template<input_range IR, @_nothrow-forward-range_@ OR>
    requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
    constexpr uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
      uninitialized_copy(IR&& in_range, OR&& out_range);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S1,
+           @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S2>
+    requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
+      uninitialized_copy_result<I, O>
+        uninitialized_copy(Ep&& exec, I ifirst, S1 ilast,
+                           O ofirst, S2 olast);
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ IR,
+           @_nothrow-sized-random-access-range_@ OR>
+    requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
+      uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
+        uninitialized_copy(Ep&& exec, IR&& in_range,
+                           OR&& out_range);
}
```

[4]{.pnum} *Preconditions*: [`ofirst`, `olast`) does not overlap with [`ifirst`, `ilast`).

[5]{.pnum} *Effects*: Equivalent to:
```diff
  for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst)
    ::new (voidify(*ofirst)) remove_reference_t<iter_reference_t<O>>(*ifirst);
-  return {std::move(ifirst), ofirst};
```

::: add
[x]{.pnum} *Returns*: `{ifirst, ofirst}`.
:::

```diff
template<class InputIterator, class Size, class NoThrowForwardIterator>
  constexpr NoThrowForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                                        NoThrowForwardIterator result);
+ template<class ExecutionPolicy, class ForwardIterator, class Size,
+          class NoThrowForwardIterator>
+   NoThrowForwardIterator uninitialized_copy_n(ExecutionPolicy&& exec,
+                                               ForwardIterator first,
+                                               Size n,
+                                               NoThrowForwardIterator result);
```

[6]{.pnum} *Preconditions*: `result` + [0, `n`) does not overlap with `first` + [0, `n`).

[7]{.pnum}*Effects*: Equivalent to:
```cpp
  for (; n > 0; ++result, (void)++first, --n)
    ::new (voidify(*result))
      typename iterator_traits<NoThrowForwardIterator>::value_type(*first);
```

[8]{.pnum}*Returns*: `result`.

```cpp
namespace ranges {
  template<input_iterator I, @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S>
    requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
    constexpr uninitialized_copy_n_result<I, O>
      uninitialized_copy_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
}
```
[9]{.pnum} *Preconditions*: `[ofirst, olast)` does not overlap with `ifirst` + [0, `n`).

[10]{.pnum} *Effects*: Equivalent to:
```cpp
  auto t = uninitialized_copy(counted_iterator(std::move(ifirst), n),
                              default_sentinel, ofirst, olast);
  return {std::move(t.in).base(), t.out};
```

::: add
```
template<@_execution-policy_@ Ep, random_access_iterator I, @_nothrow-random-access-iterator_@ O,
         @_nothrow-sized-sentinel-for_@<O> S>
  requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
    uninitialized_copy_n_result<I, O>
      uninitialized_copy_n(Ep&& exec, I ifirst, iter_difference_t<I> n
                           O ofirst, S olast);
```

[x]{.pnum} *Preconditions*: [`ofirst`, `olast`) does not overlap with `ifirst` + [0, `n`).

[x]{.pnum} *Effects*: Equivalent to:
```cpp
  auto t = uninitialized_copy(std::forward<Ep>(ep), counted_iterator(std::move(ifirst), n),
                              default_sentinel, ofirst, olast);
  return {in.base(), t.out};
```
:::

## Modify [uninitialized.move]{- .sref}

```cpp
template<class InputIterator, class NoThrowForwardIterator>
  constexpr NoThrowForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                                      NoThrowForwardIterator result);
```

*Preconditions*: `result + [0, (last - first))` does not overlap with `[first, last)`.

*Effects*: Equivalent to:
```cpp
for (; first != last; (void)++result, ++first)
  ::new (voidify(*result))
    typename iterator_traits<NoThrowForwardIterator>::value_type(deref-move(first));
return result;
```
```cpp
namespace ranges {
  template<input_iterator I, sentinel_for<I> S1,
           @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S2>
    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
    constexpr uninitialized_move_result<I, O>
      uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
  template<input_range IR, @_nothrow-forward-range_@ OR>
    requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
    constexpr uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
      uninitialized_move(IR&& in_range, OR&& out_range);
}
```
*Preconditions*: `[ofirst, olast)` does not overlap with `[ifirst, ilast)`.

*Effects*: Equivalent to:
```cpp
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst)
  ::new (voidify(*ofirst))
    remove_reference_t<iter_reference_t<O>>(ranges::iter_move(ifirst));
return {std::move(ifirst), ofirst};
```

[If an exception is thrown, some objects in the range `[ifirst, ilast)` are left in a valid, but unspecified state.]{.note}
```cpp
template<class InputIterator, class Size, class NoThrowForwardIterator>
  constexpr pair<InputIterator, NoThrowForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, NoThrowForwardIterator result);
```
*Preconditions*: `result + [0, n)` does not overlap with `first + [0, n)`.

*Effects*: Equivalent to:
```cpp
for (; n > 0; ++result, (void)++first, --n)
  ::new (voidify(*result))
    typename iterator_traits<NoThrowForwardIterator>::value_type(deref-move(first));
return {first, result};
```
```cpp
namespace ranges {
  template<input_iterator I, @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S>
    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
    constexpr uninitialized_move_n_result<I, O>
      uninitialized_move_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
}
```

*Preconditions*: `[ofirst, olast)` does not overlap with `ifirst + [0, n)`.

*Effects*: Equivalent to:
```cpp
auto t = uninitialized_move(counted_iterator(std::move(ifirst), n),
                            default_sentinel, ofirst, olast);
return {std::move(t.in).base(), t.out};
```

[If an exception is thrown, some objects in the range `ifirst + [0, n)` are left in a valid but unspecified state.]{.note}

## Modify [uninitialized.fill]{- .sref}

```cpp
template<class NoThrowForwardIterator, class T>
  constexpr void uninitialized_fill(NoThrowForwardIterator first,
                                    NoThrowForwardIterator last, const T& x);
```

*Effects*: Equivalent to:
```cpp
for (; first != last; ++first)
  ::new (voidify(*first))
    typename iterator_traits<NoThrowForwardIterator>::value_type(x);
```
```cpp
namespace ranges {
  template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S, class T>
    requires constructible_from<iter_value_t<I>, const T&>
    constexpr I uninitialized_fill(I first, S last, const T& x);
  template<@_nothrow-forward-range_@ R, class T>
    requires constructible_from<range_value_t<R>, const T&>
    constexpr borrowed_iterator_t<R> uninitialized_fill(R&& r, const T& x);
}
```

*Effects*: Equivalent to:
```cpp
for (; first != last; ++first)
  ::new (voidify(*first)) remove_reference_t<iter_reference_t<I>>(x);
return first;
```
```cpp
template<class NoThrowForwardIterator, class Size, class T>
  constexpr NoThrowForwardIterator
    uninitialized_fill_n(NoThrowForwardIterator first, Size n, const T& x);
```

*Effects*: Equivalent to:
```cpp
for (; n--; ++first)
  ::new (voidify(*first))
    typename iterator_traits<NoThrowForwardIterator>::value_type(x);
return first;
```
```cpp
namespace ranges {
  template<@_nothrow-forward-iterator_@ I, class T>
    requires constructible_from<iter_value_t<I>, const T&>
    constexpr I uninitialized_fill_n(I first, iter_difference_t<I> n, const T& x);
}
```


*Effects*: Equivalent to:
```cpp
return uninitialized_fill(counted_iterator(first, n), default_sentinel, x).base();
```

## Modify [specialized.destroy]{- .sref}
```cpp
template<class T>
  constexpr void destroy_at(T* location);
namespace ranges {
  template<destructible T>
    constexpr void destroy_at(T* location) noexcept;
}
```
*Effects*:
(1.1)
If T is an array type, equivalent to destroy(begin(*location), end(*location)).
(1.2)
Otherwise, equivalent to location->~T().
```cpp
template<class NoThrowForwardIterator>
  constexpr void destroy(NoThrowForwardIterator first, NoThrowForwardIterator last);
```

*Effects*: Equivalent to:
```cpp
for (; first != last; ++first)
  destroy_at(addressof(*first));
```
```cpp
namespace ranges {
  template<@_nothrow-input-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
    requires destructible<iter_value_t<I>>
    constexpr I destroy(I first, S last) noexcept;
  template<@_nothrow-input-range_@ R>
    requires destructible<range_value_t<R>>
    constexpr borrowed_iterator_t<R> destroy(R&& r) noexcept;
}
```


*Effects*: Equivalent to:
```cpp
for (; first != last; ++first)
  destroy_at(addressof(*first));
return first;
```
```cpp
template<class NoThrowForwardIterator, class Size>
  constexpr NoThrowForwardIterator destroy_n(NoThrowForwardIterator first, Size n);
```

*Effects*: Equivalent to:
```cpp
for (; n > 0; (void)++first, --n)
  destroy_at(addressof(*first));
return first;
```
```cpp
namespace ranges {
  template<@_nothrow-input-iterator_@ I>
    requires destructible<iter_value_t<I>>
    constexpr I destroy_n(I first, iter_difference_t<I> n) noexcept;
}
```
*Effects*: Equivalent to:
```cpp
return destroy(counted_iterator(std::move(first), n), default_sentinel).base();
```

## Modify [memory.syn]{- .sref} ## {#modify_memory_syn}

```diff
namespace ranges {
  template<class I, class O>
    using uninitialized_move_result = in_out_result<I, O>;                        @_// freestanding_@
  template<input_iterator I, sentinel_for<I> S1,
           @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S2>
    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
      uninitialized_move_result<I, O>
        uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);              @_// freestanding_@
  template<input_range IR, @_nothrow-forward-range_@ OR>
    requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
      uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
        uninitialized_move(IR&& in_range, OR&& out_range);                       @_// freestanding_@

  template<input_iterator I,
            @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S>
    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
      uninitialized_move_n_result<I, O>
        uninitialized_move_n(I ifirst, iter_difference_t<I> n,                   @_// freestanding_@
                             O ofirst, S olast);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S1,
+          @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S2>
+    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
+      uninitialized_move_result<I, O>
+        uninitialized_move(Ep&& exec, I ifirst, S1 ilast,  @_// freestanding-deleted_,@
+                           O ofirst, S2 olast);            @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ IR, @_nothrow-sized-random-access-range_@ OR>
+    requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
+      uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
+        uninitialized_move(Ep&& exec, IR&& in_range,       @_// freestanding-deleted_,@
+                           OR&& out_range);                @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, random_access_iterator I,
+      @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S>
+    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
+      uninitialized_move_n_result<I, O>
+        uninitialized_move_n(Ep&& exec, I ifirst, iter_difference_t<I> n, @_// freestanding-deleted_,@
+                             O ofirst, S olast);                          @_// see [algorithms.parallel.overloads]_@
}

namespace ranges {
  template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S, class T>
    requires constructible_from<iter_value_t<I>, const T&>
      I uninitialized_fill(I first, S last, const T& x);                          @_// freestanding_@
  template<@_nothrow-forward-range_@ R, class T>
    requires constructible_from<range_value_t<R>, const T&>
      borrowed_iterator_t<R> uninitialized_fill(R&& r, const T& x);               @_// freestanding_@

  template<@_nothrow-forward-iterator_@ I, class T>
    requires constructible_from<iter_value_t<I>, const T&>
      I uninitialized_fill_n(I first, iter_difference_t<I> n, const T& x);        @_// freestanding_@

+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for_@<I> S, class T>
+    requires constructible_from<iter_value_t<I>, const T&>
+      I uninitialized_fill(Ep&& exec, I first, S last,                      @_// freestanding-deleted_,@
+                           const T& x);                                     @_// see [algorithms.parallel.overloads]_@
+  template<@_execution-policy_@ Ep, @_nothrow-sized-random-access-range_@ R, class T>
+    requires constructible_from<range_value_t<R>, const T&>
+      borrowed_iterator_t<R> uninitialized_fill(Ep&& exec, R&& r,           @_// freestanding-deleted_,@
+                                                const T& x);                @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, class T>
+    requires constructible_from<iter_value_t<I>, const T&>
+      I uninitialized_fill_n(Ep&& exec, I first,                            @_// freestanding-deleted_,@
+                             iter_difference_t<I> n, const T& x);           @_// see [algorithms.parallel.overloads]_@
}

namespace ranges {
  template<@_nothrow-input-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
    requires destructible<iter_value_t<I>>
      constexpr I destroy(I first, S last) noexcept;                              @_// freestanding_@
  template<@_nothrow-input-range_@ R>
    requires destructible<range_value_t<R>>
      constexpr borrowed_iterator_t<R> destroy(R&& r) noexcept;                   @_// freestanding_@

  template<@_nothrow-input-iterator_@ I>
    requires destructible<iter_value_t<I>>
      constexpr I destroy_n(I first, iter_difference_t<I> n) noexcept;            @_// freestanding_@

+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for_@<I> S>
+    requires destructible<iter_value_t<I>>
+      I destroy(Ep&& exec,                                           @_// freestanding-deleted_,@
+                I first, S last) noexcept;                           @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-sized-random-access-range_@ R>
+    requires destructible<range_value_t<R>>
+      borrowed_iterator_t<R> destroy(Ep&& exec,                      @_// freestanding-deleted_,@
+                                     R&& r) noexcept;                @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
+    requires destructible<iter_value_t<I>>
+      I destroy_n(Ep&& exec, I first,                                @_// freestanding-deleted_,@
+                  iter_difference_t<I> n) noexcept;                  @_// see [algorithms.parallel.overloads]_@
}
```


