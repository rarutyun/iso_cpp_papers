---
title: C++ parallel range algorithms
document: P3179R5
date: today
author:
    - name: Ruslan Arutyunyan
      email: <ruslan.arutyunyan@intel.com>
    - name: Alexey Kukanov
      email: <alexey.kukanov@intel.com>
    - name: Bryce Adelstein Lelbach (he/him/his)
      email: <brycelelbach@gmail.com>
audience:
    - LEWG
---

<style>
/*
table, th, td {
    border: 1px solid black;
}

span, span * {
  white-space: pre;
}
*/
@media screen {
    #TOC {
        position: fixed;
        width: min(25%, 30em);
        height: 100%;
        left: 0;
        top: 0;
        overflow-y: scroll;
        padding-left: 1em;
        padding-right: 1em;
        text-align: left;
        a {
            font-size: 110%;
        }
    }
    body {
        padding-left: min(26%, 32em);
    }
}
</style>

# Abstract # {- .unlisted}

This paper proposes adding parallel algorithms that work together with the C++ Ranges library.

# Motivation # {#motivation}

Standard parallel algorithms with execution policies which set semantic requirements to user-provided callable objects
were a good start for supporting parallelism in the C++ standard.

The C++ Ranges library - ranges, views, etc. - is a powerful facility to produce lazily evaluated pipelines
that can be processed by range-based algorithms. Together they provide a productive and expressive API
with the room for extra optimizations.

Combining these two powerful features by adding support for execution policies to the range-based algorithms opens
an opportunity to fuse several computations into one parallel algorithm call, thus reducing the overhead on parallelism.
That is especially valuable for heterogeneous implementations of parallel algorithms, for which the range-based API helps
reducing the number of kernels submitted to an accelerator.

Users are already using ranges and range adaptors by passing range iterators to the existing non-range parallel
algorithms. [@P2408R5] was adopted to enable this. This pattern is often featured when teaching C++ parallel algorithms
and appears in many codebases.

`iota` and `cartesian_product` are especially common, as many compute workloads want to iterate over indices, not
objects, and many work with multidimensional data. `transform` is also common, as it enables fusion of element-wise
operations into a single parallel algorithm call, which can avoid the need for temporary storage and is more
performant than two separate calls.

However, passing range iterators to non-range algorithms is unwieldy and verbose. It is surprising to
users that they cannot simply pass the ranges to the parallel algorithms as they would for serial algorithms.

<table>
<tr>
<th colspan=2>Scalar-Vector Multiply
<tr>
<th>Before
<th>After
<tr>
<td>
```cpp
std::span<double> data = …;
double C = …;

auto indices = std::views::iota(1, data.size());
std::for_each(std::execution::par_unseq,
  std::ranges::begin(indices),
  std::ranges::end(indices),
  [=] (auto i) { data[i] *= C; });
```
<td>
```cpp
std::span<double> data = …;
double C = …;

std::ranges::for_each(std::execution::par_unseq,
  std::views::iota(1, data.size()),
  [=] (auto i) { data[i] *= C; });
```
</table>

<table>
<tr>
<th colspan=2>Matrix Transpose
<tr>
<th>Before
<th>After
<tr>
<td>
```cpp
std::mdspan A{input,  N, M};
std::mdspan B{output, M, N};

auto indices = std::views::cartesian_product(
  std::views::iota(0, A.extent(0)),
  std::views::iota(0, A.extent(1)));

std::for_each(std::execution::par_unseq,
  std::ranges::begin(indices),
  std::ranges::end(indices),
  [=] (auto idx) {
    auto [i, j] = idx;
    B[j, i] = A[i, j];
  });
```
<td>
```cpp
std::mdspan A{input,  N, M};
std::mdspan B{output, M, N};

std::ranges::for_each(std::execution::par_unseq,
  std::views::cartesian_product(
    std::views::iota(0, A.extent(0)),
    std::views::iota(0, A.extent(1))),
  [=] (auto idx) {
    auto [i, j] = idx;
    B[j, i] = A[i, j];
  });
```
</table>

Earlier, [@P2500R2] proposed to add the range-based C++ parallel algorithms together with its primary goal of extending
algorithms with schedulers. We have decided to split those parts to separate papers, which could progress independently.

# Design overview # {#design_overview}

This paper proposes execution policy support for C++ range-based algorithms. In the nutshell, the proposal extends C++
range algorithms with overloads taking any standard or implementation defined C++ execution policy as a function parameter.
These overloads are further referred to as *parallel range algorithms*.

The proposal is targeted to C++26.

## Design summary ## {#design_summary}

### Differences to serial range algorithms ### {#design_diff_to_cpp20_ranges}

Comparing to the C++20 serial range algorithms, we propose the following modifications:

- The execution policy parameter is added, supporting all standard and implementation-defined execution policies. ([[#supported_policies]])
- `for_each` and `for_each_n` return only an iterator but not the function. ([[#return_type]])
- Parallel range algorithms take a range, not an iterator, as the output for the overloads with ranges, and additionally take
    an output sentinel for the "iterator and sentinel" overloads. ([[#range_as_the_output]])
- Until better parallelism-friendly abstractions are proposed, parallel algorithms require `random_access_{iterator,range}`. ([[#random_access_requirement]])
- All input and output data sequences must be bounded. ([[#require_bounded_ranges]])

### Differences to C++17 parallel algorithms ### {#design_diff_to_cpp17_par}

In addition to data sequences being passed as either ranges or "iterator and sentinel" pairs, the following differences
to the C++17 parallel algorithms are proposed:

- `for_each` returns an iterator, not `void`.
- Algorithms require `random_access_{iterator,range}`, and not *LegacyForwardIterator*.
- All input and output data sequences must be bounded.

### Other design aspects ### {#design_other_aspects}

- Except as mentioned above, the parallel range algorithms should return the same type as the corresponding serial range algorithms. ([[#return_type]])
- The proposed algorithms extend the overload set of algorithm function objects defined in `std::ranges`. ([[#algorithm_func_objects]])
- The proposed algorithms should require callable object passed to an algorithm to be `regular_invocable` where possible. ([[#callable_parameters]])
- The proposed algorithms should follow the design of C++17 parallel algorithms with regard to `constexpr` support. ([[#constexpr_support]])

### An example of the proposed API ### {#design_api_example}

The proposed API will look like the following (using `transform` as an example):

```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
  ranges::unary_transform_result<I, O>
    ranges::transform(Ep&& exec, I first, S last, O result, OutS result_last,
                      F op, Proj proj = {});

template<@_execution-policy_@ Ep, ranges::@_random-access-sized-range_@ R, ranges::@_random-access-sized-range_@ OutR,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<ranges::iterator_t<OutR>, indirect_result_t<F&, projected<ranges::iterator_t<R>, Proj>>>
  ranges::unary_transform_result<ranges::borrowed_iterator_t<R>, ranges::borrowed_iterator_t<OutR>>
    ranges::transform(Ep&& exec, R&& r, OutR&& result, F op, Proj proj = {});
```

The used exposition-only concepts are described below.

## Coexistence with schedulers ## {#coexistence_with_schedulers}

We believe that adding parallel range algorithms does not have the risk of conflict with anticipated scheduler-based
algorithms, because an execution policy does not satisfy the requirements for a policy-aware scheduler [@P2500R2],
a sender [@P3300R0], or really anything else from [@P2300R10] that can be used to specify such algorithms.

At this point we do not, however, discuss how the appearance of schedulers
may or should impact the execution rules for parallel algorithms specified in
[algorithms.parallel.exec]{- .sref},
and just assume that the same rules apply to the range algorithms with execution policies.

## Supported execution policies ## {#supported_policies}

Parallel range algorithms should operate with the same set of execution policies as the existing parallel algorithms,
that is, `seq`, `unseq`, `par`, and `par_unseq` in the `std::execution` namespace, as well as any implementation-defined
execution policies.

The following exposition-only concept simplifies constraining the algorithms with proper execution policy types:

```cpp
template<class Ep>
concept @_execution-policy_@ = @_`// exposition only`_@
    is_execution_policy_v<remove_cvref_t<Ep>>;
```

We do not propose the parallel range algorithms to be customizable for application-defined execution policies.
We expect such custom policies to become unnecessary once the standard algorithms are capable of working with
schedulers/senders/receivers.

## Algorithm return types ## {#return_type}

We explored possible algorithm return types and came to conclusion that returning the same type as serial range
algorithms is the preferred option to make the changes for enabling parallelism minimal.

```cpp
auto res = std::ranges::sort(v);
```

becomes:

```cpp
auto res = std::ranges::sort(std::execution::par, v);
```

However, `std::ranges::for_each` and `std::ranges::for_each_n` require special consideration because previous
design decisions suggest that there should be a difference between serial and parallel versions.

The following table summarizes return value types for the existing variants of these two algorithms:

<table>
  <tr>
    <th>API</th>
    <th>Return type</th>
  </tr>
  <tr>
    <td>`std::for_each`</td>
    <td>`Function`</td>
  </tr>
  <tr>
    <td>Parallel `std::for_each`</td>
    <td>`void`</td>
  </tr>
  <tr>
    <td>`std::for_each_n`</td>
    <td>`Iterator`</td>
  </tr>
  <tr>
    <td>Parallel `std::for_each_n`</td>
    <td>`Iterator`</td>
  </tr>
  <tr>
    <td>`std::ranges::for_each`</td>
    <td>`for_each_result<ranges::borrowed_iterator_t<Range>, Function>`</td>
  </tr>
  <tr>
    <td>`std::ranges::for_each`, `I` + `S` overload</td>
    <td>`for_each_result<Iterator, Function>`</td>
  </tr>
  <tr>
    <td>`std::ranges::for_each_n`</td>
    <td>`for_each_n_result<Iterator, Function>`</td>
  </tr>
</table>

While the serial `std::for_each` returns the obtained function object with all modifications it might have accumulated,
the return type for the parallel `std::for_each` is `void` because, as stated in the standard, "parallelization often
does not permit efficient state accumulation". For efficient parallelism an implementation can make multiple copies of
the function object, which for that purpose is allowed to be copyable and not just movable like for the serial `for_each`.
That implies that users cannot rely on any state accumulation within that function object, so it does not make sense
(and might be even dangerous) to return it.

In `std::ranges`, the return type of `for_each` and `for_each_n` is unified to return both an iterator and the function
object.

Based on the analysis above and [the feedback from SG9](#sg9_tokyo_2024) we think that the most reasonable return type
for parallel variants of `std::ranges::for_each` and `std::ranges::for_each_n` should be:

<table>
  <tr>
    <th>API</th>
    <th>Return type</th>
  </tr>
  <tr>
    <td>Parallel `std::ranges::for_each`</td>
    <td>`ranges::borrowed_iterator_t<Range>`</td>
  </tr>
  <tr>
    <td>Parallel `std::ranges::for_each`, `I` + `S` overload</td>
    <td>`Iterator`</td>
  </tr>
  <tr>
    <td>Parallel `std::ranges::for_each_n`</td>
    <td>`Iterator`</td>
  </tr>
</table>


## Extending the overload sets of algorithm function objects ## {#algorithm_func_objects}

We believe the proposed functionality should have the same properties and general behavior as serial range algorithms,
particularly regarding the name lookup.

With the adoption of [@P3136R0], function templates in the `std::ranges` namespace have been respecified as
*algorithm function objects*. These objects are defined as sets of one or more overloaded function templates,
which names designate the objects.

The parallel range algorithms we propose will extend the overload sets for the respective algorithm function objects.
The name lookup rules for such objects will apply automatically. It is covered by the wording proposed in [@P3136R0];
additional changes are not needed.

From the implementation standpoint, adding parallel versions of the range algorithms to the overload set should not be
a problem. Please see [[#possible_impl]] for more information.

## Requiring `random_access_iterator` or `random_access_range` ## {#random_access_requirement}

C++17 parallel algorithms minimally require *LegacyForwardIterator* for data sequences, but in our opinion, it is not quite
suitable for an efficient parallel implementation. Therefore for parallel range algorithms we propose to require
random access ranges and iterators.

Using parallel algorithms with forward ranges will in most cases give little to no benefit,
and may even reduce performance due to extra overheads. We believe that forward ranges and iterators are bad abstractions
for parallel data processing, and allowing those could result in wrong expectations and unsatisfactory user experience
with parallel algorithms.

Many parallel programming models that are well known and widely used in the industry, including OpenMP, OpenCL, CUDA,
SYCL, oneTBB, define iteration or data spaces for their parallel constructs in ways that allow creating sufficient
parallel work quickly and efficiently. A key property for this is the ability to split the work into smaller chunks.
These programming models allow to control the amount of work per chunk and sometimes the ways chunks are created
and/or scheduled. All these also support iteration spaces up to at least 3 dimensions.

Except for `tbb::parallel_for_each` in oneTBB which can work with forward iterators, these parallel programming models
require random access iterators or some equivalent, such as numeric indexes or pointers. This is natural,
as referring to an arbitrary point in the iteration space at constant time is the main and by far simplest way
to create parallel work. Forward iterators, on the other hand, are notoriously bad for splitting a sequence
that can only be done in linear time. Moreover, if the output of an algorithm should preserve the order of its input,
which is typical for the C++ algorithms, it requires additional synchronization or/and additional space with forward
iterators and comes almost for granted with random access ones.

These very programming models are often used as backends to implement the C++ standard parallelism. Not surprisingly,
most implementations fall back to serial processing if data sequences have no random access. Of the GNU libstdc++,
LLVM libc++, and MSVC's standard library, only the latter attempts to process forward iterator based sequences in parallel,
for which it first needs to serially iterate over a whole sequence once or even twice.
oneAPI DPC++ library (oneDPL) supports forward iterators only for a very few algorithms,
only for `par` and only in the implementation based on oneTBB.

According to the SG1/SG9 feedback we have got earlier, there seemingly are two main reasons why others do not want to restrict
parallel algorithms by only random access ranges:

- That would prevent some useful views, such as `filter_view`, from being used with parallel range algorithms.
- That would be inconsistent with the C++17 parallel algorithms.

Given the other aspects of the proposed design, we believe some degree of inconsistency with C++17 parallel algorithms
is inevitable and should not become a gating factor for important design decisions.

The question of supporting the standard views that do not provide random access is very important. We think though
that it should better be addressed through proper abstractions and new concepts defining iteration spaces, including
multidimensional ones, suitable for parallel algorithms. We intend to work on developing these (likely in another paper),
however it requires time and effort to make it right, and we think trying to squeeze that into C++26 adds significant risks.
For now, random access ranges with known bounds (see [[#require_bounded_ranges]]) is probably the best approximation
that exists in the standard. Starting from that and gradually enabling other types of iteration spaces
in a source-compatible manner seems to us better than blanket allowance of any `forward_range`.

## Taking range as the output ## {#range_as_the_output}

We propose taking a range as the output for the overloads that take ranges for input.
Similarly, we propose requiring a sentinel for the output where the input is passed as "iterator and sentinel".

The benefits of this *range-as-the-output* approach, comparing to taking a single iterator for the output, are:

- It creates a safer API where all data sequences have known bounds. Specifically, the `sized_range`
    and `sized_sentinel_for` concepts will be applied to the output sequences in the same way as to the input sequences.
- Not for all algorithms the output size is defined by the input size. An example is `copy_if` (and similar
    algorithms with *filtering* semantics), where the output sequence might be shorter than the input one.
    Knowing the expected size of the output may open opportunities for more efficient implementations.
- Passing a range for the output makes code a bit simpler in the cases typical for parallel execution.

On the joint SG1 and SG9 discussion of [@P3179R2] the audience expressed several concerns about the idea and
[requested to stay with iterators for the output](#sg1_sg9_st_louis_2024) until deeper investigation is made.

To address the concerns, we wrote a separate paper [@P3490R0] with the detailed investigation of the topic,
suggesting there a compromise solution with adding separate function template overloads for both *iterator-as-the-output*
and *range-as-the-output*. See [@P3490R0] for more details.

Eventually SG9 [accepted](#sg9_wroclaw_2024) our original proposal to use ranges for the output, without extra overloads
for legacy convenience.

## Requiring ranges to be bounded ## {#require_bounded_ranges}

One of the requirements we want to put on the parallel range algorithms is to disallow unbounded input and output.
The reasons for that are:

- For efficient parallel implementation we need to know the iteration space bounds. Otherwise, it's hard to
    apply the "divide and conquer" strategy for creating work for multiple execution threads.
- While serial range algorithms allow passing an "infinite" range like `std::ranges::views::iota(0)`,
    it may result in an endless loop. It's hard to imagine usefulness of that in the case of parallel execution.
    Requiring data sequences to be bounded potentially prevents errors at run-time.
- Using explicitly bounded output ranges follows established practices of secure coding, which recommend or even
    require to always specify the size of the output in order to prevent out-of-range data modifications.

If several provided ranges or sequences are bounded, an algorithm should stop as soon as the end is reached for the shortest one.
There are already precedents in the standard that an algorithm takes two sequences with potentially different input sizes
and chooses the smaller size as the number of iterations it is going to make, such as `std::ranges::transform`
and `std::ranges::mismatch`. For the record, `std::transform` (including the overload with execution policy) doesn't support
different input sizes, while `std::mismatch` does.

In the case of two input ranges or sequences, for a few algorithms - namely, `mismatch`, `equal`, and `transform` -
it could be sufficient for just one range to be bounded and the other assumed to have at least as many elements
as the bounded one. This enables unbounded ranges such as `views::repeat` in certain useful patterns, for example:

```cpp
void normalize_parallel(range auto&& v) {
  auto mx = reduce(execution::par, v, ranges::max{});
  transform(execution::par, v, views::repeat(mx), v.begin(), divides);
}
```

However, SG9 [decided](#sg9_wroclaw_2024) to require `sized_range` for all inputs, with the plan to relax these constraints
for `transform` once there is a way to statically detect infinite ranges like `views::repeat` (as opposed to finite unsized
ranges, such as null terminated strings).

The exposition-only concept _`random-access-sized-range`_ combines the key requirements to the types of ranges
to simplify the signatures of parallel range algorithms:

```cpp
template<class R>
concept @_random-access-sized-range_@ = @_`// exposition only`_@ 
    ranges::random_access_range<R> && ranges::sized_range<R>;
```

## Requirements for callable parameters ## {#callable_parameters}

In [@P3179R0] we proposed that parallel range algorithms should require function objects for predicates, comparators, etc.
to have `const`-qualified `operator()`, with the intent to provide compile-time diagnostics for mutable	function objects
which might be unsafe for parallel execution. We have got contradictory feedback from SG1 and SG9 on that topic:
SG1 preferred to keep the behavior consistent with C++17 parallel algorithms, while SG9 supported our design intent.

We did extra investigation and decided that requiring `const`-qualified operator at compile-time is not strictly necessary
because:

- The vast majority of the serial range algorithms requires function objects to be `regular_invocable` (or its derivatives),
    which already has the semantic requirement of not modifying either the function object or its arguments.
    While not enforced at compile-time, it seems good enough for our purpose because it demands having the same function
    object state between invocations (independently of `const` qualifier), and it is consistent with serial range algorithms.
- Remaining algorithms should be considered individually. For example, `for_each` using a mutable `operator()` is of less
    concern if the algorithm does not return the function object (see more detailed analysis below).
    For `generate`, a non-mutable callable appears to be of very limited use: in order to produce multiple values while not
    taking any arguments, a generator should typically maintain and update some state.

The following example works fine for serial code. While it compiles for parallel code, users should not assume that the
semantics remains intact. Since the parallel version of `for_each` requires function object to be copyable, it
is not guaranteed that all `for_each` iterations are processed by the same function object. Practically speaking, users
cannot rely on accumulating any state modifications in a parallel `for_each` call.


```cpp
struct callable
{
    void operator()(int& x)
    {
        ++x;
        ++i; // a data race if the callable is executed concurrently
    }
    int get_i() const {
        return i;
    }
private:
    int i = 0;
};

callable c;

// serial for_each call
auto fun = std::for_each(v.begin(), v.end(), c);

// parallel for_each call
// The callable object cannot be read because parallel for_each version purposefully returns void
std::for_each(std::execution::par, v.begin(), v.end(), c);

// for_each serial range version call
auto [_, fun] = std::ranges::for_each(v.begin(), v.end(), c);
```

We allow the same callable to be used in the proposed `std::ranges::for_each`.

```cpp
// callable is used from the previous code snippet
callable c;
// The returned iterator is ignored
std::ranges::for_each(std::execution::par, v.begin(), v.end(), c);
```

Again, even though `c` accumulates state modifications, one cannot rely on that because an algorithm implementation
is allowed to make as many copies of `c` as it wants. Of course, this can be overcome by using `std::reference_wrapper`
but that might lead to data races.

```cpp
// callable is used from the previous code snippet
// Wrapping a callable object with std::reference_wrapper compiles, but might result in data races
callable c;
std::ranges::for_each(std::execution::par, v.begin(), v.end(), std::ref(c));
```

Our conclusion is that it's user responsibility to provide such a callable that avoids data races, same as for C++17 parallel
algorithms.

## `constexpr` parallel range algorithms ## {#constexpr_support}

[@P2902R0] suggests allowing algorithms with execution policies to be used in constant expressions.
We do not consider that as a primary design goal for our work, however we will happily align with that proposal
in the future once it progresses towards adoption into the working draft.

# More examples # {#more_examples}

## Change existing code to use parallel range algorithms ## {#easy_to_switch}

One of the goals is to require a minimal amount of changes when switching from the existing API to parallel range
algorithms. However, that simplicity should not create hidden issues negatively impacting the overall user experience.
We believe that the proposal provides a good balance in that regard.

As an example, let's look at using `for_each` to apply a lambda function to all elements of a `std::vector v`.

For the serial range-based `for_each` call:

```cpp
std::ranges::for_each(v, [](auto& x) { ++x; });
```

switching to the parallel version will look like:

```cpp
std::ranges::for_each(std::execution::par, v, [](auto& x) { ++x; });
```

In this simple case, the only change is an execution policy added as the first function argument. It will also hold for
the "iterator and sentinel" overload of `std::ranges::for_each`.

The C++17 parallel `for_each` call:

```cpp
std::for_each(std::execution::par, v.begin(), v.end(), [](auto& x) { ++x; });
```

can be changed to one of the following:

```cpp
// Using iterator and sentinel
std::ranges::for_each(std::execution::par, v.begin(), v.end(), [](auto& x) { ++x; });

// Using vector as a range
std::ranges::for_each(std::execution::par, v, [](auto& x) { ++x; });
```

So, here only changing the namespace is necessary, though users might also change `v.begin(), v.end()` to just `v`.

However, for other algorithms more changes might be necessary.

## Less parallel algorithm calls and better expressiveness ## {#less_parallel_call}

Let's consider the following example:

```cpp
reverse(policy, begin(data), end(data));
transform(policy, begin(data), end(data), begin(result), [](auto i){ return i * i; });
auto res = find_if(policy, begin(result), end(result), pred);
```

It has three stages and eventually tries to answer the question if the input sequence contains an element after reversing
and transforming it. The interesting considerations are:

- Since the example has three parallel stages, it adds extra overhead for parallel computation per algorithm.
- The first two stages will complete for all elements before the `any_of` stage is started, though it is not required for
    correctness. If reverse and transformation would be done on the fly, a good implementation of `any_of` might have
    skipped the remaining work when `pred` returns `true`, thus providing more performance.

Let's make it better:

```cpp
// With fancy iterators
auto res = find_if(policy,
                  make_transform_iterator(make_reverse_iterator(end(data)),
                                          [](auto i){ return i * i; }),
                  make_transform_iterator(make_reverse_iterator(begin(data)),
                                          [](auto i){ return i * i; }),
                  pred);
```

Now there is only one parallel algorithm call, and `any_of` can skip unneeded work. However, this
variation also has interesting considerations:

- First, it doesn't compile. We use `transform iterator` to pass the transformation function,
    but the two `make_transform_iterator` expressions use two different lambdas, and
    the iterator type for `any_of` cannot be deduced because the types of `transform_iterator` do not match.
    One of the options to make it compile is to store a lambda in a variable.
- Second, it requires using a non-standard iterator.
- Third, the expressiveness of the code is not good: it is hard to read while easy to make a mistake
    like the one described in the first bullet.

Let's improve the example further with the proposed API:

```cpp
// With ranges
auto res = find_if(policy, data | views::reverse | views::transform([](auto i){ return i * i; }),
                  pred);
```

The example above lacks the drawbacks described for the previous variations:

- There is only one algorithm call;
- The implementation might skip unnecessary work;
- There is no room for the lambda type mistake;
- The readability is much better compared to the second variation and not worse than in the first one.

# Possible implementation of a parallel range algorithm # {#possible_impl}

Here we show a possible implementation of `std::ranges::for_each` with the new overloads
proposed in [[#modify_alg_foreach]]:

```cpp
// A possible implementation of std::ranges::for_each
namespace ranges
{
namespace __detail
{
struct __for_each_fn
{
    // ...
    // Existing serial overloads
    // ...

    // The overload for unsequenced and parallel policies. Requires random_access_iterator
    template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
             class Proj = identity, indirectly_unary_invocable<projected<I, Proj>> Fun>
    I operator()(Ep&& exec, I first, S last, Fun f, Proj proj = {}) const
    {
        // properly handle the execution policy;
        // for the reference, a serial implementation is provided
        for (; first != last; ++first)
        {
            std::invoke(f, std::invoke(proj, *first));
        }
        return first;
    }

    template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
             indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
    ranges::borrowed_iterator_t<R>
    operator()(Ep&& exec, R&& r, Fun f, Proj proj = {}) const
    {
        return (*this)(std::forward<Ep>(exec), std::ranges::begin(r),
                       std::ranges::end(r), f, proj);
    }
}; // struct for_each
} // namespace __detail
inline namespace __for_each_fn_namespace
{
inline constexpr __detail::__for_each_fn for_each;
} // __for_each_fn_namespace
} // namespace ranges
```

# The proposal scope # {#proposal_scope}

## In-scope ## {#in_scope}

### The counterparts of C++17 parallel algorithms in `std::ranges` namespace ### {#cpp17_counterpart}

<table>
  <tr>
    <td>`all_of`
    <td>`search{_n}`
    <td>`remove_copy`
    <td>`is_sorted`
    <td>`is_heap`
  </tr>
  <tr>
    <td>`any_of`
    <td>`copy{_n}`
    <td>`remove_copy_if`
    <td>`is_sorted_until`
    <td>`is_heap_until`
  </tr>
  <tr>
    <td>`none_of`
    <td>`copy_if`
    <td>`unique`
    <td>`nth_element`
    <td>`min_element`
  </tr>
  <tr>
    <td>`for_each{_n}`
    <td>`move`
    <td>`unique_copy`
    <td>`is_partitioned`
    <td>`max_element`
  </tr>
  <tr>
    <td>`find`
    <td>`swap_ranges`
    <td>`reverse`
    <td>`partition`
    <td>`minmax_element`
  </tr>
  <tr>
    <td>`find_if`
    <td>`transform`
    <td>`reverse_copy`
    <td>`stable_partition`
    <td>`lexicographical_compare`
  </tr>
  <tr>
    <td>`find_if_not`
    <td>`replace`
    <td>`rotate`
    <td>`partition_copy`
    <td>`uninitialized_default_construct{_n}`
  </tr>
  <tr>
    <td>`find_end`
    <td>`replace_if`
    <td>`rotate_copy`
    <td>`merge`
    <td>`uninitialized_value_construct{_n}`
  </tr>
  <tr>
    <td>`find_first_of`
    <td>`replace_copy`
    <td>`shift_left`
    <td>`inplace_merge`
    <td>`uninitialized_copy{_n}`
  </tr>
  <tr>
    <td>`adjacent_find`
    <td>`replace_copy_if`
    <td>`shift_right`
    <td>`includes`
    <td>`uninitialized_move{_n}`
  </tr>
  <tr>
    <td>`count`
    <td>`fill{_n}`
    <td>`sort`
    <td>`set_union`
    <td>`uninitialized_fill{_n}`
  </tr>
  <tr>
    <td>`count_if`
    <td>`generate{_n}`
    <td>`stable_sort`
    <td>`set_intersection`
    <td>`destroy{_n}`
  </tr>
  <tr>
    <td>`mismatch`
    <td>`remove`
    <td>`partial_sort`
    <td>`set_difference`
    <td>
  </tr>
  <tr>
    <td>`equal`
    <td>`remove_if`
    <td>`partial_sort_copy`
    <td>`set_symmetric_difference`
    <td>
  </tr>
</table>

### Algorithms in `std::ranges` namespace only ### {#only_in_std_ranges}

The algorithms below are easy to add because they are either expressible via existing parallel algorithms or
an analogue with very close semantics exists:

<table>
  <tr>
    <th>`std::ranges` algorithms to add
    <th>`std` algorithms used as the guidance
  </tr>
  <tr>
    <td>`contains`
    <td>`find`
  </tr>
  <tr>
    <td>`contains_subrange`
    <td>`search`
  </tr>
  <tr>
    <td>`find_last`
    <td>`find`
  </tr>
  <tr>
    <td>`find_last_if`
    <td>`find_if`
  </tr>
  <tr>
    <td>`find_last_if_not`
    <td>`find_if_not`
  </tr>
  <tr>
    <td>`starts_with`
    <td>`mismatch`
  </tr>
  <tr>
    <td>`ends_with`
    <td>`equal`
  </tr>
  <tr>
    <td>`min`
    <td>`min_element`
  </tr>
  <tr>
    <td>`max`
    <td>`max_element`
  </tr>
  <tr>
    <td>`minmax`
    <td>`minmax_element`
  </tr>
</table>

## Out-of-scope ## {#out_of_scope}

### The counterparts of exiting algorithms without `ExecutionPolicy` ### {#without_exec_policy_counterpart}

Below we list the algorithms below without `ExecutionPolicy` in C++17 and where `ExecutionPolicy` parameter doesn't seem
to add value:

- `push_heap`
- `pop_heap`
- `sort_heap`
- `next_permutation`
- `prev_permutation`
- `lower_bound`
- `upper_bound`
- `equal_range`
- `binary_search`
- `partition_point`

Below we list the algorithms below without `ExecutionPolicy` in C++17, where `ExecutionPolicy` parameter might make sense
but requires deeper investigation:

- `iota`
- `make_heap`
- `is_permutation`
- `copy_backward`
- `move_backward`
- `sample` (RNG specific)
- `shuffle` (RNG specific)

Below we list `std::ranges` only algorithms where we don't add the `ExecutionPolicy` parameter:

- `fold_left`
- `fold_left_first`
- `fold_right`
- `fold_right_last`
- `fold_left_with_iter`
- `fold_left_first_with_iter`
- `generate_random` (RNG specific, `ExecutionPolicy` parameter was rejected during [@P1068R11] review)

### Absence of some serial range-based algorithms ### {#serial_range_based_absence}

We understand that some useful algorithms do not yet exist in `std::ranges`, for example, most of generalized numeric
operations [numeric.ops]{- .sref}. The goal of this paper is however limited to
adding overloads with `ExecutionPolicy`  to the existing algorithms in the `std::ranges` namespace. Any follow-up paper
that adds `<numeric>` algorithms to `std::ranges` should also consider adding dedicated overloads with `ExecutionPolicy`.

# Implementation experience # {#impl_exp}

The oneAPI DPC++ Library (oneDPL) [developer guide](https://oneapi-src.github.io/oneDPL/parallel_api/parallel_range_algorithms.html)
covers parallel range algorithms we’ve implemented so far. The oneAPI specification provides
[formal signatures](https://github.com/uxlfoundation/oneAPI-spec/blob/main/source/elements/oneDPL/source/parallel_api/parallel_range_api.rst)
of these algorithms. The implementation supports execution policies for CPUs (semantically aligned with the C++ standard)
and for SYCL devices, and it works with a subset of the standard C++ views.

We use the range-as-the-output approach where applicable: in `transform`, `copy`, `copy_if`, and `merge`.

We don't foresee any issues with implementability for the rest of the proposed parallel algorithms because all of them were
already implemented in C++17 and new APIs that we propose are expressible via the existing ones.

# Further work # {#further_work}

## Issues to address ## {#issues_to_address}

Having known bugs and feedback from SG1 and SG9, the plan of work prior to the next committee F2F meeting in
Austria, 2025 is the following:

- Update [algorithm.syn]{- .sref}.
- Consider adding the algorithm descriptions to the wording, even if no changes are made.
- ~~Add random-access-sized-range as an exposition-only concept~~
- ~~Use the old feature testing macro~~
- ~~Shorten the exec policy parameter + italicize the exposition only context~~
- Clarify that views can be copied by parallel algorithms
- The thread safety rules for `begin()/end()` should be like for element access function
- Add testing experience of thread safe access to the views
- ~~Add short descriptions of the new exposition-only concepts to the design overview.~~
- Extend [algorithms.parallel.defns]{- .sref} to also refer to algorithm function objects (requires [@P3136R0]), and maybe Mention "ranges" next to iterators etc.

## LWG questions ## {#lwg_questions}

- C++17 `<memory>` Parallel Algorithms exist in the `<memory>` synopsis only. Should it be fixed?
- namespace `ranges` is used (or not used) inconsistently, in our opinion. Need an advice.
- `ExecutionPolicy` function parameter is named `exec` everywhere, except two places where the name is `policy`. Should it be fixed?
- `starts_with`, `ends_with` misses dot at the end of _Returns_. It should be fixed, right?
- `find_last` doesn't have `T = projected_value`... in the synopsis. It must be a bug.

## Thread-safe views examination ## {#thread_safe_views}

We need to understand better whether using some `views` with parallel algorithms might result in data races.
While some investigation was done by other authors in [@P3159R0], it's mostly not about the data races but about
ability to parallelize processing of data represented by various views.

We need to invest more time to understand the implications of sharing a state between `view` and `iterator` on the possibility
of data races. One example is `transform_view`, where iterators keep pointers to the function object that is stored
in the view itself.

Here are questions we want to answer (potentially not a complete list):

- Do users have enough control to guarantee absence of data races for such views?
- Are races not possible because of implementation strategy chosen by standard libraries?
- Do we need to add extra requirements towards thread safety to the standard views?

# Formal wording # {#formal_wording}

## Modify the `__cpp_lib_parallel_algorithm` macro in [version.syn]{- .sref} ## {#modify_version_syn}

```diff
- #define __cpp_lib_parallel_algorithm                201603L // also in <algorithm>, <numeric>
+ #define __cpp_lib_parallel_algorithm                20XXXXL // also in <algorithm>, <numeric>, <memory>
```

## Modify [ranges.syn]{- .sref} ## {#modify_ranges_syn}

```diff
  template<class T>
    concept constant_range = @_see below_@;                                             @_`// freestanding`_@
+
+  template<class R>
+    concept @_random-access-sized-range_@ = @_see below_@    @_// exposition only_@
```

## Add an exposition-only concept to [range.refinements]{- .sref} ## {#modify_range_refinements}

[7]{.pnum} The `constant_range` concept specifies the requirements of a `range` type whose elements are not modifiable.

```cpp
template<class T>
  concept constant_range =
    input_range<T> && constant-iterator<iterator_t<T>>;
```

::: add
[X]{.pnum} The exposition-only _`random-access-sized-range`_ concept specifies the requirements of a range type
that is sized and allows random access to its elements.

[*Note X*: This concept constraints some parallel algorithm overloads; see [algorithms]. — *end note*]

```cpp
  template<class R>
    concept @_random-access-sized-range_@ =     @_// exposition only_@
      random_access_range<R> && sized_range<R>;
```
:::

## Modify [algorithms.parallel.defns]{- .sref} ## {#modify_alg_parallel_def}

[2]{.pnum} A *parallel algorithm* is a function template listed in this [document]{.rm}[Clause]{.add} with
a[n *execution policy* ([execpol]{- .sref})]{.add} template parameter named `ExecutionPolicy` [or `@_execution-policy_@ Ep`]{.add}.

[3]{.pnum} Parallel algorithms access objects indirectly accessible via their arguments by invoking the following functions:

- All operations of the categories of the iterators[, sentinels]{.add} or mdspan types that the algorithm is instantiated with.
- Operations on those sequence elements that are required by its specification.
- User-provided [function]{.rm}[invocable]{.add} objects to be applied during the execution of the algorithm, if required by the specification.
- Operations on those [function]{.rm}[invocable]{.add} objects required by the specification.

## Modify [algorithms.parallel.user]{- .sref} ## {#modify_alg_parallel_user}

[1]{.pnum} Unless otherwise specified, [function]{.rm}[invocable]{.add} objects passed into parallel algorithms as objects of type
`Predicate`, `BinaryPredicate`, `Compare`, `UnaryOperation`, `BinaryOperation`, `BinaryOperation1`, `BinaryOperation2`, `BinaryDivideOp`,
[`Proj`]{.add} and the operators used by the analogous overloads to these parallel algorithms that are formed by an invocation
with the specified default predicate or operation (where applicable) shall not directly or indirectly modify objects via their arguments,
nor shall they rely on the identity of the provided objects.

## Modify [algorithms.parallel.exec]{- .sref} ## {#modify_alg_parallel_exec}

[1]{.pnum} Parallel algorithms have template parameters named `ExecutionPolicy` [or `@_execution-policy_@ Ep`]{.add} ([execpol]{- .sref})
which describe the manner in which the execution of these algorithms may be parallelized and the manner in which
they apply the element access functions.

## Modify [algorithms.parallel.exceptions]{- .sref} ## {#modify_alg_parallel_exceptions}

[2]{.pnum} During the execution of a parallel algorithm, if the invocation of an element access function exits
via an uncaught exception, the behavior is determined by the [`ExecutionPolicy`]{.rm}[execution policy]{.add}.

## Modify [algorithms.parallel.overloads]{- .sref} ## {#modify_alg_parallel_overloads}

[1]{.pnum} Parallel algorithms are algorithm overloads. Each parallel algorithm overload has an additional template
type parameter named `ExecutionPolicy` [or `@_execution-policy_@ Ep`]{.add}, which is the first template parameter.
Additionally, each parallel algorithm overload has an additional function parameter of type `ExecutionPolicy&&`
[or `Ep&&`]{.add}, which is the first function parameter.

[*Note 1*: Not all algorithms have parallel algorithm overloads. — *end note*]

[2]{.pnum} Unless otherwise specified, the semantics of [`ExecutionPolicy`]{.rm} algorithm overloads
[with an execution policy]{.add} are identical to their overloads without.

[3]{.pnum} Unless otherwise specified, the complexity requirements of [`ExecutionPolicy`]{.rm} algorithm overloads
[with an execution policy]{.add} are relaxed from the complexity requirements of the overloads without as follows:
...

[4]{.pnum} Parallel algorithms shall not participate in overload resolution unless
`is_execution_policy_v<remove_cvref_t<ExecutionPolicy>>` is `true`.
[Parallel algorithms in the `std::ranges` namespace are constrained with the following exposition-only concept:]{.add}

::: add
```cpp
template<class Ep>
concept @_execution-policy_@ = @_// exposition only_@
  is_execution_policy_v<remove_cvref_t<Ep>>;
```
:::

## Modify [algorithm.syn]{- .sref} ## {#modify_alg_syn}

```diff
namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr bool all_of(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool all_of(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+          indirect_unary_predicate<projected<I, Proj>> Pred>
+    bool all_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+          indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    bool all_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr bool any_of(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool any_of(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+          indirect_unary_predicate<projected<I, Proj>> Pred>
+    bool any_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+          indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    bool any_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr bool none_of(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool none_of(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+          indirect_unary_predicate<projected<I, Proj>> Pred>
+    bool none_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+          indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    bool none_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr bool contains(I first, S last, const T& value, Proj proj = {});
  template<input_range R, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires
      indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
    constexpr bool contains(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+           class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    bool contains(Ep&& exec, I first, S last, const T& value, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+            class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    bool contains(Ep&& exec, R&& r, const T& value, Proj proj = {});

  template<forward_iterator I1, sentinel_for<I1> S1,
            forward_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                      Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<forward_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool contains_subrange(R1&& r1, R2&& r2,
                                      Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+          random_access_iterator I2, sized_sentinel_for<I2> S2,
+          class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    bool contains_subrange(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                            Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
+          class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    bool contains_subrange(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
+                            Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<class I, class F>
    using for_each_result = in_fun_result<I, F>;

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirectly_unary_invocable<projected<I, Proj>> Fun>
    constexpr for_each_result<I, Fun>
      for_each(I first, S last, Fun f, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
    constexpr for_each_result<borrowed_iterator_t<R>, Fun>
      for_each(R&& r, Fun f, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+          indirectly_unary_invocable<projected<I, Proj>> Fun>
+    I for_each(Ep&& exec, I first, S last, Fun f, Proj proj = {});
+
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+          indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
+    borrowed_iterator_t<R>
+      for_each(Ep&& exec, R&& r, Fun f, Proj proj = {});
}

namespace ranges {
  template<class I, class F>
    using for_each_n_result = in_fun_result<I, F>;

  template<input_iterator I, class Proj = identity,
            indirectly_unary_invocable<projected<I, Proj>> Fun>
    constexpr for_each_n_result<I, Fun>
      for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, class Proj = identity,
+          indirectly_unary_invocable<projected<I, Proj>> Fun>
+    I for_each_n(Ep&& exec, I first, iter_difference_t<I> n, Fun f, Proj proj = {});
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr I find(I first, S last, const T& value, Proj proj = {});
  template<input_range R, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T*>
    constexpr borrowed_iterator_t<R>
      find(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    I find(Ep&& exec, I first, S last, const T& value, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R,
+            class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    borrowed_iterator_t<R> find(Ep&& exec, R&& r, const T& value, Proj proj = {});

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_iterator_t<R>
      find_if(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    I find_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    borrowed_iterator_t<R> find_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_iterator_t<R>
      find_if_not(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    I find_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    borrowed_iterator_t<R> find_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class T, class Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr subrange<I> find_last(I first, S last, const T& value, Proj proj = {});
  template<forward_range R, class T, class Proj = identity>
    requires
      indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
    constexpr borrowed_subrange_t<R> find_last(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    subrange<I> find_last(Ep&& exec, I first, S last, const T& value, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+            class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    borrowed_subrange_t<R> find_last(Ep&& exec, R&& r, const T& value, Proj proj = {});

  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr subrange<I> find_last_if(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_subrange_t<R> find_last_if(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+           indirect_unary_predicate<projected<I, Proj>> Pred>
+    subrange<I> find_last_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+           indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    borrowed_subrange_t<R> find_last_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});

  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr subrange<I> find_last_if_not(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_subrange_t<R> find_last_if_not(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    subrange<I> find_last_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    borrowed_subrange_t<R> find_last_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr subrange<I1>
      find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<forward_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr borrowed_subrange_t<R1>
      find_end(R1&& r1, R2&& r2, Pred pred = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1, random_access_iterator I2,
+           sized_sentinel_for<I2> S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    subrange<I1> find_end(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    borrowed_subrange_t<R1> find_end(Ep&& exec, R1&& r1, R2&& r2,
+                                      Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<input_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr borrowed_iterator_t<R1>
      find_first_of(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    I1 find_first_of(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                      Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    borrowed_iterator_t<R1> find_first_of(Ep&& exec, R1&& r1, R2&& r2,
+                                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_binary_predicate<projected<I, Proj>,
                                      projected<I, Proj>> Pred = ranges::equal_to>
    constexpr I adjacent_find(I first, S last, Pred pred = {},
                              Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_binary_predicate<projected<iterator_t<R>, Proj>,
                                      projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
    constexpr borrowed_iterator_t<R>
      adjacent_find(R&& r, Pred pred = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_binary_predicate<projected<I, Proj>, projected<I, Proj>> Pred = ranges::equal_to>
+    I adjacent_find(Ep&& exec, I first, S last, Pred pred = {}, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+            indirect_binary_predicate<projected<iterator_t<R>, Proj>, projected<iterator_t<R>, Proj>> Pred
+             = ranges::equal_to>
+    borrowed_iterator_t<R> adjacent_find(Ep&& exec, R&& r, Pred pred = {}, Proj proj = {});
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr iter_difference_t<I>
      count(I first, S last, const T& value, Proj proj = {});
  template<input_range R, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T*>
    constexpr range_difference_t<R>
      count(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    iter_difference_t<I> count(Ep&& exec, I first, S last, const T& value, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+            class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    range_difference_t<R> count(Ep&& exec, R&& r, const T& value, Proj proj = {});

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr iter_difference_t<I>
      count_if(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr range_difference_t<R>
      count_if(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    iter_difference_t<I> count_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    range_difference_t<R> count_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<class I1, class I2>
    using mismatch_result = in_in_result<I1, I2>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr mismatch_result<I1, I2>
      mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
      mismatch(R1&& r1, R2&& r2, Pred pred = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    mismatch_result<I1, I2>
+      mismatch(Ep&& exec, I1 first1, S1 last1, I2 first2,S2 last2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
+      mismatch(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                          Pred pred = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool equal(R1&& r1, R2&& r2, Pred pred = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    bool equal(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, class Pred = ranges::equal_to,
+            class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    bool equal(Ep&& exec, R1&& r1, R2&& r2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
            sentinel_for<I2> S2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr subrange<I1>
      search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
              Proj1 proj1 = {}, Proj2 proj2 = {});
  template<forward_range R1, forward_range R2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr borrowed_subrange_t<R1>
      search(R1&& r1, R2&& r2, Pred pred = {},
              Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+      subrange<I1>
+        search(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+      borrowed_subrange_t<R1>
+        search(Ep&& exec, R1&& r1, R2&& r2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S,
            class Pred = ranges::equal_to, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirectly_comparable<I, const T*, Pred, Proj>
    constexpr subrange<I>
      search_n(I first, S last, iter_difference_t<I> count,
                const T& value, Pred pred = {}, Proj proj = {});
  template<forward_range R, class Pred = ranges::equal_to,
            class Proj = identity, class T = projected_value_t<I, Proj>>
    requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
    constexpr borrowed_subrange_t<R>
      search_n(R&& r, range_difference_t<R> count,
                const T& value, Pred pred = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Pred = ranges::equal_to, class Proj = identity,
+            class T = projected_value_t<I, Proj>>
+    requires indirectly_comparable<I, const T*, Pred, Proj>
+      subrange<I>
+        search_n(Ep&& exec, I first, S last, iter_difference_t<I> count,
+                  const T& value, Pred pred = {}, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Pred = ranges::equal_to,
+            class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
+      borrowed_subrange_t<R>
+        search_n(Ep&& exec, R&& r, range_difference_t<R> count,
+                  const T& value, Pred pred = {}, Proj proj = {});
}

namespace ranges {
  // [alg.starts.with], starts with
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool starts_with(R1&& r1, R2&& r2, Pred pred = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    bool starts_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                              Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    bool starts_with(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

  // [alg.ends.with], ends with
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires (forward_iterator<I1> || sized_sentinel_for<S1, I1>) &&
              (forward_iterator<I2> || sized_sentinel_for<S2, I2>) &&
              indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires (forward_range<R1> || sized_range<R1>) &&
              (forward_range<R2> || sized_range<R2>) &&
              indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool ends_with(R1&& r1, R2&& r2, Pred pred = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    bool ends_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                    Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    bool ends_with(Ep&& exec, R1&& r1, R2&& r2,
+                    Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<class I, class O>
    using copy_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr copy_result<I, O>
      copy(I first, S last, O result);
  template<input_range R, weakly_incrementable O>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr copy_result<borrowed_iterator_t<R>, O>
      copy(R&& r, O result);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>
+    requires indirectly_copyable<I, O>
+    copy_result<I, O> copy(Ep&& exec, I first, S last, O result, OutS result_last);
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
+    copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      copy(Ep&& exec, R&& r, OutR&& result);
}

namespace ranges {
  template<class I, class O>
    using copy_n_result = in_out_result<I, O>;

  template<input_iterator I, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr copy_n_result<I, O>
      copy_n(I first, iter_difference_t<I> n, O result);

+  template<@_execution-policy_@ Ep, random_access_iterator I, random_access_iterator O>
+    requires indirectly_copyable<I, O>
+    copy_n_result<I, O>
+      copy_n(Ep&& exec, I first, iter_difference_t<I> n, O result);
}

namespace ranges {
  template<class I, class O>
    using copy_if_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_copyable<I, O>
    constexpr copy_if_result<I, O>
      copy_if(I first, S last, O result, Pred pred, Proj proj = {});
  template<input_range R, weakly_incrementable O, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr copy_if_result<borrowed_iterator_t<R>, O>
      copy_if(R&& r, O result, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS,
+            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    requires indirectly_copyable<I, O>
+    copy_if_result<I, O>
+      copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
+               Pred pred, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, random_access_iterator OutR,
+            class Proj = identity, indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
+    copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      copy_if(Ep&& exec, R&& r, OutR&& result, Pred pred, Proj proj = {});
}

namespace ranges {
  template<class I, class O>
    using move_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_movable<I, O>
    constexpr move_result<I, O>
      move(I first, S last, O result);
  template<input_range R, weakly_incrementable O>
    requires indirectly_movable<iterator_t<R>, O>
    constexpr move_result<borrowed_iterator_t<R>, O>
      move(R&& r, O result);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>
+    requires indirectly_movable<I, O>
+    move_result<I, O> move(Ep&& exec, I first, S last, O result, OutS result_last);
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR>
+    requires indirectly_movable<iterator_t<R>, iterator_t<OutR>>
+    move_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      move(Ep&& exec, R&& r, OutR&& result);
}

namespace ranges {
  template<class I1, class I2>
    using swap_ranges_result = in_in_result<I1, I2>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2>
    requires indirectly_swappable<I1, I2>
    constexpr swap_ranges_result<I1, I2>
      swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
  template<input_range R1, input_range R2>
    requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
    constexpr swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
      swap_ranges(R1&& r1, R2&& r2);

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2>
+    requires indirectly_swappable<I1, I2>
+    swap_ranges_result<I1, I2>
+      swap_ranges(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2);
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2>
+    requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
+    swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
+      swap_ranges(Ep&& exec, R1&& r1, R2&& r2);
}

namespace ranges {
  template<class I, class O>
    using unary_transform_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
            copy_constructible F, class Proj = identity>
    requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
    constexpr unary_transform_result<I, O>
      transform(I first1, S last1, O result, F op, Proj proj = {});
  template<input_range R, weakly_incrementable O, copy_constructible F,
            class Proj = identity>
    requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
    constexpr unary_transform_result<borrowed_iterator_t<R>, O>
      transform(R&& r, O result, F op, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS,
+            copy_constructible F, class Proj = identity>
+    requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
+    unary_transform_result<I, O>
+      transform(Ep&& exec, I first, S last, O result, OutS result_last,
+                 F op, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR,
+           copy_constructible F, class Proj = identity>
+    requires indirectly_writable<iterator_t<OutR>, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
+    unary_transform_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      transform(Ep&& exec, R&& r, OutR&& result, F op, Proj proj = {});

  template<class I1, class I2, class O>
    using binary_transform_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, copy_constructible F, class Proj1 = identity,
            class Proj2 = identity>
    requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
                                            projected<I2, Proj2>>>
    constexpr binary_transform_result<I1, I2, O>
      transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            copy_constructible F, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
                                            projected<iterator_t<R2>, Proj2>>>
    constexpr binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
      transform(R1&& r1, R2&& r2, O result,
                F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            random_access_iterator O,  sized_sentinel_for<O> OutS,
+            copy_constructible F, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>, projected<I2, Proj2>>>
+    binary_transform_result<I1, I2, O>
+      transform(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, O result,
+                 OutS result_last, F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
+  template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
+            @_random-access-sized-range_@ OutR, copy_constructible F, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_writable<iterator_t<OutR>,
+               indirect_result_t<F&, projected<iterator_t<R1>, Proj1>, projected<iterator_t<R2>, Proj2>>>
+    binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
+      transform(Ep&& exec, R1&& r1, R2&& r2, OutR&& result,
+                 F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T1 = projected_value_t<I, Proj>, class T2 = T1>
    requires indirectly_writable<I, const T2&> &&
              indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
    constexpr I
      replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
  template<input_range R, class Proj = identity,
            class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
    requires indirectly_writable<iterator_t<R>, const T2&> &&
              indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T1*>
    constexpr borrowed_iterator_t<R>
      replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_writable<I, const T&>
    constexpr I replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
  template<input_range R, class Proj = identity, class T = projected_value_t<I, Proj>,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_writable<iterator_t<R>, const T&>
    constexpr borrowed_iterator_t<R>
      replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});
}

namespace ranges {
  template<class I, class O>
    using replace_copy_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, class O,
            class Proj = identity,
            class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
    requires indirectly_copyable<I, O> &&
              indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
              output_iterator<O, const T2&>
    constexpr replace_copy_result<I, O>
      replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                    Proj proj = {});
  template<input_range R, class O, class Proj = identity,
            class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = iter_value_t<O>>
    requires indirectly_copyable<iterator_t<R>, O> &&
              indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T1*> &&
              output_iterator<O, const T2&>
    constexpr replace_copy_result<borrowed_iterator_t<R>, O>
      replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                    Proj proj = {});

  template<class I, class O>
    using replace_copy_if_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, class O, class T = iter_value_t<O>
            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_copyable<I, O> && output_iterator<O, const T&>
    constexpr replace_copy_if_result<I, O>
      replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                      Proj proj = {});
  template<input_range R, class O, class T = iter_value_t<O>, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_copyable<iterator_t<R>, O> && output_iterator<O, const T&>
    constexpr replace_copy_if_result<borrowed_iterator_t<R>, O>
      replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                      Proj proj = {});
}

namespace ranges {
  template<class O, sentinel_for<O> S, class T = iter_value_t<O>>
    requires output_iterator<O, const T&>
    constexpr O fill(O first, S last, const T& value);
  template<class R, class T = range_value_t<R>>
    requires output_range<R, const T&>
    constexpr borrowed_iterator_t<R> fill(R&& r, const T& value);
  template<class O, class T = iter_value_t<O>>
    requires output_iterator<O, const T&>
    constexpr O fill_n(O first, iter_difference_t<O> n, const T& value);
}

namespace ranges {
  template<input_or_output_iterator O, sentinel_for<O> S, copy_constructible F>
    requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
    constexpr O generate(O first, S last, F gen);
  template<class R, copy_constructible F>
    requires invocable<F&> && output_range<R, invoke_result_t<F&>>
    constexpr borrowed_iterator_t<R> generate(R&& r, F gen);
  template<input_or_output_iterator O, copy_constructible F>
    requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
    constexpr O generate_n(O first, iter_difference_t<O> n, F gen);
}

namespace ranges {
  template<permutable I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr subrange<I> remove(I first, S last, const T& value, Proj proj = {});
  template<forward_range R, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires permutable<iterator_t<R>> &&
              indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T*>
    constexpr borrowed_subrange_t<R>
      remove(R&& r, const T& value, Proj proj = {});
  template<permutable I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr subrange<I> remove_if(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R>
      remove_if(R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<class I, class O>
    using remove_copy_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
            class Proj = identity, class T = projected_value_t<I, Proj>>
    requires indirectly_copyable<I, O> &&
              indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr remove_copy_result<I, O>
      remove_copy(I first, S last, O result, const T& value, Proj proj = {});
  template<input_range R, weakly_incrementable O, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires indirectly_copyable<iterator_t<R>, O> &&
              indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T*>
    constexpr remove_copy_result<borrowed_iterator_t<R>, O>
      remove_copy(R&& r, O result, const T& value, Proj proj = {});

  template<class I, class O>
    using remove_copy_if_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_copyable<I, O>
    constexpr remove_copy_if_result<I, O>
      remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
  template<input_range R, weakly_incrementable O, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr remove_copy_if_result<borrowed_iterator_t<R>, O>
      remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
}

namespace ranges {
  template<permutable I, sentinel_for<I> S, class Proj = identity,
            indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
    constexpr subrange<I> unique(I first, S last, C comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R>
      unique(R&& r, C comp = {}, Proj proj = {});
}

namespace ranges {
  template<class I, class O>
    using unique_copy_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
            indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
    requires indirectly_copyable<I, O> &&
              (forward_iterator<I> ||
              (input_iterator<O> && same_as<iter_value_t<I>, iter_value_t<O>>) ||
              indirectly_copyable_storable<I, O>)
    constexpr unique_copy_result<I, O>
      unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
  template<input_range R, weakly_incrementable O, class Proj = identity,
            indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
    requires indirectly_copyable<iterator_t<R>, O> &&
              (forward_iterator<iterator_t<R>> ||
              (input_iterator<O> && same_as<range_value_t<R>, iter_value_t<O>>) ||
              indirectly_copyable_storable<iterator_t<R>, O>)
    constexpr unique_copy_result<borrowed_iterator_t<R>, O>
      unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
}

namespace ranges {
  template<bidirectional_iterator I, sentinel_for<I> S>
    requires permutable<I>
    constexpr I reverse(I first, S last);
  template<bidirectional_range R>
    requires permutable<iterator_t<R>>
    constexpr borrowed_iterator_t<R> reverse(R&& r);
}

namespace ranges {
  template<class I, class O>
    using reverse_copy_result = in_out_result<I, O>;

  template<bidirectional_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr reverse_copy_result<I, O>
      reverse_copy(I first, S last, O result);
  template<bidirectional_range R, weakly_incrementable O>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr reverse_copy_result<borrowed_iterator_t<R>, O>
      reverse_copy(R&& r, O result);
}

namespace ranges {
  template<permutable I, sentinel_for<I> S>
    constexpr subrange<I> rotate(I first, I middle, S last);
  template<forward_range R>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R> rotate(R&& r, iterator_t<R> middle);
}

namespace ranges {
  template<class I, class O>
    using rotate_copy_result = in_out_result<I, O>;

  template<forward_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr rotate_copy_result<I, O>
      rotate_copy(I first, I middle, S last, O result);
  template<forward_range R, weakly_incrementable O>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr rotate_copy_result<borrowed_iterator_t<R>, O>
      rotate_copy(R&& r, iterator_t<R> middle, O result);
}

namespace ranges {
  template<permutable I, sentinel_for<I> S>
    constexpr subrange<I> shift_left(I first, S last, iter_difference_t<I> n);
  template<forward_range R>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R> shift_left(R&& r, range_difference_t<R> n);
}

namespace ranges {
  template<permutable I, sentinel_for<I> S>
    constexpr subrange<I> shift_right(I first, S last, iter_difference_t<I> n);
  template<forward_range R>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R> shift_right(R&& r, range_difference_t<R> n);
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I
      sort(I first, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      sort(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      stable_sort(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I
      partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      partial_sort(R&& r, iterator_t<R> middle, Comp comp = {},
                    Proj proj = {});
}

namespace ranges {
  template<class I, class O>
    using partial_sort_copy_result = in_out_result<I, O>;

  template<input_iterator I1, sentinel_for<I1> S1,
            random_access_iterator I2, sentinel_for<I2> S2,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
              indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
    constexpr partial_sort_copy_result<I1, I2>
      partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, random_access_range R2, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
              sortable<iterator_t<R2>, Comp, Proj2> &&
              indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
                                        projected<iterator_t<R2>, Proj2>>
    constexpr partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
      partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
                        Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr bool is_sorted(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr borrowed_iterator_t<R>
      is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I
      nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool is_partitioned(R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<permutable I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr subrange<I>
      partition(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R>
      partition(R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<bidirectional_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    requires permutable<I>
    constexpr subrange<I> stable_partition(I first, S last, Pred pred, Proj proj = {});
  template<bidirectional_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R> stable_partition(R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<class I, class O1, class O2>
    using partition_copy_result = in_out_out_result<I, O1, O2>;

  template<input_iterator I, sentinel_for<I> S,
            weakly_incrementable O1, weakly_incrementable O2,
            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
    constexpr partition_copy_result<I, O1, O2>
      partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                      Proj proj = {});
  template<input_range R, weakly_incrementable O1, weakly_incrementable O2,
            class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_copyable<iterator_t<R>, O1> &&
              indirectly_copyable<iterator_t<R>, O2>
    constexpr partition_copy_result<borrowed_iterator_t<R>, O1, O2>
      partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_iterator_t<R>
      partition_point(R&& r, Pred pred, Proj proj = {});
}

namespace ranges {
  template<class I1, class I2, class O>
    using merge_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,
            class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr merge_result<I1, I2, O>
      merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
            Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
      merge(R1&& r1, R2&& r2, O result,
            Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
  template<bidirectional_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {},
                    Proj proj = {});
}

namespace ranges {
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Proj1 = identity, class Proj2 = identity,
            indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
              ranges::less>
    constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                            Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Proj1 = identity,
            class Proj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
    constexpr bool includes(R1&& r1, R2&& r2, Comp comp = {},
                            Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<class I1, class I2, class O>
    using set_union_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_union_result<I1, I2, O>
      set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
      set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<class I1, class I2, class O>
    using set_intersection_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_intersection_result<I1, I2, O>
      set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
      set_intersection(R1&& r1, R2&& r2, O result,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<class I, class O>
    using set_difference_result = in_out_result<I, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_difference_result<I1, O>
      set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_difference_result<borrowed_iterator_t<R1>, O>
      set_difference(R1&& r1, R2&& r2, O result,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<class I1, class I2, class O>
    using set_symmetric_difference_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_symmetric_difference_result<I1, I2, O>
      set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                Comp comp = {}, Proj1 proj1 = {},
                                Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_symmetric_difference_result<borrowed_iterator_t<R1>,
                                              borrowed_iterator_t<R2>, O>
      set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr bool is_heap(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr borrowed_iterator_t<R>
      is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<class T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr const T& min(const T& a, const T& b, Comp comp = {}, Proj proj = {});
  template<copyable T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr T min(initializer_list<T> r, Comp comp = {}, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
    constexpr range_value_t<R>
      min(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<class T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr const T& max(const T& a, const T& b, Comp comp = {}, Proj proj = {});
  template<copyable T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr T max(initializer_list<T> r, Comp comp = {}, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
    constexpr range_value_t<R>
      max(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<class T>
    using minmax_result = min_max_result<T>;

  template<class T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr minmax_result<const T&>
      minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {});
  template<copyable T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr minmax_result<T>
      minmax(initializer_list<T> r, Comp comp = {}, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
    constexpr minmax_result<range_value_t<R>>
      minmax(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr borrowed_iterator_t<R>
      min_element(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr borrowed_iterator_t<R>
      max_element(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<class I>
    using minmax_element_result = min_max_result<I>;

  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr minmax_element_result<I>
      minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr minmax_element_result<borrowed_iterator_t<R>>
      minmax_element(R&& r, Comp comp = {}, Proj proj = {});
}

namespace ranges {
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Proj1 = identity, class Proj2 = identity,
            indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
              ranges::less>
    constexpr bool
      lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Proj1 = identity,
            class Proj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
    constexpr bool
      lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
}
```

## Modify `all_of` in [alg.all.of]{- .sref} ## {#modify_alg_all_of}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr bool ranges::all_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::all_of(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  bool ranges::all_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  bool ranges::all_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

## Modify `any_of` in [alg.any.of]{- .sref} ## {#modify_alg_any_of}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr bool ranges::any_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::any_of(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  bool ranges::any_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  bool ranges::any_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

## Modify `none_of` in [alg.none.of]{- .sref} ## {#modify_alg_none_of}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr bool ranges::none_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::none_of(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  bool ranges::none_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  bool ranges::none_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

## Modify `contains` in [alg.contains]{- .sref} ## {#modify_alg_contains}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr bool ranges::contains(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr bool ranges::contains(R&& r, const T& value, Proj proj = {});
```

*Returns*: `ranges​::​find(std​::​move(first), last, value, proj) != last.`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  bool ranges::contains(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  bool ranges::contains(Ep&& exec, R&& r, const T& value, Proj proj = {});
```

*Returns*: `ranges​::​find(std::forward<Ep>(exec), std​::​move(first), last, value, proj) != last.`
:::

```cpp
template<forward_iterator I1, sentinel_for<I1> S1,
         forward_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::contains_subrange(R1&& r1, R2&& r2, Pred pred = {},
                                           Proj1 proj1 = {}, Proj2 proj2 = {});
```

*Returns*: `first2 == last2 || !ranges​::​search(first1, last1, first2, last2, pred, proj1, proj2).empty().`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  bool ranges::contains_subrange(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                                 Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  bool ranges::contains_subrange(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
```

*Returns*: `first2 == last2 || !ranges​::​search(std::forward<Ep>(exec), first1, last1, first2, last2, pred, proj1, proj2).empty().`
:::

## Modify `for_each` in [alg.foreach]{- .sref} ## {#modify_alg_foreach}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirectly_unary_invocable<projected<I, Proj>> Fun>
  constexpr ranges::for_each_result<I, Fun>
    ranges::for_each(I first, S last, Fun f, Proj proj = {});
template<input_range R, class Proj = identity,
         indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
  constexpr ranges::for_each_result<borrowed_iterator_t<R>, Fun>
    ranges::for_each(R&& r, Fun f, Proj proj = {});
```

*Effects*: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the range `[first, last)`, starting from `first`
and proceeding to `last - 1`.

[*Note X*: If the result of `invoke(proj, *i)` is a mutable reference, `f` can apply non-constant functions. — *end note*]

*Returns*: `{last, std​::​move(f)}.`

*Complexity*: Applies `f` and `proj` exactly `last - first` times.

*Remarks*: If `f` returns a result, the result is ignored.

[*Note X*: The overloads in namespace `ranges` require `Fun` to model `copy_constructible`. — *end note*]

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirectly_unary_invocable<projected<I, Proj>> Fun>
  I ranges::for_each(Ep&& exec, I first, S last, Fun f, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
  borrowed_iterator_t<R>
    ranges::for_each(Ep&& exec, R&& r, Fun f, Proj proj = {});
```

*Effects*: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the range `[first, last)`.

[*Note X*: If the result of `invoke(proj, *i)` is a mutable reference, `f` can apply non-constant functions. — *end note*]

*Returns*: `last.`

*Complexity*: Applies `f` and `proj` exactly `last - first` times.

*Remarks*: If `f` returns a result, the result is ignored. Implementations do not have the freedom granted under
[algorithms.parallel.exec] to make arbitrary copies of elements from the input sequence.

[*Note X*: The overloads in namespace `ranges` require `Fun` to model `copy_constructible`. — *end note*]

[*Note X*: Do not return a copy of its `Fun` parameter, since parallelization often does not permit efficient state
accumulation. — *end note*]
:::

```cpp
template<input_iterator I, class Proj = identity,
         indirectly_unary_invocable<projected<I, Proj>> Fun>
  constexpr ranges::for_each_n_result<I, Fun>
    ranges::for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});
```

*Preconditions*: `n >= 0` is `true`.

*Effects*: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the range `[first, first + n)` in order.

[*Note X*: If the result of `invoke(proj, *i)` is a mutable reference, `f` can apply non-constant functions. — *end note*]

*Returns*: `{first + n, std​::​move(f)}`.

*Remarks*: If `f` returns a result, the result is ignored.

[*Note X*: The overload in namespace `ranges` requires `Fun` to model `copy_constructible`. — *end note*]

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, class Proj = identity,
         indirectly_unary_invocable<projected<I, Proj>> Fun>
  I ranges::for_each_n(Ep&& exec, I first, iter_difference_t<I> n, Fun f, Proj proj = {});
```

*Preconditions*: `n >= 0` is `true`.

*Effects*: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the range `[first, first + n)`.

[*Note X*: If the result of `invoke(proj, *i)` is a mutable reference, `f` can apply non-constant functions. — *end note*]

*Returns*: `first + n`.

*Remarks*: If `f` returns a result, the result is ignored.

[*Note X*: The overload in namespace `ranges` requires `Fun` to model `copy_constructible`. — *end note*]

[*Note X*: Does not return a copy of its `Fun` parameter, since parallelization often does not permit efficient state
accumulation. — *end note*]
:::

## Modify `find` in [alg.find]{- .sref} ## {#modify_alg_find}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr I ranges::find(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_iterator_t<R>
    ranges::find(R&& r, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  I ranges::find(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  borrowed_iterator_t<R> ranges::find(Ep&& exec, R&& r, const T& value, Proj proj = {});
```
:::


```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr I ranges::find_if(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_iterator_t<R>
    ranges::find_if(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  I ranges::find_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  borrowed_iterator_t<R> ranges::find_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr I ranges::find_if_not(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_iterator_t<R>
    ranges::find_if_not(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  I ranges::find_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  borrowed_iterator_t<R> ranges::find_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

## Modify `find_last` in [alg.find.last]{- .sref} ## {#modify_alg_find_last}

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr subrange<I> ranges::find_last(I first, S last, const T& value, Proj proj = {});
template<forward_range R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_subrange_t<R> ranges::find_last(R&& r, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  subrange<I> ranges::find_last(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  borrowed_subrange_t<R> ranges::find_last(Ep&& exec, R&& r, const T& value, Proj proj = {});
```
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::find_last_if(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_subrange_t<R> ranges::find_last_if(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  subrange<I> ranges::find_last_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  borrowed_subrange_t<R> ranges::find_last_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::find_last_if_not(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_subrange_t<R> ranges::find_last_if_not(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  subrange<I> ranges::find_last_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  borrowed_subrange_t<R> ranges::find_last_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

## Modify `find_end` in [alg.find.end]{- .sref} ## {#modify_alg_find_end}

```cpp
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr subrange<I1>
    ranges::find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_subrange_t<R1>
    ranges::find_end(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1, random_access_iterator I2,
         sized_sentinel_for<I2> S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  subrange<I1> ranges::find_end(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  borrowed_subrange_t<R1> ranges::find_end(Ep&& exec, R1&& r1, R2&& r2,
                                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `find_first_of` in [alg.find.first.of]{- .sref} ## {#modify_alg_find_first_of}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr I1 ranges::find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                                     Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, forward_range R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_iterator_t<R1>
    ranges::find_first_of(R1&& r1, R2&& r2, Pred pred = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  I1 ranges::find_first_of(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  borrowed_iterator_t<R1> ranges::find_first_of(Ep&& exec, R1&& r1, R2&& r2,
                                                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `adjacent_find` in [alg.adjacent.find]{- .sref} ## {#modify_alg_adjacent_find}

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_binary_predicate<projected<I, Proj>,
                                   projected<I, Proj>> Pred = ranges::equal_to>
  constexpr I ranges::adjacent_find(I first, S last, Pred pred = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_binary_predicate<projected<iterator_t<R>, Proj>,
                                   projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
  constexpr borrowed_iterator_t<R> ranges::adjacent_find(R&& r, Pred pred = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_binary_predicate<projected<I, Proj>, projected<I, Proj>> Pred = ranges::equal_to>
  I ranges::adjacent_find(Ep&& exec, I first, S last, Pred pred = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_binary_predicate<projected<iterator_t<R>, Proj>, projected<iterator_t<R>, Proj>> Pred
           = ranges::equal_to>
  borrowed_iterator_t<R> ranges::adjacent_find(Ep&& exec, R&& r, Pred pred = {}, Proj proj = {});
```
:::


## Modify `count` in [alg.count]{- .sref} ## {#modify_alg_count}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr iter_difference_t<I>
    ranges::count(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr range_difference_t<R>
    ranges::count(R&& r, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  iter_difference_t<I> ranges::count(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  range_difference_t<R> ranges::count(Ep&& exec, R&& r, const T& value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr iter_difference_t<I>
    ranges::count_if(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr range_difference_t<R>
    ranges::count_if(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  iter_difference_t<I> ranges::count_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  range_difference_t<R> ranges::count_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

## Modify `mismatch` in [alg.mismatch]{- .sref} ## {#modify_alg_mismatch}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr ranges::mismatch_result<I1, I2>
    ranges::mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr ranges::mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::mismatch(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  ranges::mismatch_result<I1, I2>
    ranges::mismatch(Ep&& exec, I1 first1, S1 last1, I2 first2,S2 last2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  ranges::mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::mismatch(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `equal` in [alg.equal]{- .sref} ## {#modify_alg_equal}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::equal(I1 first1, S1 last1, I2 first2, S2 last2,
                               Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::equal(R1&& r1, R2&& r2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  bool ranges::equal(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  bool ranges::equal(Ep&& exec, R1&& r1, R2&& r2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `search` in [alg.search]{- .sref} ## {#modify_alg_search}

```cpp
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
         sentinel_for<I2> S2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr subrange<I1>
    ranges::search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_subrange_t<R1>
    ranges::search(R1&& r1, R2&& r2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    subrange<I1>
      ranges::search(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    borrowed_subrange_t<R1>
      ranges::search(Ep&& exec, R1&& r1, R2&& r2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

```cpp
template<forward_iterator I, sentinel_for<I> S,
         class Pred = ranges::equal_to, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirectly_comparable<I, const T*, Pred, Proj>
  constexpr subrange<I>
    ranges::search_n(I first, S last, iter_difference_t<I> count,
                     const T& value, Pred pred = {}, Proj proj = {});
template<forward_range R, class Pred = ranges::equal_to,
         class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
  constexpr borrowed_subrange_t<R>
    ranges::search_n(R&& r, range_difference_t<R> count,
                     const T& value, Pred pred = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Pred = ranges::equal_to, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirectly_comparable<I, const T*, Pred, Proj>
    subrange<I>
      ranges::search_n(Ep&& exec, I first, S last, iter_difference_t<I> count,
                       const T& value, Pred pred = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Pred = ranges::equal_to,
         class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
    borrowed_subrange_t<R>
      ranges::search_n(Ep&& exec, R&& r, range_difference_t<R> count,
                       const T& value, Pred pred = {}, Proj proj = {});
```
:::

## Modify `starts_with` in [alg.starts.with]{- .sref} ## {#modify_alg_starts_with}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity,
         class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::starts_with(R1&& r1, R2&& r2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
```

*Returns*: `ranges::mismatch(std::move(first1), last1, std::move(first2), last2, pred, proj1, proj2).in2 == last2`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  bool ranges::starts_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  bool ranges::starts_with(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

*Returns*: `ranges::mismatch(std::forward<Ep>(exec), std::move(first1), last1, std::move(first2), last2, pred, proj1, proj2).in2 == last2`
:::

## Modify `ends_with` in [alg.ends.with]{- .sref} ## {#modify_alg_ends_with}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires (forward_iterator<I1> || sized_sentinel_for<S1, I1>) &&
           (forward_iterator<I2> || sized_sentinel_for<S2, I2>) &&
           indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                   Proj1 proj1 = {}, Proj2 proj2 = {});
```
Let `N1` be `last1 - first1` and `N2` be `last2 - first2`.

*Returns*: `false` if `N1 < N2`, otherwise `ranges::equal(std::move(first1) + (N1 - N2), last1, std::move(first2), last2, pred, proj1, proj2)`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  bool ranges::ends_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                         Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
Let `N1` be `last1 - first1` and `N2` be `last2 - first2`.

*Returns*: `false` if `N1 < N2`, otherwise `ranges::equal(std::forward<Ep>(exec), std::move(first1) + (N1 - N2), last1, std::move(first2), last2, pred, proj1, proj2)`
:::

```cpp
template<input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity,
         class Proj2 = identity>
  requires (forward_range<R1> || sized_range<R1>) &&
           (forward_range<R2> || sized_range<R2>) &&
           indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::ends_with(R1&& r1, R2&& r2, Pred pred = {},
                                   Proj1 proj1 = {}, Proj2 proj2 = {});
```
Let `N1` be `ranges​::​distance(r1)` and `N2` be `ranges​::​distance(r2)`.

*Returns*: `false` if `N1 < N2`, otherwise `ranges::equal(views::drop(ranges::ref_view(r1), N1 - static_cast<decltype(N1)>(N2)), r2, pred, proj1, proj2)`

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  bool ranges::ends_with(Ep&& exec, R1&& r1, R2&& r2,
                         Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

Let `N1` be `ranges​::​distance(r1)` and `N2` be `ranges​::​distance(r2)`.

*Returns*: `false` if `N1 < N2`, otherwise `ranges::equal(std::forward<Ep>, views::drop(ranges::ref_view(r1), N1 - static_cast<decltype(N1)>(N2)), r2, pred, proj1, proj2)`
:::

## Modify `copy` in [alg.copy]{- .sref} ## {#modify_copy}

```cpp
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 copy(ExecutionPolicy&& policy,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_copyable<I, O>
  ranges::copy_result<I, O> ranges::copy(Ep&& exec, I first, S last, O result, OutS result_last);
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::copy(Ep&& exec, R&& r, OutR&& result);
```
:::

```cpp
template<input_iterator I, weakly_incrementable O>
  requires indirectly_copyable<I, O>
  constexpr ranges::copy_n_result<I, O>
    ranges::copy_n(I first, iter_difference_t<I> n, O result);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, random_access_iterator O>
  requires indirectly_copyable<I, O>
  ranges::copy_n_result<I, O>
    ranges::copy_n(Ep&& exec, I first, iter_difference_t<I> n, O result);
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O>
  constexpr ranges::copy_if_result<I, O>
    ranges::copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::copy_if_result<borrowed_iterator_t<R>, O>
    ranges::copy_if(R&& r, O result, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O>
  ranges::copy_if_result<I, O>
    ranges::copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
                    Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, random_access_iterator OutR,
         class Proj = identity, indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::copy_if(Ep&& exec, R&& r, OutR&& result, Pred pred, Proj proj = {});
```
:::

## Modify `move` in [alg.move]{- .sref} ## {#modify_move}

```cpp
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 move(ExecutionPolicy&& policy,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_movable<I, O>
  ranges::move_result<I, O> ranges::move(Ep&& exec, I first, S last, O result, OutS result_last);
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR>
  requires indirectly_movable<iterator_t<R>, iterator_t<OutR>>
  ranges::move_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::move(Ep&& exec, R&& r, OutR&& result);
```
:::


## Modify `swap` in [alg.swap]{- .sref} ## {#modify_swap}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2>
  requires indirectly_swappable<I1, I2>
  constexpr ranges::swap_ranges_result<I1, I2>
    ranges::swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
template<input_range R1, input_range R2>
  requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
  constexpr ranges::swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::swap_ranges(R1&& r1, R2&& r2);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1, random_access_iterator I2, sized_sentinel_for<I2> S2>
  requires indirectly_swappable<I1, I2>
  ranges::swap_ranges_result<I1, I2>
    ranges::swap_ranges(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2);
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2>
  requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
  ranges::swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::swap_ranges(Ep&& exec, R1&& r1, R2&& r2);
```
:::

## Modify `transform` in [alg.transform]{- .sref} ## {#modify_transform}

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
  constexpr ranges::unary_transform_result<I, O>
    ranges::transform(I first1, S last1, O result, F op, Proj proj = {});
template<input_range R, weakly_incrementable O, copy_constructible F,
         class Proj = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
  constexpr ranges::unary_transform_result<borrowed_iterator_t<R>, O>
    ranges::transform(R&& r, O result, F op, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
  ranges::unary_transform_result<I, O>
    ranges::transform(Ep&& exec, I first, S last, O result, OutS result_last,
                      F op, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<iterator_t<OutR>, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
  ranges::unary_transform_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::transform(Ep&& exec, R&& r, OutR&& result, F op, Proj proj = {});
```
:::

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, copy_constructible F, class Proj1 = identity,
         class Proj2 = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
                                         projected<I2, Proj2>>>
  constexpr ranges::binary_transform_result<I1, I2, O>
    ranges::transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         copy_constructible F, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
                                         projected<iterator_t<R2>, Proj2>>>
  constexpr ranges::binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::transform(R1&& r1, R2&& r2, O result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O,  sized_sentinel_for<O> OutS,
         copy_constructible F, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>, projected<I2, Proj2>>>
  ranges::binary_transform_result<I1, I2, O>
    ranges::transform(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, O result,
                      OutS result_last, F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, @_random-access-sized-range_@ OutR,
         copy_constructible F, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_writable<iterator_t<OutR>,
             indirect_result_t<F&, projected<iterator_t<R1>, Proj1>, projected<iterator_t<R2>, Proj2>>>
  ranges::binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::transform(Ep&& exec, R1&& r1, R2&& r2, OutR&& result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `replace` in [alg.replace]{- .sref} ## {#modify_replace}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T1 = projected_value_t<I, Proj>, class T2 = T1>
  requires indirectly_writable<I, const T2&> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
  constexpr I
    ranges::replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
template<input_range R, class Proj = identity,
         class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
  requires indirectly_writable<iterator_t<R>, const T2&> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
  constexpr borrowed_iterator_t<R>
    ranges::replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T1 = projected_value_t<I, Proj>, class T2 = T1>
  requires indirectly_writable<I, const T2&> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
  I ranges::replace(Ep&& exec, I first, S last,
                    const T1& old_value, const T2& new_value, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
  requires indirectly_writable<iterator_t<R>, const T2&> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
  borrowed_iterator_t<R>
    ranges::replace(Ep&& exec, R&& r,
                    const T1& old_value, const T2& new_value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_writable<I, const T&>
  constexpr I ranges::replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_writable<iterator_t<R>, const T&>
  constexpr borrowed_iterator_t<R>
    ranges::replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_writable<I, const T&>
  I ranges::replace_if(Ep&& exec, I first, S last, Pred pred,
                       const T& new_value, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_writable<iterator_t<R>, const T&>
  borrowed_iterator_t<R>
    ranges::replace_if(Ep&& exec, R&& r, Pred pred,
                       const T& new_value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, class O,
         class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
  requires indirectly_copyable<I, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
           output_iterator<O, const T2&>
  constexpr ranges::replace_copy_result<I, O>
    ranges::replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                         Proj proj = {});
template<input_range R, class O, class Proj = identity,
         class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = iter_value_t<O>>
  requires indirectly_copyable<iterator_t<R>, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
           && output_iterator<O, const T2&>
  constexpr ranges::replace_copy_result<borrowed_iterator_t<R>, O>
    ranges::replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                         Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>,
         class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
  requires indirectly_copyable<I, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
           indirectly_writable<O, const T2&>
  ranges::replace_copy_result<I, O>
    ranges::replace_copy(Ep&& exec, I first, S last, O result, OutS result_last,
                         const T1& old_value, const T2& new_value, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR,
         class Proj = identity, class T1 = projected_value_t<iterator_t<R>, Proj>,
         class T2 = range_value_t<OutR>>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*> &&
           indirectly_writable<iterator_t<OutR>, const T2&>
  ranges::replace_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::replace_copy(Ep&& exec, R&& r, OutR&& result,
                         const T1& old_value, const T2& new_value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S,class O, class T = iter_value_t<O>,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O> && output_iterator<O, const T&>
  constexpr ranges::replace_copy_if_result<I, O>
    ranges::replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                            Proj proj = {});
template<input_range R, class O, class T = iter_value_t<O>, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, O> && output_iterator<O, const T&>
  constexpr ranges::replace_copy_if_result<borrowed_iterator_t<R>, O>
    ranges::replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                            Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>, class T = iter_value_t<O>,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O> && indirectly_writable<O, const T&>
  ranges::replace_copy_if_result<I, O>
    ranges::replace_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
                            Pred pred, const T& new_value, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR,
         class T = range_value_t<OutR>, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
           indirectly_writable<iterator_t<OutR>, const T&>
  ranges::replace_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::replace_copy_if(Ep&& exec, R&& r, OutR&& result,
                            Pred pred, const T& new_value, Proj proj = {});
```
:::

## Modify `fill` in [alg.fill]{- .sref} ## {#modify_fill}

```cpp
template<class O, sentinel_for<O> S, class T = iter_value_t<O>>
  requires output_iterator<O, const T&>
  constexpr O ranges::fill(O first, S last, const T& value);
template<class R, class T = range_value_t<R>>
  requires output_range<R, const T&>
  constexpr borrowed_iterator_t<R> ranges::fill(R&& r, const T& value);
template<class O, class T = iter_value_t<O>>
  requires output_iterator<O, const T&>
  constexpr O ranges::fill_n(O first, iter_difference_t<O> n, const T& value);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator O, sized_sentinel_for<O> S,
         class T = iter_value_t<O>>
  requires output_iterator<O, const T&>
  O ranges::fill(Ep&& exec, O first, S last, const T& value);
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class T = range_value_t<R>>
  requires output_range<R, const T&>
  borrowed_iterator_t<R> ranges::fill(Ep&& exec, R&& r, const T& value);
template<@_execution-policy_@ Ep, random_access_iterator O, class T = iter_value_t<O>>
    requires indirectly_writable<O, const T&>
  O ranges::fill_n(Ep&& exec, O first, iter_difference_t<O> n, const T& value);
```
:::

## Modify `generate` in [alg.generate]{- .sref} ## {#modify_generate}

```cpp
template<input_or_output_iterator O, sentinel_for<O> S, copy_constructible F>
  requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
  constexpr O ranges::generate(O first, S last, F gen);
template<class R, copy_constructible F>
  requires invocable<F&> && output_range<R, invoke_result_t<F&>>
  constexpr borrowed_iterator_t<R> ranges::generate(R&& r, F gen);
template<input_or_output_iterator O, copy_constructible F>
  requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
  constexpr O ranges::generate_n(O first, iter_difference_t<O> n, F gen);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator O, sized_sentinel_for<O> S, copy_constructible F>
  requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
  O ranges::generate(Ep&& exec, O first, S last, F gen);
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, copy_constructible F>
  requires invocable<F&> && output_range<R, invoke_result_t<F&>>
  borrowed_iterator_t<R> ranges::generate(Ep&& exec, R&& r, F gen);
template<@_execution-policy_@ Ep, random_access_iterator O, copy_constructible F>
  requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
  O ranges::generate_n(Ep&& exec, O first, iter_difference_t<O> n, F gen);
```
:::

## Modify `remove` in [alg.remove]{- .sref} ## {#modify_remove}

```cpp
template<permutable I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr subrange<I> ranges::remove(I first, S last, const T& value, Proj proj = {});
template<forward_range R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires permutable<iterator_t<R>> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_subrange_t<R>
    ranges::remove(R&& r, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  subrange<I> ranges::remove(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires permutable<iterator_t<R>> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  borrowed_subrange_t<R> ranges::remove(Ep&& exec, R&& r, const T& value, Proj proj = {});
```
:::

```cpp
template<permutable I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::remove_if(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::remove_if(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  subrange<I> ranges::remove_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::remove_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
         class Proj = identity, class T = projected_value_t<I, Proj>>
  requires indirectly_copyable<I, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr ranges::remove_copy_result<I, O>
    ranges::remove_copy(I first, S last, O result, const T& value, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirectly_copyable<iterator_t<R>, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr ranges::remove_copy_result<borrowed_iterator_t<R>, O>
    ranges::remove_copy(R&& r, O result, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>,
         class Proj = identity, class T = projected_value_t<I, Proj>>
  requires indirectly_copyable<I, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  ranges::remove_copy_result<I, O>
    ranges::remove_copy(Ep&& exec, I first, S last, O result,  OutS result_last,
                        const T& value, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  ranges::remove_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::remove_copy(Ep&& exec, R&& r, OutR&& result, const T& value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O>
  constexpr ranges::remove_copy_if_result<I, O>
    ranges::remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::remove_copy_if_result<borrowed_iterator_t<R>, O>
    ranges::remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O>
  ranges::remove_copy_if_result<I, O>
    ranges::remove_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
                           Pred pred, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::remove_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::remove_copy_if(Ep&& exec, R&& r, OutR&& result, Pred pred, Proj proj = {});
```
:::

## Modify `unique` in [alg.unique]{- .sref} ## {#modify_unique}
```cpp
template<permutable I, sentinel_for<I> S, class Proj = identity,
         indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
  constexpr subrange<I> ranges::unique(I first, S last, C comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::unique(R&& r, C comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
  requires permutable<I>
  subrange<I> ranges::unique(Ep&& exec, I first, S last, C comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::unique(Ep&& exec, R&& r, C comp = {}, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
         indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
  requires indirectly_copyable<I, O> &&
           (forward_iterator<I> ||
            (input_iterator<O> && same_as<iter_value_t<I>, iter_value_t<O>>) ||
            indirectly_copyable_storable<I, O>)
  constexpr ranges::unique_copy_result<I, O>
    ranges::unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
         indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires indirectly_copyable<iterator_t<R>, O> &&
           (forward_iterator<iterator_t<R>> ||
            (input_iterator<O> && same_as<range_value_t<R>, iter_value_t<O>>) ||
            indirectly_copyable_storable<iterator_t<R>, O>)
  constexpr ranges::unique_copy_result<borrowed_iterator_t<R>, O>
    ranges::unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>, class Proj = identity,
         indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
  requires indirectly_copyable<I, O>
  ranges::unique_copy_result<I, O>
    ranges::unique_copy(Ep&& exec, I first, S last, O result, OutS result_last,
                        C comp = {}, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR, class Proj = identity,
         indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::unique_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::unique_copy(Ep&& exec, R&& r, OutR&& result,
                        C comp = {}, Proj proj = {});
```
:::

## Modify `reverse` in [alg.reverse]{- .sref} ## {#modify_reverse}

```cpp
template<bidirectional_iterator I, sentinel_for<I> S>
  requires permutable<I>
  constexpr I ranges::reverse(I first, S last);
template<bidirectional_range R>
  requires permutable<iterator_t<R>>
  constexpr borrowed_iterator_t<R> ranges::reverse(R&& r);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
  requires permutable<I>
  I ranges::reverse(Ep&& exec, I first, S last);
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R>
  requires permutable<iterator_t<R>>
  borrowed_iterator_t<R> ranges::reverse(Ep&& exec, R&& r);
```
:::

```cpp
template<bidirectional_iterator I, sentinel_for<I> S, weakly_incrementable O>
  requires indirectly_copyable<I, O>
  constexpr ranges::reverse_copy_result<I, O>
    ranges::reverse_copy(I first, S last, O result);
template<bidirectional_range R, weakly_incrementable O>
  requires indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::reverse_copy_result<borrowed_iterator_t<R>, O>
    ranges::reverse_copy(R&& r, O result);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_copyable<I, O>
  ranges::reverse_copy_result<I, O>
    ranges::reverse_copy(Ep&& exec, I first, S last, O result, OutS result_last);

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::reverse_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::reverse_copy(Ep&& exec, R&& r, OutR&& result);
```
:::

## Modify `rotate` in [alg.rotate]{- .sref} ## {#modify_rotate}

```cpp
template<permutable I, sentinel_for<I> S>
  constexpr subrange<I> ranges::rotate(I first, I middle, S last);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
  requires permutable<I>
  subrange<I> ranges::rotate(Ep&& exec, I first, I middle, S last);
```
:::

```cpp
template<forward_range R>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::rotate(R&& r, iterator_t<R> middle);
```
*Effects*: Equivalent to: `return ranges​::​rotate(ranges​::​begin(r), middle, ranges​::​end(r));`

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::rotate(Ep&& exec, R&& r, iterator_t<R> middle);
```
*Effects*: Equivalent to: `return ranges​::​rotate(std::forward<Ep>(exec), ranges​::​begin(r), middle, ranges​::​end(r));`
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr ranges::rotate_copy_result<I, O>
      ranges::rotate_copy(I first, I middle, S last, O result);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_copyable<I, O>
  ranges::rotate_copy_result<I, O>
    ranges::rotate_copy(Ep&& exec, I first, I middle, S last, O result, OutS result_last);
```
:::

```cpp
template<forward_range R, weakly_incrementable O>
  requires indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::rotate_copy_result<borrowed_iterator_t<R>, O>
    ranges::rotate_copy(R&& r, iterator_t<R> middle, O result);
```

*Effects*: Equivalent to: `return ranges::rotate_copy(ranges::begin(r), middle, ranges::end(r), std::move(result));`

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::rotate_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::rotate_copy(Ep&& exec, R&& r, iterator_t<R> middle, OutR&& result);
```
*Effects*: Equivalent to: `return ranges::rotate_copy(std::forward<Ep>(exec), ranges::begin(r), middle, ranges::end(r), ranges::begin(result), ranges::end(result));`
:::

## Modify `shift` in [alg.shift]{- .sref} ## {#modify_shift}

```cpp
template<permutable I, sentinel_for<I> S>
  constexpr subrange<I> ranges::shift_left(I first, S last, iter_difference_t<I> n);
template<forward_range R>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::shift_left(R&& r, range_difference_t<R> n)
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
  requires permutable<I>
  subrange<I> ranges::shift_left(Ep&& exec, I first, S last, iter_difference_t<I> n);
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::shift_left(Ep&& exec, R&& r, range_difference_t<R> n);
```
:::

```cpp
template<permutable I, sentinel_for<I> S>
  constexpr subrange<I> ranges::shift_right(I first, S last, iter_difference_t<I> n);
template<forward_range R>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::shift_right(R&& r, range_difference_t<R> n);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
  requires permutable<I>
  subrange<I> ranges::shift_right(Ep&& exec, I first, S last, iter_difference_t<I> n);
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::shift_right(Ep&& exec, R&& r, range_difference_t<R> n);
```
:::

## Modify `sort` in [sort]{- .sref} ## {#modify_sort}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I
    ranges::sort(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::sort(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

## Modify `stable_sort` in [stable.sort]{- .sref} ## {#modify_stable_sort}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I ranges::stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::stable_sort(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::stable_sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::stable_sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

## Modify `partial_sort` in [partial.sort]{- .sref} ## {#modify_partial_sort}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I
    ranges::partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::partial_sort(Ep&& exec, I first, I middle, S last, Comp comp = {}, Proj proj = {});
```
:::

```cpp
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::partial_sort(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::partial_sort(ranges::begin(r), middle, ranges::end(r), comp, proj);`

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::partial_sort(Ep&& exec, R&& r, iterator_t<R> middle,
                                              Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::partial_sort(std::forward<Ep>(exec), ranges::begin(r), middle, ranges::end(r), comp, proj);`
:::

## Modify `partial_sort_copy` in [partial.sort.copy]{- .sref} ## {#modify_partial_sort_copy}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, random_access_iterator I2, sentinel_for<I2> S2,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
           indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
  constexpr ranges::partial_sort_copy_result<I1, I2>
    ranges::partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, random_access_range R2, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
           sortable<iterator_t<R2>, Comp, Proj2> &&
           indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>>
  constexpr ranges::partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
           indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
  ranges::partial_sort_copy_result<I1, I2>
    ranges::partial_sort_copy(Ep&& exec, I1 first, S1 last, I2 result_first, S2 result_last,
                              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
           sortable<iterator_t<R2>, Comp, Proj2> &&
           indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>>
  ranges::partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::partial_sort_copy(Ep&& exec, R1&& r, R2&& result_r, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `is_sorted` in [is.sorted]{- .sref} ## {#modify_is_sorted}

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_sorted(R&& r, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges​::​is_sorted_until(first, last, comp, proj) == last;`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  bool ranges::is_sorted(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  bool ranges::is_sorted(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to:<br>
`return ranges​::​is_sorted_until(std::forward<Ep>(exec), first, last, comp, proj) == last;`
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  I ranges::is_sorted_until(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  borrowed_iterator_t<R> ranges::is_sorted_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

## Modify `nth_element` in [alg.nth.element]{- .sref} ## {#modify_nth_element}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I
    ranges::nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::nth_element(Ep&& exec, I first, I nth, S last, Comp comp = {}, Proj proj = {});
```
:::

```cpp
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::nth_element(ranges::begin(r), nth, ranges::end(r), comp, proj);`

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::nth_element(Ep&& exec, R&& r, iterator_t<R> nth,
                                             Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::nth_element(std::forward<Ep>(exec), ranges::begin(r), nth, ranges::end(r), comp, proj);`
:::

## Modify `partitions` in [alg.partitions]{- .sref} ## {#modify_partitions}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr bool ranges::is_partitioned(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::is_partitioned(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  bool ranges::is_partitioned(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  bool ranges::is_partitioned(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

```cpp
template<permutable I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr subrange<I>
    ranges::partition(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::partition(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  subrange<I> ranges::partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::partition(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

```cpp
template<bidirectional_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires permutable<I>
  constexpr subrange<I> ranges::stable_partition(I first, S last, Pred pred, Proj proj = {});
template<bidirectional_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::stable_partition(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires permutable<I>
  subrange<I> ranges::stable_partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::stable_partition(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O1, weakly_incrementable O2,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
  constexpr ranges::partition_copy_result<I, O1, O2>
    ranges::partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                           Proj proj = {});
template<input_range R, weakly_incrementable O1, weakly_incrementable O2,
         class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, O1> &&
           indirectly_copyable<iterator_t<R>, O2>
  constexpr ranges::partition_copy_result<borrowed_iterator_t<R>, O1, O2>
    ranges::partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O1, sized_sentinel_for<O1> OutS1,
         random_access_iterator O2, sized_sentinel_for<O2> OutS2,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
  ranges::partition_copy_result<I, O1, O2>
    ranges::partition_copy(Ep&& exec, I first, S last, O1 out_true, OutS1 last_true,
                           O2 out_false, OutS2 last_false, Pred pred, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, @_random-access-sized-range_@ OutR1,
         @_random-access-sized-range_@ OutR2, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR1>> &&
           indirectly_copyable<iterator_t<R>, iterator_t<OutR2>>
  ranges::partition_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR1>, borrowed_iterator_t<OutR2>>
    ranges::partition_copy(Ep&& exec, R&& r, OutR1&& out_true, OutR2&& out_false,
                           Pred pred, Proj proj = {});
```
:::

## Modify `merge` in [alg.merge]{- .sref} ## {#modify_merge}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,
         class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::merge_result<I1, I2, O>
    ranges::merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::merge(R1&& r1, R2&& r2, O result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::merge_result<I1, I2, O>
    ranges::merge(Ep&& exec, I1 first1, S1 last1,
                  I2 first2, S2 last2, O result, OutS result_last,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2,
         @_random-access-sized-range_@ OutR, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::merge(Ep&& exec, R1&& r1, R2&& r2, OutR&& result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

```cpp
template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I ranges::inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::inplace_merge(Ep&& exec, I first, I middle, S last, Comp comp = {}, Proj proj = {});
```
:::

```cpp
template<bidirectional_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::inplace_merge(ranges::begin(r), middle, ranges::end(r), comp, proj);`

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::inplace_merge(Ep&& exec, R&& r, iterator_t<R> middle,
                                               Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::inplace_merge(std::forward<Ep>(exec), ranges::begin(r), middle, ranges::end(r), comp, proj);`
:::

## Modify `includes` in [includes]{- .sref} ## {#modify_includes}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<I1, Proj1>,
                                    projected<I2, Proj2>> Comp = ranges::less>
  constexpr bool ranges::includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Proj1 = identity,
         class Proj2 = identity,
         indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  constexpr bool ranges::includes(R1&& r1, R2&& r2, Comp comp = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1, random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less>
  bool ranges::includes(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>, projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  bool ranges::includes(Ep&& exec, R1&& r1, R2&& r2,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `set_union` in [set.union]{- .sref} ## {#modify_set_union}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_union_result<I1, I2, O>
    ranges::set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_union_result<I1, I2, O>
    ranges::set_union(Ep&& exec, I1 first1, S1 last1,
                      I2 first2, S2 last2, O result, OutS result_last,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, @_random-access-sized-range_@ OutR,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::set_union(Ep&& exec, R1&& r1, R2&& r2, OutR&& result,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `set_intersection` in [set.intersection]{- .sref} ## {#modify_set_intersection}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_intersection_result<I1, I2, O>
    ranges::set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::set_intersection(R1&& r1, R2&& r2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_intersection_result<I1, I2, O>
    ranges::set_intersection(Ep&& exec, I1 first1, S1 last1,
                             I2 first2, S2 last2, O result, OutS result_last,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, @_random-access-sized-range_@ OutR,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::set_intersection(Ep&& exec, R1&& r1, R2&& r2, OutR&& result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `set_difference` in [set.difference]{- .sref} ## {#modify_set_difference}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_difference_result<I1, O>
    ranges::set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_difference_result<borrowed_iterator_t<R1>, O>
    ranges::set_difference(R1&& r1, R2&& r2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_difference_result<I1, O>
    ranges::set_difference(Ep&& exec, I1 first1, S1 last1,
                           I2 first2, S2 last2, O result, OutS result_last,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, @_random-access-sized-range_@ OutR,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<OutR>>
    ranges::set_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `set_symmetric_difference` in [set.symmetric.difference]{- .sref} ## {#modify_set_symmetric_difference}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_symmetric_difference_result<I1, I2, O>
    ranges::set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                     Comp comp = {}, Proj1 proj1 = {},
                                     Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_symmetric_difference_result<borrowed_iterator_t<R1>,
                                                    borrowed_iterator_t<R2>, O>
    ranges::set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_symmetric_difference_result<I1, I2, O>
    ranges::set_symmetric_difference(Ep&& exec, I1 first1, S1 last1,
                                     I2 first2, S2 last2, O result, OutS result_last,
                                     Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, @_random-access-sized-range_@ OutR,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_symmetric_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::set_symmetric_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result,
                                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify `is_heap` in [is.heap]{- .sref} ## {#modify_is_heap}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_heap(R&& r, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges​::​is_heap_until(first, last, comp, proj) == last;`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  bool ranges::is_heap(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  bool ranges::is_heap(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges​::​is_heap_until(std::forward<Ep>(exec), first, last, comp, proj) == last;`
:::

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  I ranges::is_heap_until(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  borrowed_iterator_t<R>
    ranges::is_heap_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});

```
:::

## Modify `min`, `max`, `minmax` in [alg.min.max]{- .sref} ## {#modify_alg_min_max}

```cpp
template<input_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  constexpr range_value_t<R>
    ranges::min(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  range_value_t<R>
    ranges::min(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

```cpp
template<input_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  constexpr range_value_t<R>
    ranges::max(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  range_value_t<R>
    ranges::max(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

```cpp
template<input_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  constexpr ranges::minmax_result<range_value_t<R>>
    ranges::minmax(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  ranges::minmax_result<range_value_t<R>>
    ranges::minmax(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::min_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::min_element(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  I ranges::min_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  borrowed_iterator_t<R>
    ranges::min_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::max_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::max_element(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  I ranges::max_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  borrowed_iterator_t<R>
    ranges::max_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr ranges::minmax_element_result<I>
    ranges::minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr ranges::minmax_element_result<borrowed_iterator_t<R>>
    ranges::minmax_element(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  ranges::minmax_element_result<I>
    ranges::minmax_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  ranges::minmax_element_result<borrowed_iterator_t<R>>
    ranges::minmax_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

## Modify `lexicographical_compare` in [alg.lex.comparison]{- .sref} ## {#modify_alg_lex_comparison}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<I1, Proj1>,
                                    projected<I2, Proj2>> Comp = ranges::less>
  constexpr bool
    ranges::lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Proj1 = identity,
         class Proj2 = identity,
         indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  constexpr bool
    ranges::lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less>
  bool ranges::lexicographical_compare(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ R1, @_random-access-sized-range_@ R2, class Proj1 = identity,
         class Proj2 = identity,
         indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  bool ranges::lexicographical_compare(Ep&& exec, R1&& r1, R2&& r2, Comp comp = {},
                                       Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

## Modify [memory.syn]{- .sref} ## {#modify_memory_syn}

```cpp
@_// [specialized.algorithms], specialized algorithms_@
@_// [special.mem.concepts], special memory concepts_@
template<class I>
  concept @_nothrow-input-iterator_@ = @_see below_@;       @_`// exposition only`_@
template<class I>
  concept @_nothrow-forward-iterator_@ = @_see below_@;     @_`// exposition only`_@
```
::: add
```cpp
template<class I>
  concept @_nothrow-bidirectional-iterator_@ = @_see below_@;  @_// exposition only_@
template<class I>
  concept @_nothrow-random-access-iterator_@ = @_see below_@;  @_// exposition only_@
```
:::

```cpp
template<class S, class I>
  concept @_nothrow-sentinel-for_@ = @_see below_@;         @_`// exposition only`_@
```
::: add
```cpp
template<class S, class I>
  concept @_nothrow-sized-sentinel-for_@ = @_see below_@;   @_// exposition only_@
```
:::
```cpp
template<class R>
  concept @_nothrow-input-range_@ = @_see below_@;          @_`// exposition only`_@
template<class R>
  concept @_nothrow-forward-range_@ = @_see below_@;        @_`// exposition only`_@
```
::: add
```cpp
template<class I>
  concept @_nothrow-bidirectional-range_@ = @_see below_@;     @_// exposition only_@
template<class I>
  concept @_nothrow-random-access-range_@ = @_see below_@;     @_// exposition only_@
template<class I>
  concept @_nothrow-random-access-sized-range_@ = @_see below_@;     @_// exposition only_@
```
:::

```cpp
template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
  requires default_initializable<iter_value_t<I>>
    I uninitialized_default_construct(I first, S last);                         // @_freestanding_@
template<@_nothrow-forward-range_@ R>
  requires default_initializable<range_value_t<R>>
    borrowed_iterator_t<R> uninitialized_default_construct(R&& r);              // @_freestanding_@

template<@_nothrow-forward-iterator_@ I>
  requires default_initializable<iter_value_t<I>>
    I uninitialized_default_construct_n(I first, iter_difference_t<I> n);       // @_freestanding_@
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for_@<I> S>
  requires default_initializable<iter_value_t<I>>
  I uninitialized_default_construct(Ep&& exec, I first, S last); @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, @_nothrow-random-access-sized-range_@ R>
  requires default_initializable<range_value_t<R>>
  borrowed_iterator_t<R> uninitialized_default_construct(Ep&& exec, R&& r); @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
  requires default_initializable<iter_value_t<I>>
  I uninitialized_default_construct_n(Ep&& exec, I first, iter_difference_t<I> n); @_// see [algorithms.parallel.overloads]_@
```
:::

```cpp
template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
  requires default_initializable<iter_value_t<I>>
    I uninitialized_value_construct(I first, S last);                           @_// freestanding_@
template<@_nothrow-forward-range_@ R>
  requires default_initializable<range_value_t<R>>
    borrowed_iterator_t<R> uninitialized_value_construct(R&& r);                @_// freestanding_@

template<@_nothrow-forward-iterator_@ I>
  requires default_initializable<iter_value_t<I>>
    I uninitialized_value_construct_n(I first, iter_difference_t<I> n);         @_// freestanding_@
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for<_@I> S>
  requires default_initializable<iter_value_t<I>>
  I uninitialized_value_construct(Ep&& exec, I first, S last); @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, @_nothrow-random-access-sized-range_@ R>
  requires default_initializable<range_value_t<R>>
  borrowed_iterator_t<R> uninitialized_value_construct(Ep&& exec, R&& r); @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
  requires default_initializable<iter_value_t<I>>
  I uninitialized_value_construct_n(Ep&& exec, I first, iter_difference_t<I> n); @_// see [algorithms.parallel.overloads]_@
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S1,
          @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S2>
  requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
    uninitialized_copy_result<I, O>
      uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);               @_// freestanding_@
template<input_range IR, @_nothrow-forward-range_@ OR>
  requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
    uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
      uninitialized_copy(IR&& in_range, OR&& out_range);                        @_// freestanding_@

template<class I, class O>
  using uninitialized_copy_n_result = in_out_result<I, O>;                      @_// freestanding_@
template<input_iterator I, @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S>
  requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
    uninitialized_copy_n_result<I, O>
      uninitialized_copy_n(I ifirst, iter_difference_t<I> n,                    @_// freestanding_@
                           O ofirst, S olast);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S1,
         @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S2>
  requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
    uninitialized_copy_result<I, O>
      uninitialized_copy(Ep&& exec, I ifirst, S1 ilast, O ofirst, S2 olast); @_// see [algorithms.parallel.overloads]_@
template<@_execution-policy_@ Ep, @_random-access-sized-range_@ IR, @_nothrow-random-access-sized-range_@ OR>
  requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
    uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
      uninitialized_copy(Ep&& exec, IR&& in_range, OR&& out_range); @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, random_access_iterator I, @_nothrow-random-access-iterator_@ O,
         @_nothrow-sized-sentinel-for_@<O> S>
  requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
    uninitialized_copy_n_result<I, O>
      uninitialized_copy_n(Ep&& exec, I ifirst, iter_difference_t<I> n, @_// see [algorithms.parallel.overloads]_@
                           O ofirst, S olast);
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S1,
          @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S2>
  requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
    uninitialized_move_result<I, O>
      uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);              @_// freestanding_@
template<input_range IR, @_nothrow-forward-range_@ OR>
  requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
    uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
      uninitialized_move(IR&& in_range, OR&& out_range);                       @_// freestanding_@

template<input_iterator I,
          @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S>
  requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
    uninitialized_move_n_result<I, O>
      uninitialized_move_n(I ifirst, iter_difference_t<I> n,                @_// freestanding_@
                           O ofirst, S olast);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S1,
         @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S2>
  requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
    uninitialized_move_result<I, O>
      uninitialized_move(Ep&& exec, I ifirst, S1 ilast, O ofirst, S2 olast); @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, @_random-access-sized-range_@ IR, @_nothrow-random-access-sized-range_@ OR>
  requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
    uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
      uninitialized_move(Ep&& exec, IR&& in_range, OR&& out_range);        @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, random_access_iterator I,
    @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S>
  requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
    uninitialized_move_n_result<I, O>
      uninitialized_move_n(Ep&& exec, I ifirst, iter_difference_t<I> n, @_// see [algorithms.parallel.overloads]_@
                           O ofirst, S olast);
```
:::

```cpp
template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S, class T>
  requires constructible_from<iter_value_t<I>, const T&>
    I uninitialized_fill(I first, S last, const T& x);                          @_// freestanding_@
template<@_nothrow-forward-range_@ R, class T>
  requires constructible_from<range_value_t<R>, const T&>
    borrowed_iterator_t<R> uninitialized_fill(R&& r, const T& x);               @_// freestanding_@

template<@_nothrow-forward-iterator_@ I, class T>
  requires constructible_from<iter_value_t<I>, const T&>
    I uninitialized_fill_n(I first, iter_difference_t<I> n, const T& x);        @_// freestanding_@
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for_@<I> S, class T>
  requires constructible_from<iter_value_t<I>, const T&>
    I uninitialized_fill(Ep&& exec, I first, S last, const T& x);                @_// see [algorithms.parallel.overloads]_@
template<@_execution-policy_@ Ep, @_nothrow-random-access-sized-range_@ R, class T>
  requires constructible_from<range_value_t<R>, const T&>
    borrowed_iterator_t<R> uninitialized_fill(Ep&& exec, R&& r, const T& x);     @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, class T>
  requires constructible_from<iter_value_t<I>, const T&>
    I uninitialized_fill_n(Ep&& exec, I first, iter_difference_t<I> n, const T& x); @_// see [algorithms.parallel.overloads]_@
```
:::

```cpp
template<@_nothrow-input-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
  requires destructible<iter_value_t<I>>
    constexpr I destroy(I first, S last) noexcept;                              @_// freestanding_@
template<@_nothrow-input-range_@ R>
  requires destructible<range_value_t<R>>
    constexpr borrowed_iterator_t<R> destroy(R&& r) noexcept;                   @_// freestanding_@

template<@_nothrow-input-iterator_@ I>
  requires destructible<iter_value_t<I>>
    constexpr I destroy_n(I first, iter_difference_t<I> n) noexcept;            @_// freestanding_@
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for_@<I> S>
  requires destructible<iter_value_t<I>>
    I destroy(Ep&& exec, I first, S last) noexcept;                           @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, @_nothrow-random-access-sized-range_@ R>
  requires destructible<range_value_t<R>>
    borrowed_iterator_t<R> destroy(Ep&& exec, R&& r) noexcept;                @_// see [algorithms.parallel.overloads]_@

template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
  requires destructible<iter_value_t<I>>
    I destroy_n(Ep&& exec, I first, iter_difference_t<I> n) noexcept;         @_// see [algorithms.parallel.overloads]_@
```
:::

## Add exposition only concepts to [special.mem.concepts]{- .sref} ## {#modify_special_mem_concepts}

```cpp
template<class S, class I>
concept @_nothrow-sentinel-for_@ = sentinel_for<S, I>; @_`// exposition only`_@
```

Types `S` and `I` model `@_nothrow-sentinel-for_@` only if no exceptions are thrown from copy construction,
move construction, copy assignment, move assignment, or comparisons between valid values of type `I` and `S`.

[*Note X*: This concept allows some `sentinel_for` ([iterator.concept.sentinel]) operations to throw exceptions. — *end note*]

::: add
```cpp
template<class S, class I>
concept @_nothrow-sized-sentinel-for_@ = @_// exposition only_@
  @_nothrow-sentinel-for_@<S, I> &&
  sized_sentinel_for<S, I>;
```

Types `S` and `I` model `@_nothrow-sized-sentinel-for_@` only if no exceptions are thrown from the `-` operator
for valid values of type `I` and `S`.

[*Note X*: This concept allows some `sized_sentinel_for` ([iterator.concept.sizedsentinel]) operations to throw exceptions. — *end note*]
:::

```cpp
template<class I>
concept @_nothrow-forward-iterator_@ = @_`// exposition only`_@
  @_nothrow-input-iterator_@<I> &&
  forward_iterator<I> &&
  @_nothrow-sentinel-for_@<I, I>;
```

[*Note X*: This concept allows some `forward_iterator` ([iterator.concept.forward]) operations to throw exceptions. — *end note*]

```cpp
template<class R>
concept @_nothrow-forward-range_@ = @_`// exposition only`_@
  @_nothrow-input-range_@<R> &&
  @_nothrow-forward-iterator_@<iterator_t<R>>;
```

::: add
```cpp
template<class I>
concept @_nothrow-bidirectional-iterator_@ = @_// exposition only_@
  @_nothrow-forward-iterator_@<I> &&
  bidirectional_iterator<I>;
```

A type `I` models `@_nothrow-bidirectional-iterator_@` only if no exceptions are thrown from decrementing valid iterators.

[*Note X*: This concept allows some `bidirectional_iterator` ([iterator.concept.bidir]) operations to throw exceptions. — *end note*]

```cpp
template<class R>
concept @_nothrow-bidirectional-range_@ = @_// exposition only_@
  @_nothrow-forward-range_@<R> &&
  @_nothrow-bidirectional-iterator_@<iterator_t<R>>;
```
```cpp
template<class I>
concept @_nothrow-random-access-iterator_@ = @_// exposition only_@
  @_nothrow-bidirectional-iterator_@<I> &&
  random_access_iterator<I> &&
  @_nothrow-sized-sentinel-for_@<I, I>;
```

A type `I` models `@_nothrow-random-access-iterator_@` only if no exceptions are thrown from advancement
with `+=`, `+`, `-=`, and `-`, comparisons, or applying the `[]` subscript operator to valid iterators.

[*Note X*: This concept allows some `random_access_iterator` ([iterator.concept.random.access]) operations to throw exceptions. — *end note*]

```cpp
template<class R>
concept @_nothrow-random-access-range_@ = @_// exposition only_@
  @_nothrow-bidirectional-range_@<R> &&
  @_nothrow-random-access-iterator_@<iterator_t<R>>;

template<class R>
concept @_nothrow-random-access-sized-range_@ = @_// exposition only_@
  @_nothrow-random-access-range_@<R> && sized_range<R>;
```
:::

# Revision history # {#revision_history}

## R3 => R4 ## {#r3_r4}

- Revert back to range-as-the-output design aspect, change the formal wording accordingly
- Revert back to requiring all ranges to be sized (`&&` instead of `||`)
- Clarify which execution policies are supported
- Clarify that new APIs extend algorithm function objects in `std::ranges`
- Add the feature test macro
- Add implementation experience and thoughts on implementability
- Fix known bugs in the signatures
- Address other feedback from SG1 and SG9:
    - Decide on constraining the execution policy template parameter
    - List all the algorithms that are being given execution policy overloads
    - List range algorithms that are being excluded

## R2 => R3 ## {#r2_r3}

- Use `iterator` as an output
- Add wording

## R1 => R2 ## {#r1_r2}

- Summarize proposed differences from the serial range algorithms and from the non-range parallel algorithms
- Allow all but one input sequences to be unbounded
- List existing algorithms that take ranges for output
- Update arguments and mitigation for using ranges for output
- Add more arguments in support of random access ranges
- Fix the signatures of `for_each` to match the proposed design

## R0 => R1 ## {#r0_r1}

- Address the feedback from SG1 and SG9 review
- Add more information about iterator constraints
- Propose `range` as an output for the algorithms
- Require ranges to be bounded

# Polls # {#polls}

## SG9, Wroclaw, 2024 ## {#sg9_wroclaw_2024}

**Poll 1**: Change `mismatch` and `equal` to require `sized_range` for both inputs ("`&&` instead of `||`").
<table>
  <tr>
    <th>SF</th>
    <th>F</th>
    <th>N</th>
    <th>A</th>
    <th>SA</th>
  </tr>
  <tr>
    <td>4</td>
    <td>3</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
  </tr>
</table>

**Poll 2**: Change `transform` to require `sized_range` for both inputs ("`&&` instead of `||`"),
with the plan to relax these constraints once we have a way to statically detect infinite ranges.
<table>
  <tr>
    <th>SF</th>
    <th>F</th>
    <th>N</th>
    <th>A</th>
    <th>SA</th>
  </tr>
  <tr>
    <td>3</td>
    <td>3</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
  </tr>
</table>

**Poll 3**: We want to remove the "legacy" overload that includes only an iterator as output for convenience, because we know it's unsafe.
<table>
  <tr>
    <th>SF</th>
    <th>F</th>
    <th>N</th>
    <th>A</th>
    <th>SA</th>
  </tr>
  <tr>
    <td>4</td>
    <td>4</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
</table>

**Poll 4** Forward P3179R3 with the changes in P3490R0 (as updated above) to LEWG for inclusion in C++26 with these changes polled above.

<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>4
    <td>5
    <td>0
    <td>0
    <td>0
  </tr>
</table>

## SG1, Wroclaw, 2024 ## {#sg1_wroclaw_2024}

Forward P3179R3 to LEWG with the following notes:

1. The intention is that algorithms call `begin`/`end` only once, in serial code
     (we do not think any new words are needed)
2. The intention is that `mismatch`, `transform` and `equal` assume the unsized range
     is at least as large as the sized one (UB / precondition) or require && sized

<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>4
    <td>8
    <td>0
    <td>0
    <td>0
  </tr>
</table>

## Joint SG1 + SG9, St. Louis, 2024 ## {#sg1_sg9_st_louis_2024}

**Poll**: Continue work on P3179R2 for IS'26 with these notes:
1. RandomAccess for inputs and outputs
2. Iterators for outputs
3. We believe the overloads are worth it

<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>7
    <td>4
    <td>2
    <td>1
    <td>0
  </tr>
</table>

## SG9, Tokyo, 2024 ## {#sg9_tokyo_2024}

**Poll 1**: `for_each` shouldn't return the callable
<table>
  <tr>
    <th>SF</th>
    <th>F</th>
    <th>N</th>
    <th>A</th>
    <th>SA</th>
  </tr>
  <tr>
    <td>2</td>
    <td>4</td>
    <td>2</td>
    <td>0</td>
    <td>0</td>
  </tr>
</table>

**Poll 2**: Parallel `std::ranges` algos should return the same type as serial `std::ranges` algos

<table>
  <tr>
    <td>Unanimous consent.</td>
  </tr>
</table>

**Poll 3**: Parallel ranges algos should require `forward_range`, not `random_access_range`

<table>
  <tr>
    <th>SF</th>
    <th>F</th>
    <th>N</th>
    <th>A</th>
    <th>SA</th>
  </tr>
  <tr>
    <td>3</td>
    <td>2</td>
    <td>3</td>
    <td>1</td>
    <td>1</td>
  </tr>
</table>

**Poll 4**: Range-based parallel algos should require const operator()

<table>
  <tr>
    <th>SF</th>
    <th>F</th>
    <th>N</th>
    <th>A</th>
    <th>SA</th>
  </tr>
  <tr>
    <td>0</td>
    <td>7</td>
    <td>2</td>
    <td>0</td>
    <td>0</td>
  </tr>
</table>

---
references:
  - id: P3490R0
    citation-label: P3490R0
    title: "Justification for ranges as the output of parallel range algorithms"
    author:
      - family: Kukanov
        given: Alexey
      - family: Arutyunyan
        given: Ruslan
    URL: http://www.wg21.link/P3490R0
---
