---
title: C++ parallel range algorithms
document: P3179R9
date: 2025-05-20
author:
    - name: Ruslan Arutyunyan
      email: <ruslan.arutyunyan@intel.com>
    - name: Alexey Kukanov
      email: <alexey.kukanov@intel.com>
    - name: Bryce Adelstein Lelbach (he/him/his)
      email: <brycelelbach@gmail.com>
audience:
    - LWG
toc-depth: 4
---

<style>
@media screen {
    #TOC {
        position: fixed;
        width: min(20%, 30em);
        height: 100%;
        left: 0;
        top: 0;
        overflow-y: scroll;
        padding-left: 1em;
        padding-right: 1em;
        text-align: left;
        a {
            font-size: 110%;
        }
    }
    body {
        padding-left: min(21%, 32em);
    }
}
</style>

# Abstract # {- .unlisted}

This paper proposes adding parallel algorithms that work together with the C++ Ranges library.

# Motivation # {#motivation}

Standard parallel algorithms with execution policies which set semantic requirements to user-provided callable objects
were a good start for supporting parallelism in the C++ standard.

The C++ Ranges library - ranges, views, etc. - is a powerful facility to produce lazily evaluated pipelines
that can be processed by range-based algorithms. Together they provide a productive and expressive API
with the room for extra optimizations.

Combining these two powerful features by adding support for execution policies to the range-based algorithms opens
an opportunity to fuse several computations into one parallel algorithm call, thus reducing the overhead on parallelism.
That is especially valuable for heterogeneous implementations of parallel algorithms, for which the range-based API helps
reducing the number of kernels submitted to an accelerator.

Users are already using ranges and range adaptors by passing range iterators to the existing non-range parallel
algorithms. [@P2408R5] was adopted to enable this. This pattern is often featured when teaching C++ parallel algorithms
and appears in many codebases.

`iota` and `cartesian_product` are especially common, as many compute workloads want to iterate over indices, not
objects, and many work with multidimensional data. `transform` is also common, as it enables fusion of element-wise
operations into a single parallel algorithm call, which can avoid the need for temporary storage and is more
performant than two separate calls.

However, passing range iterators to non-range algorithms is unwieldy and verbose. It is surprising to
users that they cannot simply pass the ranges to the parallel algorithms as they would for serial algorithms.

::: cmptable

> Scalar-Vector Multiply

### Before
```cpp
std::span<double> data = …;
double C = …;

auto indices = std::views::iota(1, data.size());
std::for_each(std::execution::par_unseq,
  std::ranges::begin(indices),
  std::ranges::end(indices),
  [=] (auto i) { data[i] *= C; });
```

### After
```cpp
std::span<double> data = …;
double C = …;

std::ranges::for_each(std::execution::par_unseq,
  std::views::iota(1, data.size()),
  [=] (auto i) { data[i] *= C; });
```
:::

::: cmptable
> Matrix Transpose

### Before
```cpp
std::mdspan A{input,  N, M};
std::mdspan B{output, M, N};

auto indices = std::views::cartesian_product(
  std::views::iota(0, A.extent(0)),
  std::views::iota(0, A.extent(1)));

std::for_each(std::execution::par_unseq,
  std::ranges::begin(indices),
  std::ranges::end(indices),
  [=] (auto idx) {
    auto [i, j] = idx;
    B[j, i] = A[i, j];
  });
```

### After
```cpp
std::mdspan A{input,  N, M};
std::mdspan B{output, M, N};

std::ranges::for_each(std::execution::par_unseq,
  std::views::cartesian_product(
    std::views::iota(0, A.extent(0)),
    std::views::iota(0, A.extent(1))),
  [=] (auto idx) {
    auto [i, j] = idx;
    B[j, i] = A[i, j];
  });
```
:::

Earlier, [@P2500R2] proposed to add the range-based C++ parallel algorithms together with its primary goal of extending
algorithms with schedulers. We have decided to split those parts to separate papers, which could progress independently.

# Design overview # {#design_overview}

This paper proposes execution policy support for C++ range-based algorithms. In the nutshell, the proposal extends C++
range algorithms with overloads taking any standard or implementation defined C++ execution policy as a function parameter.
These overloads are further referred to as *parallel range algorithms*.

The proposal is targeted to C++26.

## Design summary ## {#design_summary}

### Differences to serial range algorithms ### {#design_diff_to_cpp20_ranges}

Comparing to the C++20 serial range algorithms, we propose the following modifications:

- The execution policy parameter is added, supporting all standard and implementation-defined execution policies.
  See [](#supported_policies).
- `for_each` and `for_each_n` return only an iterator but not the function. See [](#return_type).
- Parallel range algorithms take a range, not an iterator, as the output for the overloads with ranges, and additionally take
    an output sentinel for the "iterator and sentinel" overloads. See [](#range_as_the_output).
- Until better parallelism-friendly abstractions are proposed, parallel algorithms require `random_access_{iterator,range}`.
  See [](#random_access_requirement).
- All input and output data sequences must be bounded. See [](#require_bounded_ranges).
  - As a consequence, when the bounded output has less space than needed for all the input, an algorithm might return
      iterators pointing to the positions where the processing stopped. See [](#bounded_output).

### Differences to C++17 parallel algorithms ### {#design_diff_to_cpp17_par}

In addition to data sequences being passed as either ranges or "iterator and sentinel" pairs, the following differences
to the C++17 parallel algorithms are proposed:

- `for_each` returns an iterator, not `void`.
- Algorithms require `random_access_{iterator,range}`, and not *LegacyForwardIterator*.
- All input and output data sequences must be bounded.

### Other design aspects ### {#design_other_aspects}

- Except as mentioned above, the parallel range algorithms should return the same type as the corresponding serial range
  algorithms. See [](#return_type).
- The proposed algorithms extend the overload set of algorithm function objects defined in `std::ranges`.
  See [](#algorithm_func_objects).
- The proposed algorithms should require callable object passed to an algorithm to be `regular_invocable` where possible.
  See [](#callable_parameters).
- The proposed algorithms should follow the design of C++17 parallel algorithms with regard to `constexpr` support.
  See [](#constexpr_support).
- `rotate_copy`, `reverse_copy`, and `partition_copy` design is described separately. See [](#bounded_output).

### An example of the proposed API ### {#design_api_example}

The proposed API will look like the following (using `transform` as an example):

```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
  ranges::unary_transform_result<I, O>
    ranges::transform(Ep&& exec, I first, S last, O result, OutS result_last,
                      F op, Proj proj = {});

template<@_execution-policy_@ Ep, ranges::@_sized-random-access-range_@ R, ranges::@_sized-random-access-range_@ OutR,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<ranges::iterator_t<OutR>, indirect_result_t<F&, projected<ranges::iterator_t<R>, Proj>>>
  ranges::unary_transform_result<ranges::borrowed_iterator_t<R>, ranges::borrowed_iterator_t<OutR>>
    ranges::transform(Ep&& exec, R&& r, OutR&& result, F op, Proj proj = {});
```

The used exposition-only concepts are described below.

## Coexistence with schedulers ## {#coexistence_with_schedulers}

We believe that adding parallel range algorithms does not have the risk of conflict with anticipated scheduler-based
algorithms, because an execution policy does not satisfy the requirements for a policy-aware scheduler [@P2500R2],
a sender [@P3300R0], or really anything else from [@P2300R10] that can be used to specify such algorithms.

At this point we do not, however, discuss how the appearance of schedulers
may or should impact the execution rules for parallel algorithms specified in
[algorithms.parallel.exec]{- .sref},
and just assume that the same rules apply to the range algorithms with execution policies.

## Supported execution policies ## {#supported_policies}

Parallel range algorithms should operate with the same set of execution policies as the existing parallel algorithms,
that is, `seq`, `unseq`, `par`, and `par_unseq` in the `std::execution` namespace, as well as any implementation-defined
execution policies.

The following exposition-only concept simplifies constraining the algorithms with proper execution policy types:

```cpp
template<class Ep>
concept @_execution-policy_@ = @_`// exposition only`_@
    is_execution_policy_v<remove_cvref_t<Ep>>;
```

We do not propose the parallel range algorithms to be customizable for application-defined execution policies.
We expect such custom policies to become unnecessary once the standard algorithms are capable of working with
schedulers/senders/receivers.

## Algorithm return types ## {#return_type}

We explored possible algorithm return types and came to conclusion that returning the same type as serial range
algorithms is the preferred option to make the changes for enabling parallelism minimal.

```cpp
auto res = std::ranges::sort(v);
```

becomes:

```cpp
auto res = std::ranges::sort(std::execution::par, v);
```

However, `std::ranges::for_each` and `std::ranges::for_each_n` require special consideration because previous
design decisions suggest that there should be a difference between serial and parallel versions.

The following table summarizes return value types for the existing variants of these two algorithms:

API                                                     Return type
---                                                     -----------
`std::for_each`                                         `Function`
Parallel `std::for_each`                                `void`
`std::for_each_n`                                       `Iterator`
Parallel `std::for_each_n`                              `Iterator`
`std::ranges::for_each`                                 `for_each_result<ranges::borrowed_iterator_t<Range>, Function>`
`std::ranges::for_each`, `I` + `S` overload             `for_each_result<Iterator, Function>`
`std::ranges::for_each_n`                               `for_each_n_result<Iterator, Function>`


While the serial `std::for_each` returns the obtained function object with all modifications it might have accumulated,
the return type for the parallel `std::for_each` is `void` because, as stated in the standard, "parallelization often
does not permit efficient state accumulation". For efficient parallelism an implementation can make multiple copies of
the function object, which for that purpose is allowed to be copyable and not just movable like for the serial `for_each`.
That implies that users cannot rely on any state accumulation within that function object, so it does not make sense
(and might be even dangerous) to return it.

In `std::ranges`, the return type of `for_each` and `for_each_n` is unified to return both an iterator and the function
object.

Based on the analysis above and [the feedback from SG9](#sg9_tokyo_2024) we think that the most reasonable return type
for parallel variants of `std::ranges::for_each` and `std::ranges::for_each_n` should be:


API                                                        Return type
---                                                        -----------
Parallel `std::ranges::for_each`                           `ranges::borrowed_iterator_t<Range>`
Parallel `std::ranges::for_each`, `I` + `S` overload       `Iterator`
Parallel `std::ranges::for_each_n`                         `Iterator`

## Extending the overload sets of algorithm function objects ## {#algorithm_func_objects}

We believe the proposed functionality should have the same properties and general behavior as serial range algorithms,
particularly regarding the name lookup.

With the adoption of [@P3136R0], function templates in the `std::ranges` namespace have been respecified as
*algorithm function objects*. These objects are defined as sets of one or more overloaded function templates,
which names designate the objects.

The parallel range algorithms we propose will extend the overload sets for the respective algorithm function objects.
The name lookup rules for such objects will apply automatically. It is covered by the wording proposed in [@P3136R0];
additional changes are not needed.

From the implementation standpoint, adding parallel versions of the range algorithms to the overload set should not be
a problem. Please see [](#possible_impl) for more information.

## Requiring `random_access_iterator` or `random_access_range` ## {#random_access_requirement}

C++17 parallel algorithms minimally require *LegacyForwardIterator* for data sequences, but in our opinion, it is not quite
suitable for an efficient parallel implementation. Therefore for parallel range algorithms we propose to require
random access ranges and iterators.

Using parallel algorithms with forward ranges will in most cases give little to no benefit,
and may even reduce performance due to extra overheads. We believe that forward ranges and iterators are bad abstractions
for parallel data processing, and allowing those could result in wrong expectations and unsatisfactory user experience
with parallel algorithms.

Many parallel programming models that are well known and widely used in the industry, including OpenMP, OpenCL, CUDA,
SYCL, oneTBB, define iteration or data spaces for their parallel constructs in ways that allow creating sufficient
parallel work quickly and efficiently. A key property for this is the ability to split the work into smaller chunks.
These programming models allow to control the amount of work per chunk and sometimes the ways chunks are created
and/or scheduled. All these also support iteration spaces up to at least 3 dimensions.

Except for `tbb::parallel_for_each` in oneTBB which can work with forward iterators, these parallel programming models
require random access iterators or some equivalent, such as numeric indexes or pointers. This is natural,
as referring to an arbitrary point in the iteration space at constant time is the main and by far simplest way
to create parallel work. Forward iterators, on the other hand, are notoriously bad for splitting a sequence
that can only be done in linear time. Moreover, if the output of an algorithm should preserve the order of its input,
which is typical for the C++ algorithms, it requires additional synchronization or/and additional space with forward
iterators and comes almost for granted with random access ones.

These very programming models are often used as backends to implement the C++ standard parallelism. Not surprisingly,
most implementations fall back to serial processing if data sequences have no random access. Of the GNU libstdc++,
LLVM libc++, and MSVC's standard library, only the latter attempts to process forward iterator based sequences in parallel,
for which it first needs to serially iterate over a whole sequence once or even twice.
oneAPI DPC++ library (oneDPL) supports forward iterators only for a very few algorithms,
only for `par` and only in the implementation based on oneTBB.

According to the SG1/SG9 feedback we have got earlier, there seemingly are two main reasons why others do not want to restrict
parallel algorithms by only random access ranges:

- That would prevent some useful views, such as `filter_view`, from being used with parallel range algorithms.
- That would be inconsistent with the C++17 parallel algorithms.

Given the other aspects of the proposed design, we believe some degree of inconsistency with C++17 parallel algorithms
is inevitable and should not become a gating factor for important design decisions.

The question of supporting the standard views that do not provide random access is very important. We think though
that it should better be addressed through proper abstractions and new concepts defining iteration spaces, including
multidimensional ones, suitable for parallel algorithms. We intend to work on developing these in the future,
however it requires time and effort to make it right; trying to squeeze that into C++26 would add significant risks.
For now, random access ranges with known bounds (see [](#require_bounded_ranges)) is probably the best approximation
that exists in the standard. Starting from that and gradually enabling other types of iteration spaces
in a source-compatible manner seems to us better than blanket allowance of any `forward_range`.

## Taking range as the output ## {#range_as_the_output}

We propose taking a range as the output for the overloads that take ranges for input.
Similarly, we propose requiring a sentinel for the output where the input is passed as "iterator and sentinel".

The benefits of this *range-as-the-output* approach, comparing to taking a single iterator for the output, are:

- It creates a safer API where all data sequences have known bounds. Specifically, the `sized_range`
    and `sized_sentinel_for` concepts will be applied to the output sequences in the same way as to the input sequences.
- Not for all algorithms the output size is defined by the input size. An example is `copy_if` (and similar
    algorithms with *filtering* semantics), where the output sequence might be shorter than the input one.
    Knowing the expected size of the output may open opportunities for more efficient implementations.
- Passing a range for the output makes code a bit simpler in the cases typical for parallel execution.

On the joint SG1 and SG9 discussion of [@P3179R2] the audience expressed several concerns about the idea and
[requested to stay with iterators for the output](#sg1_sg9_st_louis_2024) until deeper investigation is made.

To address the concerns, we wrote a separate paper [@P3490R0] with the detailed investigation of the topic,
suggesting there a compromise solution with adding separate function template overloads for both *iterator-as-the-output*
and *range-as-the-output*. See [@P3490R0] for more details.

Eventually SG9 [accepted](#sg9_wroclaw_2024) our original proposal to use ranges for the output, without extra overloads
for legacy convenience.

## Requiring ranges to be bounded ## {#require_bounded_ranges}

One of the requirements we want to put on the parallel range algorithms is to disallow unbounded input and output.
The reasons for that are:

- For efficient parallel implementation we need to know the iteration space bounds. Otherwise, it's hard to
    apply the "divide and conquer" strategy for creating work for multiple execution threads.
- While serial range algorithms allow passing an "infinite" range like `std::ranges::views::iota(0)`,
    it may result in an endless loop. It's hard to imagine usefulness of that in the case of parallel execution.
    Requiring data sequences to be bounded potentially prevents errors at run-time.
- Using explicitly bounded output ranges follows established practices of secure coding, which recommend or even
    require to always specify the size of the output in order to prevent out-of-range data modifications.

If several input ranges or sequences are bounded, an algorithm should usually stop as soon as the end is reached for the
shortest one. There are already precedents in the standard that an algorithm takes two sequences with potentially different
input sizes and chooses the smaller size as the number of iterations it is going to make, such as `std::ranges::transform`
and `std::ranges::mismatch`. For the record, `std::transform` (including the overload with execution policy) doesn't support
different input sizes, while `std::mismatch` does.

For a few algorithms - namely, `mismatch`, `equal`, and `transform` -
it could be sufficient for just one range to be bounded and the other assumed to have at least as many elements
as the bounded one. This enables unbounded ranges such as `views::repeat` in certain useful patterns, for example:

```cpp
void normalize_parallel(range auto&& v) {
  auto mx = reduce(execution::par, v, ranges::max{});
  transform(execution::par, v, views::repeat(mx), v.begin(), divides);
}
```

However, SG9 [decided](#sg9_wroclaw_2024) to require `sized_range` for all inputs, with the plan to relax these constraints
for `transform` once there is a way to statically detect infinite ranges like `views::repeat` (as opposed to finite unsized
ranges, such as null terminated strings).

Dealing with bounded output sequences is discussed in detail in [](#bounded_output).

The exposition-only concept _`sized-random-access-range`_ combines the key requirements to the types of ranges
to simplify the signatures of parallel range algorithms:

```cpp
template<class R>
concept @_sized-random-access-range_@ = @_`// exposition only`_@
    ranges::random_access_range<R> && ranges::sized_range<R>;
```

### Handling bounded output ### {#bounded_output}

As the output data sequences are bounded, they are no more assumed to have sufficient space for all the input.
There is thus a possibility that some elements of the input sequences are not processed by an algorithm,
and it makes sense for it to return iterators to the positions in these sequences where the processing stopped.

As the general principle, we propose the algorithm execution to stop once the next value cannot be written
to the output. For some algorithms (`copy`, `transform`, and others), this is equivalent to reaching the end
of the output sequence. Other algorithms, however, may skip some elements of the input, and so can keep
going even if the output has no space for as long as nothing needs to be written. We discuss these options
in the [](#partition_copy) subsection. Per [LEWG decision](#lewg_hagenberg_2025), the same semantics should be
used for `copy_if`, `remove_copy[_if]`, `unique_copy`, as well as for set algorithms.

For `reverse_copy` and `rotate_copy` below we propose modifications to which iterators are returned
that do not match their existing serial counterparts.

If some day serial range algorithms with range-as-the-output appear, we envision the same semantics for these algorithms.

#### `reverse_copy` design #### {#reverse_copy}

The `reverse_copy` algorithm is special because it traverses an input range from the end to the beginning for serial algorithms.
One of the serial range overloads has the following signature:

```cpp
template<std::bidirectional_iterator I, std::sentinel_for<I> S, std::weakly_incrementable O>
requires std::indirectly_copyable<I, O>
constexpr reverse_copy_result<I, O> reverse_copy(I first, S last, O result);
```

For the input, it returns the iterator equal to `last` because it assumes `result` has sufficient space to write everything.

In the 'Parallel Range Algorithms' overloads the situation is different. Since the output is bounded the input might be
traversed partially. We need to define semantics for that case.

Let's have a look to the proposed signature:

```cpp
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_copyable<I, O>
  ranges::reverse_copy_result<I, O>
    ranges::reverse_copy(Ep&& exec, I first, S last, O result, OutS result_last);
```

The only reasonable semantics we could think of when the output size is not sufficient is returning an iterator
to the last inserted element in the reverse order starting from `last - 1`. The implication of this decision is that
the algorithm would return `first` in case the output size is sufficient to write all the input.

An example with the range-based overload:

```cpp
std::vector input{1,2,3,4};
std::vector<int> output(2);

// Takes 2 elements from input
auto res = std::ranges::reverse_copy(@_policy_@, input, output);
// After the algorithm execution:
// - output is {4,3}
// - res.in == (input.end() - 2) is true
```

This design choice is made for users to get the information about how many elements were handled.
Returning `last` does not make sense for this overload.

Furthermore, it's consistent with the analogous behavior that we have in the standard. Consider the following example:

```cpp
std::vector input{1,2,3,4};
std::vector<int> output(10);

// Basically, emulates reverse_copy
auto res = std::ranges::copy(input | std::views::reverse | std::views::take(2), output.begin());
// After the algorithm execution:
// - output is {4,3}
// - res.in points to the element equal to 2, however it is a reverse_iterator,
//   thus is not comparable with input.end()
// - res.in.base() has the same type as input.end(), and res.in.base() == input.end() - 2 is true
```

But in the example above we limited the input. Let's use `uninitialized_copy` where we can limit the output:

```cpp
std::vector input{1,2,3,4};
std::unique_ptr mem = std::make_unique_for_overwrite<int[]>(10);
std::ranges::subrange<int*, int*> mem_range{mem.get(), mem.get() + 10};

auto res = std::ranges::uninitialized_copy(input | std::views::reverse, mem_range | std::views::take(2));
// After the algorithm execution:
// - output is {4,3}
// - res.in points to the element equal to 2, however it is a reverse_iterator,
//   thus is not comparable with input.end()
// - res.in.base() has the same type as input.end(), and res.in.base() == input.end() - 2 is true
```

#### `rotate_copy` design #### {#rotate_copy}

The situation for `rotate_copy` is very similar to `reverse_copy` in the sense that it also does not
traverse the input in order.

Let's look at the existing signature:

```cpp
template<std::forward_iterator I, std::sentinel_for<I> S, std::weakly_incrementable O>
requires std::indirectly_copyable<I, O>
constexpr rotate_copy_result<I, O> rotate_copy(I first, I middle, S last, O result);
```

The algorithm traverses from `middle` to `last` and then from `first` to `middle`. Very much like `reverse_copy` it returns
`last` for the input range because it also assumes that the output size is always sufficient.

For 'Parallel Range Algorithms' overloads the situation is again different. The output size might be insufficient to
write everything. We believe that we also need to return the iterator past the last element we were able to insert.
The implication of this decision is the algorithm would return `middle` for the input when the output size is sufficient
to write everything from the input.

An example with the range-based overload:

```cpp
std::vector input{1,2,3,4,5,6};
std::vector<int> output(2);

auto res = std::ranges::rotate_copy(@_policy_@, input, input.begin() + 3, output);
// After the algorithm execution:
// - output is {4,5}
// - res.in points to the element equal to 6, exactly past-the-last element written to the output
```

Another example, with the output size sufficient for the subrange from `middle` to `last` but not sufficient to write all
the input:

```cpp
std::vector input{1,2,3,4,5,6};
std::vector<int> output(5);

auto res = std::ranges::rotate_copy(@_policy_@, input, input.begin() + 3, output);
// After the algorithm execution:
// - output is {4,5,6,1,2}
// - res.in points to the element equal to 3, exactly past-the-last element written to the output
```

There are two corner cases to consider:

- The output size is exactly `last` - `middle`.
- The output size is zero.

For the first corner case we propose to return `first` because this is the next iterator that would have been copied from
(in other words, past-the-last), if the space was sufficient.

```cpp
std::vector input{1,2,3,4,5,6};
std::vector<int> output(3);

auto res = std::ranges::rotate_copy(@_policy_@, input, input.begin() + 3, output);
// After the algorithm execution:
// - output is {4,5,6}
// - res.in points to the element equal to 1, past-the-last element written to the output from this algorithm standpoint
```

For the second corner case we propose to return `middle`. This situation is distinguishable from the case when the output
size is sufficient. Because `result` was not moved anywhere, the returned object is `{middle, result}`, while in case when
the output size is sufficient the returned object is `{middle, result + N}`, where `N` is the number of elements written to
the output.

```cpp
std::vector input{1,2,3,4,5,6};
std::vector<int> output;

auto res = std::ranges::rotate_copy(@_policy_@, input, input.begin() + 3, output);
// After the algorithm execution:
// - output is {}
// - res.in points to the element equal to 4, middle, because no elements were written
// - res.out == output.begin() is true
```

Please note that the `rotate_copy` parallel range algorithm never returns `last`.

#### `partition_copy` design #### {#partition_copy}

`partition_copy` is special because this is the only algorithm that has two outputs: one is for the predicate returning
`true`, another one - for the predicate returning `false`. The existing overloads assume that the output is
always sufficient and so guarantee to traverse the whole input. However, this is not the case for the proposed
overloads with an execution policy. Let's look at the proposed signature:

```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O1, sized_sentinel_for<O1> OutS1,
         random_access_iterator O2, sized_sentinel_for<O2> OutS2,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
  ranges::partition_copy_result<I, O1, O2>
    ranges::partition_copy(Ep&& exec, I first, S last, O1 out_true, OutS1 last_true,
                           O2 out_false, OutS2 last_false, Pred pred, Proj proj = {});
```

The biggest question is when to stop traversing the input if one of the output ranges does not have space to write into.

There are three considered options:

1. Stop when both ranges do not have space. It means that if, for example, the `out_true` range reaches the end but the
   `out_false` range still has some available space, the algorithm continues going through the input. Given that the algorithm
   returns the iterator where it stops, we think this semantics is bad because it creates a false impression that the input
   is handled till the returned iterator, while, in fact, some elements might be skipped. This violates user expectations.
2. Stop when one of the output ranges reaches the end. While this semantics is perhaps good enough, we could do better
   in some cases. For example, if the `out_true` range reaches its end, but the predicate returns `false` for the rest
   of the input, we can still write to the `out_false` range until it is also full.
3. Stop when we cannot write the next element. It means that while we have some input to traverse we take an element from it,
   check that element by the predicate, decide whether it should go to `out_true` or `out_false`, and stop only if
   we don't have available space in the respective output range.

We propose the option (3).

A possible serial implementation of the proposed semantics:

```cpp
struct partition_copy_fn
{
    template<@_execution-policy_@ Ep, std::random_access_iterator I, std::sized_sentinel_for<I> S,
         std::random_access_iterator O1, std::sized_sentinel_for<O1> OutS1,
         std::random_access_iterator O2, std::sized_sentinel_for<O2> OutS2,
         class Proj = std::identity, std::indirect_unary_predicate<std::projected<I, Proj>> Pred>
        requires std::indirectly_copyable<I, O1> && std::indirectly_copyable<I, O2>
    std::ranges::partition_copy_result<I, O1, O2>
    operator()(Ep&& exec, I first, S last, O1 out_true, OutS1 last_true,
               O2 out_false, OutS2 last_false, Pred pred, Proj proj = {}) const
    {
        while (first != last)
        {
            if (std::invoke(pred, std::invoke(proj, *first)))
            {
                if (out_true != last_true) {
                    *out_true = *first;
                    ++out_true;
                    ++first;
                }
                else
                    break;
            }
            else
            {
                if(out_false != last_false) {
                    *out_false = *first;
                    ++out_false;
                    ++first;
                }
                else
                    break;
            }
        }
        return {std::move(first), std::move(out_true), std::move(out_false)};
    }
};

inline constexpr partition_copy_fn partition_copy;
```

An example for the range-based overload:

```cpp
const auto in = {1,3,5,2,4,6,8,7,9,0};
std::vector<int> out_true(3), out_false(5);

auto pred = [](int i) { return (i & 0x01) == 1; }; // true, if odd

auto res = partition_copy(@_policy_@, in, out_true, out_false, pred);
// After the algorithm execution:
// - out_true is {1,3,5}
// - out_false is {2,4,6,8}
// - res.in points to the element equal to 7 because this is the first element we could not write
```

With the option (1) the example above would stop at `in.end()` pretending that it handles everything.
However, this is not true because it skips elements equal to `7` and `9`. Thus, we do NOT propose this semantics.

With the option (2) the example above would stop at the element equal to `2` because the `out_true` range reaches its end.
However, we still have available space in `out_false` range where we could write the next 4 consecutive elements. Thus,
we do NOT propose this semantics.

## Requirements for callable parameters ## {#callable_parameters}

In [@P3179R0] we proposed that parallel range algorithms should require function objects for predicates, comparators, etc.
to have `const`-qualified `operator()`, with the intent to provide compile-time diagnostics for mutable	function objects
which might be unsafe for parallel execution. We have got contradictory feedback from SG1 and SG9 on that topic:
SG1 preferred to keep the behavior consistent with C++17 parallel algorithms, while SG9 supported our design intent.

We did extra investigation and decided that requiring `const`-qualified operator at compile-time is not strictly necessary
because:

- The vast majority of the serial range algorithms requires function objects to be `regular_invocable` (or its derivatives),
    which already has the semantic requirement of not modifying either the function object or its arguments.
    While not enforced at compile-time, it seems good enough for our purpose because it demands having the same function
    object state between invocations (independently of `const` qualifier), and it is consistent with serial range algorithms.
- Remaining algorithms should be considered individually. For example, `for_each` using a mutable `operator()` is of less
    concern if the algorithm does not return the function object (see more detailed analysis below).
    For `generate`, a non-mutable callable appears to be of very limited use: in order to produce multiple values while not
    taking any arguments, a generator should typically maintain and update some state.

The following example works fine for serial code. While it compiles for parallel code, users should not assume that the
semantics remains intact. Since the parallel version of `for_each` requires function object to be copyable, it
is not guaranteed that all `for_each` iterations are processed by the same function object. Practically speaking, users
cannot rely on accumulating any state modifications in a parallel `for_each` call.

```cpp
struct callable
{
    void operator()(int& x)
    {
        ++x;
        ++i; // a data race if the callable is executed concurrently
    }
    int get_i() const {
        return i;
    }
private:
    int i = 0;
};

callable c;

// serial for_each call
auto fun = std::for_each(v.begin(), v.end(), c);

// parallel for_each call
// The callable object cannot be read because parallel for_each version purposefully returns void
std::for_each(std::execution::par, v.begin(), v.end(), c);

// for_each serial range version call
auto [_, fun] = std::ranges::for_each(v.begin(), v.end(), c);
```

We allow the same callable to be used in the proposed `std::ranges::for_each`.

```cpp
// callable is used from the previous code snippet
callable c;
// The returned iterator is ignored
std::ranges::for_each(std::execution::par, v.begin(), v.end(), c);
```

Again, even though `c` accumulates state modifications, one cannot rely on that because an algorithm implementation
is allowed to make as many copies of `c` as it wants. Of course, this can be overcome by using `std::reference_wrapper`
but that might lead to data races.

```cpp
// callable is used from the previous code snippet
// Wrapping a callable object with std::reference_wrapper compiles, but might result in data races
callable c;
std::ranges::for_each(std::execution::par, v.begin(), v.end(), std::ref(c));
```

Our conclusion is that it's user responsibility to provide such a callable that avoids data races, same as for C++17 parallel
algorithms.

## `constexpr` parallel range algorithms ## {#constexpr_support}

[@P2902R0] suggests allowing algorithms with execution policies to be used in constant expressions.
We do not consider that as a primary design goal for our work, however we will happily align with that proposal
in the future once it progresses towards adoption into the working draft.

# More examples # {#more_examples}

## Change existing code to use parallel range algorithms ## {#easy_to_switch}

One of the goals is to require a minimal amount of changes when switching from the existing API to parallel range
algorithms. However, that simplicity should not create hidden issues negatively impacting the overall user experience.
We believe that the proposal provides a good balance in that regard.

As an example, let's look at using `for_each` to apply a lambda function to all elements of a `std::vector v`.

For the serial range-based `for_each` call:

```cpp
std::ranges::for_each(v, [](auto& x) { ++x; });
```

switching to the parallel version will look like:

```cpp
std::ranges::for_each(std::execution::par, v, [](auto& x) { ++x; });
```

In this simple case, the only change is an execution policy added as the first function argument. It will also hold for
the "iterator and sentinel" overload of `std::ranges::for_each`.

The C++17 parallel `for_each` call:

```cpp
std::for_each(std::execution::par, v.begin(), v.end(), [](auto& x) { ++x; });
```

can be changed to one of the following:

```cpp
// Using iterator and sentinel
std::ranges::for_each(std::execution::par, v.begin(), v.end(), [](auto& x) { ++x; });

// Using vector as a range
std::ranges::for_each(std::execution::par, v, [](auto& x) { ++x; });
```

So, here only changing the namespace is necessary, though users might also change `v.begin(), v.end()` to just `v`.

However, for other algorithms more changes might be necessary.

## Less parallel algorithm calls and better expressiveness ## {#less_parallel_call}

Let's consider the following example:

```cpp
reverse(policy, begin(data), end(data));
transform(policy, begin(data), end(data), begin(result), [](auto i){ return i * i; });
auto res = find_if(policy, begin(result), end(result), pred);
```

It has three stages and eventually tries to answer the question if the input sequence contains an element after reversing
and transforming it. The interesting considerations are:

- Since the example has three parallel stages, it adds extra overhead for parallel computation per algorithm.
- The first two stages will complete for all elements before the `any_of` stage is started, though it is not required for
    correctness. If reverse and transformation would be done on the fly, a good implementation of `any_of` might have
    skipped the remaining work when `pred` returns `true`, thus providing more performance.

Let's make it better:

```cpp
// With fancy iterators
auto res = find_if(policy,
                   make_transform_iterator(make_reverse_iterator(end(data)),
                                          [](auto i){ return i * i; }),
                   make_transform_iterator(make_reverse_iterator(begin(data)),
                                          [](auto i){ return i * i; }),
                   pred);
```

Now there is only one parallel algorithm call, and `any_of` can skip unneeded work. However, this
variation also has interesting considerations:

- First, it doesn't compile. We use `transform iterator` to pass the transformation function,
    but the two `make_transform_iterator` expressions use two different lambdas, and
    the iterator type for `any_of` cannot be deduced because the types of `transform_iterator` do not match.
    One of the options to make it compile is to store a lambda in a variable.
- Second, it requires using a non-standard iterator.
- Third, the expressiveness of the code is not good: it is hard to read while easy to make a mistake
    like the one described in the first bullet.

Let's improve the example further with the proposed API:

```cpp
// With ranges
auto res = find_if(policy, data | views::reverse | views::transform([](auto i){ return i * i; }),
                   pred);
```

The example above lacks the drawbacks described for the previous variations:

- There is only one algorithm call;
- The implementation might skip unnecessary work;
- There is no room for the lambda type mistake;
- The readability is much better compared to the second variation and not worse than in the first one.

# Possible implementation of a parallel range algorithm # {#possible_impl}

Here we show a possible implementation of `std::ranges::for_each` with the new overloads
proposed in [](#modify_alg_foreach):

```cpp
// A possible implementation of std::ranges::for_each
namespace ranges
{
namespace __detail
{
struct __for_each_fn
{
    // ...
    // Existing serial overloads
    // ...

    // The overload for unsequenced and parallel policies. Requires random_access_iterator
    template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
             class Proj = identity, indirectly_unary_invocable<projected<I, Proj>> Fun>
    I operator()(Ep&& exec, I first, S last, Fun f, Proj proj = {}) const
    {
        // properly handle the execution policy;
        // for the reference, a serial implementation is provided
        for (; first != last; ++first)
        {
            std::invoke(f, std::invoke(proj, *first));
        }
        return first;
    }

    template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
             indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
    ranges::borrowed_iterator_t<R>
    operator()(Ep&& exec, R&& r, Fun f, Proj proj = {}) const
    {
        return (*this)(std::forward<Ep>(exec), std::ranges::begin(r),
                       std::ranges::end(r), f, proj);
    }
}; // struct for_each
} // namespace __detail
inline namespace __for_each_fn_namespace
{
inline constexpr __detail::__for_each_fn for_each;
} // __for_each_fn_namespace
} // namespace ranges
```

# The proposal scope # {#proposal_scope}

## In-scope ## {#in_scope}

### The counterparts of C++17 parallel algorithms in `std::ranges` namespace ### {#cpp17_counterpart}

<table>
  <tr>
    <td>`all_of`
    <td>`search[_n]`
    <td>`remove_copy`
    <td>`is_sorted`
    <td>`is_heap`
  </tr>
  <tr>
    <td>`any_of`
    <td>`copy[_n]`
    <td>`remove_copy_if`
    <td>`is_sorted_until`
    <td>`is_heap_until`
  </tr>
  <tr>
    <td>`none_of`
    <td>`copy_if`
    <td>`unique`
    <td>`nth_element`
    <td>`min_element`
  </tr>
  <tr>
    <td>`for_each[_n]`
    <td>`move`
    <td>`unique_copy`
    <td>`is_partitioned`
    <td>`max_element`
  </tr>
  <tr>
    <td>`find`
    <td>`swap_ranges`
    <td>`reverse`
    <td>`partition`
    <td>`minmax_element`
  </tr>
  <tr>
    <td>`find_if`
    <td>`transform`
    <td>`reverse_copy`
    <td>`stable_partition`
    <td>`lexicographical_compare`
  </tr>
  <tr>
    <td>`find_if_not`
    <td>`replace`
    <td>`rotate`
    <td>`partition_copy`
    <td>`uninitialized_default_construct[_n]`
  </tr>
  <tr>
    <td>`find_end`
    <td>`replace_if`
    <td>`rotate_copy`
    <td>`merge`
    <td>`uninitialized_value_construct[_n]`
  </tr>
  <tr>
    <td>`find_first_of`
    <td>`replace_copy`
    <td>`shift_left`
    <td>`inplace_merge`
    <td>`uninitialized_copy[_n]`
  </tr>
  <tr>
    <td>`adjacent_find`
    <td>`replace_copy_if`
    <td>`shift_right`
    <td>`includes`
    <td>`uninitialized_move[_n]`
  </tr>
  <tr>
    <td>`count`
    <td>`fill[_n]`
    <td>`sort`
    <td>`set_union`
    <td>`uninitialized_fill[_n]`
  </tr>
  <tr>
    <td>`count_if`
    <td>`generate[_n]`
    <td>`stable_sort`
    <td>`set_intersection`
    <td>`destroy[_n]`
  </tr>
  <tr>
    <td>`mismatch`
    <td>`remove`
    <td>`partial_sort`
    <td>`set_difference`
    <td>
  </tr>
  <tr>
    <td>`equal`
    <td>`remove_if`
    <td>`partial_sort_copy`
    <td>`set_symmetric_difference`
    <td>
  </tr>
</table>

### Algorithms in `std::ranges` namespace only ### {#only_in_std_ranges}

The algorithms below are easy to add because they are either expressible via existing parallel algorithms or
an analogue with very close semantics exists:

<table>
  <tr>
    <th>`std::ranges` algorithms to add
    <th>`std` algorithms used as the guidance
  </tr>
  <tr>
    <td>`contains`
    <td>`find`
  </tr>
  <tr>
    <td>`contains_subrange`
    <td>`search`
  </tr>
  <tr>
    <td>`find_last`
    <td>`find`
  </tr>
  <tr>
    <td>`find_last_if`
    <td>`find_if`
  </tr>
  <tr>
    <td>`find_last_if_not`
    <td>`find_if_not`
  </tr>
  <tr>
    <td>`starts_with`
    <td>`mismatch`
  </tr>
  <tr>
    <td>`ends_with`
    <td>`equal`
  </tr>
  <tr>
    <td>`min`
    <td>`min_element`
  </tr>
  <tr>
    <td>`max`
    <td>`max_element`
  </tr>
  <tr>
    <td>`minmax`
    <td>`minmax_element`
  </tr>
</table>

## Out-of-scope ## {#out_of_scope}

### The counterparts of exiting algorithms without `ExecutionPolicy` ### {#without_exec_policy_counterpart}

Below we list the algorithms below without `ExecutionPolicy` in C++17 and where `ExecutionPolicy` parameter doesn't seem
to add value:

- `push_heap`
- `pop_heap`
- `sort_heap`
- `next_permutation`
- `prev_permutation`
- `lower_bound`
- `upper_bound`
- `equal_range`
- `binary_search`
- `partition_point`

Below we list the algorithms below without `ExecutionPolicy` in C++17, where `ExecutionPolicy` parameter might make sense
but requires deeper investigation:

- `iota`
- `make_heap`
- `is_permutation`
- `copy_backward`
- `move_backward`
- `sample` (RNG specific)
- `shuffle` (RNG specific)

Below we list `std::ranges` only algorithms where we don't add the `ExecutionPolicy` parameter:

- `fold_left`
- `fold_left_first`
- `fold_right`
- `fold_right_last`
- `fold_left_with_iter`
- `fold_left_first_with_iter`
- `generate_random` (RNG specific, `ExecutionPolicy` parameter was rejected during [@P1068R11] review)

### Absence of some serial range-based algorithms ### {#serial_range_based_absence}

We understand that some useful algorithms do not yet exist in `std::ranges`, for example, most of generalized numeric
operations [numeric.ops]{- .sref}. The goal of this paper is however limited to
adding overloads with `ExecutionPolicy`  to the existing algorithms in the `std::ranges` namespace. Any follow-up paper
that adds `<numeric>` algorithms to `std::ranges` should also consider adding dedicated overloads with `ExecutionPolicy`.

### Use of views with parallel algorithms ### {#views_out_of_scope}

As a general principle, if a view satisfies the _`sized-random-access-range`_ concept, it can be used with parallel
range algorithms; the same applies to a view pipeline. There are additional questions to explore, and it is possible
that some views - standard or custom - cannot be safely used in a parallel context. It is not new or unique to the proposed
parallel range algorithms but also applies if view iterators are passed to the existing C++17 parallel algorithms.

We think that these questions have no direct impact on the proposed design, and should better be considered in a follow-up
paper. We present our initial analysis and exploration scope in the [](#parallelism_and_views) subsection below.

# Implementation experience # {#impl_exp}

The oneAPI DPC++ Library (oneDPL) [developer guide](https://uxlfoundation.github.io/oneDPL/parallel_api/parallel_range_algorithms.html)
covers parallel range algorithms we’ve implemented so far. The oneAPI specification provides
[formal signatures](https://oneapi-spec.uxlfoundation.org/specifications/oneapi/v1.4-rev-1/elements/onedpl/source/parallel_api/parallel_range_api)
of these algorithms. The implementation supports execution policies for CPUs (semantically aligned with the C++ standard)
and for SYCL devices, and it works with a subset of the standard C++ views.

We use the range-as-the-output approach where applicable: in `transform`, `copy`, `copy_if`, and `merge`.

We don't foresee any issues with implementability for the rest of the proposed parallel algorithms because all of them were
already implemented in C++17 and new APIs that we propose are expressible via the existing ones.

# Further work # {#further_work}

## Parallelism and Views ## {#parallelism_and_views}

We would like to provide detailed analysis of the possibility to use views in parallel contexts and potential consequences
of such use. Some investigation was done by one of the authors in [@P3159R0], however it is primarily
about the ability to parallelize processing of data represented by various views. We want to look at other aspects.

The key concern is, of course, data races. Even though parallel range algorithms require random access ranges,
data races are possible if a range has some state that can be modified by *element access functions*
[algorithms.parallel.defns]{- .sref}.

The first question to answer is: which, if any, of the view types in the C++ standard library satisfy the requirements
of parallel range algorithms yet cannot be safely used. We know from practice that many views are safe to use.
The [mentioned](#impl_exp) oneDPL implementation has been tested with
[several standard view types](https://uxlfoundation.github.io/oneDPL/parallel_api/parallel_range_algorithms.html#supported-range-views).
Views are also sometimes used via iterators with the C++17 parallel algorithms; see examples in [](#motivation).
However, certain views are known to cache some state (for example, `reverse_view` caches the result of `begin()` even
when its base is a `random_access_range`), and some have the state shared by view iterators (such as `transform_view`,
where iterators keep pointers to the function object that is stored in the view itself). Possible implications of that
need to be carefully studied, taking into account both range-based and C++17 parallel algorithms.

The second question is about which user-specified view arguments should be considered element access functions.
An obvious example is, again, `transform_view` that applies a function to each element of its base range.
We would like to check if the current description in [algorithms.parallel.defns]{- .sref} suitable for classic iterators
over data structures is sufficient also for views and their iterators, and if not, extend it as needed.

Looking from a different angle, it makes sense to consider how C++ ranges, and views in particular, might be used
in parallel contexts other than the standard algorithms. While iterators are a powerful abstraction that allows
algorithms to operate with a variety of data structures, random-access containers as well as many views allow
referring to data elements by index via `operator[]`, and this is often the preferred way, especially in parallel
programming. Also, data access patterns of some computations might depend on the data itself or spread over
the whole range, in which case it makes more sense for executing threads to obtain a reference to the data container
or a copy of the view, rather than an iterator. As an additional benefit, copying views to each thread
would reduce the risk of modifying a shared view state (though not eliminate it; see an example below).

It might therefore be useful to conditionally extend operations on ranges allowed for parallel algorithms beyond
`std::ranges::begin`, `end`, and `size` which are guaranteed by the _`sized-random-access-range`_ concept.
While not strictly required to implement this proposal, such extensions may provide implementers with more freedom,
which could be quite useful e.g. for accelerated execution on GPUs. The standard would also provide general
guidance for C++ developers on the use of ranges by multiple threads of execution.

To better define the desired extensions, we should also analyze which view pipelines would be thread-safe
for these operations. Consider the following example:

```cpp
std::vector input{1,2,3,4};
auto pipeline = input | std::views::reverse;

// Wrap pipeline with ref_view
std::ranges::ref_view ref(pipeline);

// The resulting pipeline of ref is std::ranges::ref_view<std::ranges::reverse_view<std::ranges::ref_view<std::vector<...>>>>>
```

If we then use `ref` in parallel algorithms, copying it potentially leads to data races because every copy will operate
on the same instance of `reverse_view`, which `begin` method is not thread safe as its result is cached.

As all these questions go beyond just the parallel range algorithms and are mainly orthogonal to their design,
we plan to consider them in detail in a separate paper.

# Formal wording # {#formal_wording}

## Modify the `__cpp_lib_parallel_algorithm` macro in [version.syn]{- .sref} ## {#modify_version_syn}

```diff
- #define __cpp_lib_parallel_algorithm                201603L // also in <algorithm>, <numeric>
+ #define __cpp_lib_parallel_algorithm                20XXXXL // also in <algorithm>, <numeric>, <memory>
```

## Modify [ranges.syn]{- .sref} ## {#modify_ranges_syn}

```diff
  template<class T>
    concept constant_range = @_see below_@;                                             @_// freestanding_@
+
+  template<class R>
+    concept @_sized-random-access-range_@ = @_see below_@;    @_// exposition only_@
```

## Add an exposition-only concept to [range.refinements]{- .sref} ## {#modify_range_refinements}

[7]{.pnum} The `constant_range` concept specifies the requirements of a `range` type whose elements are not modifiable.

```cpp
template<class T>
  concept constant_range =
    input_range<T> && constant-iterator<iterator_t<T>>;
```

::: add
[X]{.pnum} The exposition-only concept _`sized-random-access-range`_ specifies the requirements of a `range` type
that is sized and allows random access to its elements.

```cpp
  template<class R>
    concept @_sized-random-access-range_@ =     @_// exposition only_@
      random_access_range<R> && sized_range<R>;
```
[*Note X*: This concept constrains some parallel algorithm overloads; see [algorithms]{- .sref} — *end note*]
:::

## Modify [algorithms.requirements]{- .sref} ## {#modify_alg_reqs}

[11]{.pnum} In the description of the algorithms, operator `+` is used for some of the iterator categories for which it does
not have to be defined. In these cases the semantics of `a + n` are the same as those of
```cpp
auto tmp = a;
for (; n < 0; ++n) --tmp;
for (; n > 0; --n) ++tmp;
return tmp;
```
Similarly, operator `-` is used for some combinations of iterators and sentinel types for which it does not have to be
defined. If [`a`, `b`) denotes a range, the semantics of `b - a` in these cases are the same as those of
```cpp
iter_difference_t<decltype(a)> n = 0;
for (auto tmp = a; tmp != b; ++tmp) ++n;
return n;
```
and if [`b`, `a`) denotes a range, the same as those of
```cpp
iter_difference_t<decltype(b)> n = 0;
for (auto tmp = b; tmp != a; ++tmp) --n;
return n;
```
::: add
For each iterator `i` and sentinel `s` produced from a range `r`, the semantics of `s - i`
has the same type, value, and value category as `ranges::distance(i, s)`.

[The implementation can use `ranges::distance(r)` when that produces the same value as `ranges::distance(i, s)`.
This can be more efficient for sized ranges.]{.note}
:::

[12]{.pnum} In the description of the algorithms, given an iterator a whose difference type is `D`, and an expression `n` of
integer-like type other than *cv* `D`, the semantics of `a + n` and `a - n` are, respectively, those of `a + D(n)` and
`a - D(n)`.

[13]{.pnum} In the description of algorithm return values, a sentinel value `s` denoting the end of a range [`i`, `s`) is sometimes returned
where an iterator is expected. In these cases, the semantics are as if the sentinel is converted into an iterator using
`ranges​::​next(i, s)`.

[14]{.pnum} Overloads of algorithms that take range arguments ([range.range]) behave as if they are implemented by[ calling
ranges​::​begin and ranges​::​end on the range(s) and]{.rm} dispatching to the overload in namespace `ranges` that takes separate
iterator and sentinel arguments[.]{.rm}[, where for each range argument `r`]{.add}

::: add
- [14.1]{.pnum} a corresponding iterator argument is initialized with `ranges::begin(r)` and
- [14.2]{.pnum} a corresponding sentinel argument is initialized with `ranges::end(r)`, or `ranges::next(ranges::begin(r), ranges::end(r))`
  if the type of `r` models `forward_range` and computing `ranges::next` meets the specified complexity requirements.
:::

## Modify [algorithms.parallel.defns]{- .sref} ## {#modify_alg_parallel_def}

[2]{.pnum} A *parallel algorithm* is a function template listed in this document with
a template parameter named `ExecutionPolicy` [or constrained by the following exposition-only concept:]{.add}

::: add
```cpp
template<class Ep>
concept @_execution-policy_@ = @_// exposition only_@
  is_execution_policy_v<remove_cvref_t<Ep>>;
```

Such a template parameter is termed an *execution policy template parameter*.
:::

[3]{.pnum} [A]{.add} [P]{.rm}[p]{.add}arallel algorithm[s]{.rm} access[es]{.add} objects indirectly accessible via
[their]{.rm}[its]{.add} arguments by invoking the following functions:

- All operations of the categories of the iterators[, sentinels,]{.add} or `mdspan` types that the algorithm is instantiated with.
- Operations on those sequence elements that are required by its specification.
- User-provided [function]{.rm}[invocable]{.add} objects to be applied during the execution of the algorithm, if required by the specification.
- Operations on those [function]{.rm}[invocable]{.add} objects required by the specification.

## Modify [algorithms.parallel.user]{- .sref} ## {#modify_alg_parallel_user}

[1]{.pnum} Unless otherwise specified, [function]{.rm}[invocable]{.add} objects passed into parallel algorithms as objects
of a type [denoted by a template parameter named]{.add} `Predicate`, `BinaryPredicate`, `Compare`, `UnaryOperation`,
`BinaryOperation`, `BinaryOperation1`, `BinaryOperation2`, `BinaryDivideOp`, [or constrained by a concept that subsumes
`regular_invocable`]{.add} and the operators used by the analogous overloads to these parallel algorithms that are formed by an invocation
with the specified default predicate or operation (where applicable) shall not directly or indirectly modify objects via their arguments,
nor shall they rely on the identity of the provided objects.

## Modify [algorithms.parallel.exec]{- .sref} ## {#modify_alg_parallel_exec}

[1]{.pnum} [Parallel algorithms have template parameters named `ExecutionPolicy` ([execpol]{- .sref})
which describe]{.rm}[An execution policy template parameter describes]{.add} the manner in which the execution of
[these]{.rm} [a parallel]{.add} algorithm[s]{.rm} may be parallelized and the manner in which [they]{.rm}[it]{.add}
appl[y]{.rm}[ies]{.add} the element access functions.

## Modify [algorithms.parallel.exceptions]{- .sref} ## {#modify_alg_parallel_exceptions}

[2]{.pnum} During the execution of a parallel algorithm, if the invocation of an element access function exits
via an uncaught exception, the behavior is determined by the [`ExecutionPolicy`]{.rm}[execution policy]{.add}.

## Modify [algorithms.parallel.overloads]{- .sref} ## {#modify_alg_parallel_overloads}

[1]{.pnum} Parallel algorithms are algorithm overloads. Each parallel algorithm overload has an additional [template
type parameter named `ExecutionPolicy`, which is the first template parameter. Additionally, each parallel
algorithm overload has an additional]{.rm} function parameter [P]{.add} of type [`ExecutionPolicy&&`]{.rm} [`T&&`, as
the first function parameter, where `T` is the execution policy template parameter]{.add}[, which is the first function
parameter]{.rm}.

[*Note 1*: Not all algorithms have parallel algorithm overloads. — *end note*]

[2]{.pnum} Unless otherwise specified, the semantics of [`ExecutionPolicy`]{.rm}[calling a parallel]{.add} algorithm
overload[s]{.rm} are identical to [their overloads without]{.rm}[calling the corresponding algorithm overload without the
parameter P, using all but the first argument]{.add}.

[3]{.pnum} Unless otherwise specified, the complexity requirements of [`ExecutionPolicy`]{.rm}[a parallel]{.add} algorithm
overload[s]{.rm} are relaxed from the complexity requirements of the [corresponding]{.add} overload[s]{.rm} without
[the parameter P]{.add} as follows: when the guarantee says “at most *expr*” or “exactly *expr*” and does not specify the
number of assignments or swaps, and *expr* is not already expressed with *O*() notation, the complexity of the algorithm
shall be *O*(*expr*).

[4]{.pnum} [A]{.add} [P]{.rm}[p]{.add}arallel algorithm[s]{.rm} [with a template parameter named `ExecutionPolicy`]{.add}
shall not participate in overload resolution unless [`is_execution_policy_v<remove_cvref_t<ExecutionPolicy>>` is `true`.]{.rm}
[that template parameter satisfies *`execution-policy`*]{.add}.

## Modify [algorithm.syn]{- .sref} ## {#modify_alg_syn}

```diff
namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr bool all_of(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool all_of(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+          indirect_unary_predicate<projected<I, Proj>> Pred>
+    bool all_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+          indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    bool all_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr bool any_of(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool any_of(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+          indirect_unary_predicate<projected<I, Proj>> Pred>
+    bool any_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+          indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    bool any_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr bool none_of(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool none_of(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+          indirect_unary_predicate<projected<I, Proj>> Pred>
+    bool none_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+          indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    bool none_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr bool contains(I first, S last, const T& value, Proj proj = {});
  template<input_range R, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires
      indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
    constexpr bool contains(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+           class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    bool contains(Ep&& exec, I first, S last, const T& value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    bool contains(Ep&& exec, R&& r, const T& value, Proj proj = {});    @_// freestanding-deleted_@

  template<forward_iterator I1, sentinel_for<I1> S1,
            forward_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                      Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<forward_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool contains_subrange(R1&& r1, R2&& r2,
                                      Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+          random_access_iterator I2, sized_sentinel_for<I2> S2,
+          class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    bool contains_subrange(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                            Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+          class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    bool contains_subrange(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
+                            Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class F>
    using for_each_result = in_fun_result<I, F>;

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirectly_unary_invocable<projected<I, Proj>> Fun>
    constexpr for_each_result<I, Fun>
      for_each(I first, S last, Fun f, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
    constexpr for_each_result<borrowed_iterator_t<R>, Fun>
      for_each(R&& r, Fun f, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+          indirectly_unary_invocable<projected<I, Proj>> Fun>
+    I for_each(Ep&& exec, I first, S last, Fun f, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+          indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
+    borrowed_iterator_t<R>
+      for_each(Ep&& exec, R&& r, Fun f, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class F>
    using for_each_n_result = in_fun_result<I, F>;

  template<input_iterator I, class Proj = identity,
            indirectly_unary_invocable<projected<I, Proj>> Fun>
    constexpr for_each_n_result<I, Fun>
      for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, class Proj = identity,
+          indirectly_unary_invocable<projected<I, Proj>> Fun>
+    I for_each_n(Ep&& exec, I first, iter_difference_t<I> n, Fun f, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr I find(I first, S last, const T& value, Proj proj = {});
  template<input_range R, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T*>
    constexpr borrowed_iterator_t<R>
      find(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    I find(Ep&& exec, I first, S last, const T& value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R,
+            class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    borrowed_iterator_t<R> find(Ep&& exec, R&& r, const T& value, Proj proj = {});    @_// freestanding-deleted_@

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_iterator_t<R>
      find_if(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    I find_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    borrowed_iterator_t<R> find_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_iterator_t<R>
      find_if_not(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    I find_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    borrowed_iterator_t<R> find_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity, class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr subrange<I> find_last(I first, S last, const T& value, Proj proj = {});
  template<forward_range R, class Proj = identity, class T = projected_value_t<I, Proj>>
    requires
      indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
    constexpr borrowed_subrange_t<R> find_last(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    subrange<I> find_last(Ep&& exec, I first, S last, const T& value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    borrowed_subrange_t<R> find_last(Ep&& exec, R&& r, const T& value, Proj proj = {});    @_// freestanding-deleted_@

  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr subrange<I> find_last_if(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_subrange_t<R> find_last_if(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+           indirect_unary_predicate<projected<I, Proj>> Pred>
+    subrange<I> find_last_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+           indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    borrowed_subrange_t<R> find_last_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@

  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr subrange<I> find_last_if_not(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr borrowed_subrange_t<R> find_last_if_not(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    subrange<I> find_last_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    borrowed_subrange_t<R> find_last_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr subrange<I1>
      find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<forward_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr borrowed_subrange_t<R1>
      find_end(R1&& r1, R2&& r2, Pred pred = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1, random_access_iterator I2,
+            sized_sentinel_for<I2> S2, class Pred = ranges::equal_to, class Proj1 = identity,
+            class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    subrange<I1> find_end(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    borrowed_subrange_t<R1> find_end(Ep&& exec, R1&& r1, R2&& r2,
+                                      Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr borrowed_iterator_t<R1>
      find_first_of(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    I1 find_first_of(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                      Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    borrowed_iterator_t<R1> find_first_of(Ep&& exec, R1&& r1, R2&& r2,
+                                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_binary_predicate<projected<I, Proj>,
                                      projected<I, Proj>> Pred = ranges::equal_to>
    constexpr I adjacent_find(I first, S last, Pred pred = {},
                              Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_binary_predicate<projected<iterator_t<R>, Proj>,
                                      projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
    constexpr borrowed_iterator_t<R>
      adjacent_find(R&& r, Pred pred = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_binary_predicate<projected<I, Proj>, projected<I, Proj>> Pred = ranges::equal_to>
+    I adjacent_find(Ep&& exec, I first, S last, Pred pred = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_binary_predicate<projected<iterator_t<R>, Proj>, projected<iterator_t<R>, Proj>> Pred
+             = ranges::equal_to>
+    borrowed_iterator_t<R> adjacent_find(Ep&& exec, R&& r, Pred pred = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr iter_difference_t<I>
      count(I first, S last, const T& value, Proj proj = {});
  template<input_range R, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T*>
    constexpr range_difference_t<R>
      count(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    iter_difference_t<I> count(Ep&& exec, I first, S last, const T& value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    range_difference_t<R> count(Ep&& exec, R&& r, const T& value, Proj proj = {});    @_// freestanding-deleted_@

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr iter_difference_t<I>
      count_if(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr range_difference_t<R>
      count_if(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    iter_difference_t<I> count_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    range_difference_t<R> count_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I1, class I2>
    using mismatch_result = in_in_result<I1, I2>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr mismatch_result<I1, I2>
      mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
      mismatch(R1&& r1, R2&& r2, Pred pred = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    mismatch_result<I1, I2>
+      mismatch(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
+      mismatch(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                          Pred pred = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool equal(R1&& r1, R2&& r2, Pred pred = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    bool equal(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    bool equal(Ep&& exec, R1&& r1, R2&& r2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
            sentinel_for<I2> S2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr subrange<I1>
      search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
              Proj1 proj1 = {}, Proj2 proj2 = {});
  template<forward_range R1, forward_range R2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr borrowed_subrange_t<R1>
      search(R1&& r1, R2&& r2, Pred pred = {},
              Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+      subrange<I1>
+        search(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+      borrowed_subrange_t<R1>
+        search(Ep&& exec, R1&& r1, R2&& r2,
+                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S,
            class Pred = ranges::equal_to, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirectly_comparable<I, const T*, Pred, Proj>
    constexpr subrange<I>
      search_n(I first, S last, iter_difference_t<I> count,
                const T& value, Pred pred = {}, Proj proj = {});
  template<forward_range R, class Pred = ranges::equal_to,
            class Proj = identity, class T = projected_value_t<I, Proj>>
    requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
    constexpr borrowed_subrange_t<R>
      search_n(R&& r, range_difference_t<R> count,
                const T& value, Pred pred = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Pred = ranges::equal_to, class Proj = identity,
+            class T = projected_value_t<I, Proj>>
+    requires indirectly_comparable<I, const T*, Pred, Proj>
+      subrange<I>
+        search_n(Ep&& exec, I first, S last, iter_difference_t<I> count,
+                  const T& value, Pred pred = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Pred = ranges::equal_to,
+            class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
+      borrowed_subrange_t<R>
+        search_n(Ep&& exec, R&& r, range_difference_t<R> count,
+                  const T& value, Pred pred = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  // [alg.starts.with], starts with
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool starts_with(R1&& r1, R2&& r2, Pred pred = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    bool starts_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                              Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    bool starts_with(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@

  // [alg.ends.with], ends with
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires (forward_iterator<I1> || sized_sentinel_for<S1, I1>) &&
              (forward_iterator<I2> || sized_sentinel_for<S2, I2>) &&
              indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Pred = ranges::equal_to,
            class Proj1 = identity, class Proj2 = identity>
    requires (forward_range<R1> || sized_range<R1>) &&
              (forward_range<R2> || sized_range<R2>) &&
              indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool ends_with(R1&& r1, R2&& r2, Pred pred = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
+    bool ends_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                    Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
+    bool ends_with(Ep&& exec, R1&& r1, R2&& r2,
+                    Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using copy_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr copy_result<I, O>
      copy(I first, S last, O result);
  template<input_range R, weakly_incrementable O>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr copy_result<borrowed_iterator_t<R>, O>
      copy(R&& r, O result);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>
+    requires indirectly_copyable<I, O>
+    copy_result<I, O> copy(Ep&& exec, I first, S last, O result, OutS result_last);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
+    copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      copy(Ep&& exec, R&& r, OutR&& result_r);    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using copy_n_result = in_out_result<I, O>;

  template<input_iterator I, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr copy_n_result<I, O>
      copy_n(I first, iter_difference_t<I> n, O result);

+  template<@_execution-policy_@ Ep, random_access_iterator I, random_access_iterator O,
+            sized_sentinel_for<O> OutS>
+    requires indirectly_copyable<I, O>
+    copy_n_result<I, O>
+      copy_n(Ep&& exec, I first, iter_difference_t<I> n, O result, OutS result_last);    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using copy_if_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_copyable<I, O>
    constexpr copy_if_result<I, O>
      copy_if(I first, S last, O result, Pred pred, Proj proj = {});
  template<input_range R, weakly_incrementable O, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr copy_if_result<borrowed_iterator_t<R>, O>
      copy_if(R&& r, O result, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS,
+            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    requires indirectly_copyable<I, O>
+    copy_if_result<I, O>
+      copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
+               Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
+            class Proj = identity, indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
+    copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using move_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_movable<I, O>
    constexpr move_result<I, O>
      move(I first, S last, O result);
  template<input_range R, weakly_incrementable O>
    requires indirectly_movable<iterator_t<R>, O>
    constexpr move_result<borrowed_iterator_t<R>, O>
      move(R&& r, O result);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>
+    requires indirectly_movable<I, O>
+    move_result<I, O> move(Ep&& exec, I first, S last, O result, OutS result_last);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR>
+    requires indirectly_movable<iterator_t<R>, iterator_t<OutR>>
+    move_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      move(Ep&& exec, R&& r, OutR&& result_r);    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I1, class I2>
    using swap_ranges_result = in_in_result<I1, I2>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2>
    requires indirectly_swappable<I1, I2>
    constexpr swap_ranges_result<I1, I2>
      swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
  template<input_range R1, input_range R2>
    requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
    constexpr swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
      swap_ranges(R1&& r1, R2&& r2);

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2>
+    requires indirectly_swappable<I1, I2>
+    swap_ranges_result<I1, I2>
+      swap_ranges(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2>
+    requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
+    swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
+      swap_ranges(Ep&& exec, R1&& r1, R2&& r2);    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using unary_transform_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
            copy_constructible F, class Proj = identity>
    requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
    constexpr unary_transform_result<I, O>
      transform(I first1, S last1, O result, F op, Proj proj = {});
  template<input_range R, weakly_incrementable O, copy_constructible F,
            class Proj = identity>
    requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
    constexpr unary_transform_result<borrowed_iterator_t<R>, O>
      transform(R&& r, O result, F op, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS,
+            copy_constructible F, class Proj = identity>
+    requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
+    unary_transform_result<I, O>
+      transform(Ep&& exec, I first, S last, O result, OutS result_last,
+                 F op, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
+           copy_constructible F, class Proj = identity>
+    requires indirectly_writable<iterator_t<OutR>, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
+    unary_transform_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      transform(Ep&& exec, R&& r, OutR&& result_r, F op, Proj proj = {});    @_// freestanding-deleted_@

  template<class I1, class I2, class O>
    using binary_transform_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, copy_constructible F, class Proj1 = identity,
            class Proj2 = identity>
    requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
                                            projected<I2, Proj2>>>
    constexpr binary_transform_result<I1, I2, O>
      transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            copy_constructible F, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
                                            projected<iterator_t<R2>, Proj2>>>
    constexpr binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
      transform(R1&& r1, R2&& r2, O result,
                F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            random_access_iterator O,  sized_sentinel_for<O> OutS,
+            copy_constructible F, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>, projected<I2, Proj2>>>
+    binary_transform_result<I1, I2, O>
+      transform(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, O result,
+                 OutS result_last, F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            @_sized-random-access-range_@ OutR, copy_constructible F, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_writable<iterator_t<OutR>,
+               indirect_result_t<F&, projected<iterator_t<R1>, Proj1>, projected<iterator_t<R2>, Proj2>>>
+    binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
+      transform(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
+                 F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T1 = projected_value_t<I, Proj>, class T2 = T1>
    requires indirectly_writable<I, const T2&> &&
              indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
    constexpr I
      replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
  template<input_range R, class Proj = identity,
            class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
    requires indirectly_writable<iterator_t<R>, const T2&> &&
              indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T1*>
    constexpr borrowed_iterator_t<R>
      replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = T1>
+    requires indirectly_writable<I, const T2&> &&
+             indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
+    I replace(Ep&& exec, I first, S last,
+               const T1& old_value, const T2& new_value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
+    requires indirectly_writable<iterator_t<R>, const T2&> &&
+              indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
+    borrowed_iterator_t<R>
+      replace(Ep&& exec, R&& r,
+               const T1& old_value, const T2& new_value, Proj proj = {});    @_// freestanding-deleted_@

  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_writable<I, const T&>
    constexpr I replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
  template<input_range R, class Proj = identity, class T = projected_value_t<I, Proj>,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_writable<iterator_t<R>, const T&>
    constexpr borrowed_iterator_t<R>
      replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
+            class T = projected_value_t<I, Proj>,
+            indirect_unary_predicate<projected<I, Proj>> Pred>
+    requires indirectly_writable<I, const T&>
+    I replace_if(Ep&& exec, I first, S last, Pred pred,
+                  const T& new_value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            class T = projected_value_t<iterator_t<R>, Proj>,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires indirectly_writable<iterator_t<R>, const T&>
+    borrowed_iterator_t<R>
+      replace_if(Ep&& exec, R&& r, Pred pred,
+                  const T& new_value, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using replace_copy_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, class O,
            class Proj = identity,
            class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
    requires indirectly_copyable<I, O> &&
              indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
              output_iterator<O, const T2&>
    constexpr replace_copy_result<I, O>
      replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                    Proj proj = {});
  template<input_range R, class O, class Proj = identity,
            class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = iter_value_t<O>>
    requires indirectly_copyable<iterator_t<R>, O> &&
              indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T1*> &&
              output_iterator<O, const T2&>
    constexpr replace_copy_result<borrowed_iterator_t<R>, O>
      replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                    Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>,
+            class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
+    requires indirectly_copyable<I, O> &&
+              indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
+              indirectly_writable<O, const T2&>
+    replace_copy_result<I, O>
+      replace_copy(Ep&& exec, I first, S last, O result, OutS result_last,
+                    const T1& old_value, const T2& new_value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
+            class Proj = identity, class T1 = projected_value_t<iterator_t<R>, Proj>,
+            class T2 = range_value_t<OutR>>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
+              indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*> &&
+              indirectly_writable<iterator_t<OutR>, const T2&>
+    replace_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      replace_copy(Ep&& exec, R&& r, OutR&& result_r,
+                    const T1& old_value, const T2& new_value, Proj proj = {});    @_// freestanding-deleted_@

  template<class I, class O>
    using replace_copy_if_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, class O, class T = iter_value_t<O>
            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_copyable<I, O> && output_iterator<O, const T&>
    constexpr replace_copy_if_result<I, O>
      replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                      Proj proj = {});
  template<input_range R, class O, class T = iter_value_t<O>, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_copyable<iterator_t<R>, O> && output_iterator<O, const T&>
    constexpr replace_copy_if_result<borrowed_iterator_t<R>, O>
      replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                      Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>, class T = iter_value_t<O>,
+            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    requires indirectly_copyable<I, O> && indirectly_writable<O, const T&>
+    replace_copy_if_result<I, O>
+      replace_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
+                       Pred pred, const T& new_value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
+            class T = range_value_t<OutR>, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
+             indirectly_writable<iterator_t<OutR>, const T&>
+    replace_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      replace_copy_if(Ep&& exec, R&& r, OutR&& result_r,
+                       Pred pred, const T& new_value, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class O, sentinel_for<O> S, class T = iter_value_t<O>>
    requires output_iterator<O, const T&>
    constexpr O fill(O first, S last, const T& value);
  template<class R, class T = range_value_t<R>>
    requires output_range<R, const T&>
    constexpr borrowed_iterator_t<R> fill(R&& r, const T& value);
  template<class O, class T = iter_value_t<O>>
    requires output_iterator<O, const T&>
    constexpr O fill_n(O first, iter_difference_t<O> n, const T& value);

+ template<@_execution-policy_@ Ep, random_access_iterator O, sized_sentinel_for<O> S,
+           class T = iter_value_t<O>>
+   requires indirectly_writable<O, const T&>
+   O fill(Ep&& exec, O first, S last, const T& value);    @_// freestanding-deleted_@
+ template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class T = range_value_t<R>>
+   requires indirectly_writable<iterator_t<R>, const T&>
+   borrowed_iterator_t<R> fill(Ep&& exec, R&& r, const T& value);    @_// freestanding-deleted_@
+ template<@_execution-policy_@ Ep, random_access_iterator O, class T = iter_value_t<O>>
+   requires indirectly_writable<O, const T&>
+   O fill_n(Ep&& exec, O first, iter_difference_t<O> n, const T& value);    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_or_output_iterator O, sentinel_for<O> S, copy_constructible F>
    requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
    constexpr O generate(O first, S last, F gen);
  template<class R, copy_constructible F>
    requires invocable<F&> && output_range<R, invoke_result_t<F&>>
    constexpr borrowed_iterator_t<R> generate(R&& r, F gen);
  template<input_or_output_iterator O, copy_constructible F>
    requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
    constexpr O generate_n(O first, iter_difference_t<O> n, F gen);
+  template<@_execution-policy_@ Ep, random_access_iterator O, sized_sentinel_for<O> S,
+            copy_constructible F>
+    requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
+    O generate(Ep&& exec, O first, S last, F gen);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, copy_constructible F>
+    requires invocable<F&> && indirectly_writable<iterator_t<R>, invoke_result_t<F&>>
+    borrowed_iterator_t<R> generate(Ep&& exec, R&& r, F gen);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, random_access_iterator O, copy_constructible F>
+    requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
+    O generate_n(Ep&& exec, O first, iter_difference_t<O> n, F gen);    @_// freestanding-deleted_@
}

namespace ranges {
  template<permutable I, sentinel_for<I> S, class Proj = identity,
            class T = projected_value_t<I, Proj>>
    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr subrange<I> remove(I first, S last, const T& value, Proj proj = {});
  template<forward_range R, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires permutable<iterator_t<R>> &&
              indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T*>
    constexpr borrowed_subrange_t<R>
      remove(R&& r, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity, class T = projected_value_t<I, Proj>>
+    requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    subrange<I> remove(Ep&& exec, I first, S last, const T& value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            class T = projected_value_t<iterator_t<R>, Proj>>
+    requires permutable<iterator_t<R>> &&
+             indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    borrowed_subrange_t<R> remove(Ep&& exec, R&& r, const T& value, Proj proj = {});    @_// freestanding-deleted_@

  template<permutable I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr subrange<I> remove_if(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R>
      remove_if(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    subrange<I> remove_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires permutable<iterator_t<R>>
+    borrowed_subrange_t<R> remove_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using remove_copy_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
            class Proj = identity, class T = projected_value_t<I, Proj>>
    requires indirectly_copyable<I, O> &&
              indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
    constexpr remove_copy_result<I, O>
      remove_copy(I first, S last, O result, const T& value, Proj proj = {});
  template<input_range R, weakly_incrementable O, class Proj = identity,
            class T = projected_value_t<iterator_t<R>, Proj>>
    requires indirectly_copyable<iterator_t<R>, O> &&
              indirect_binary_predicate<ranges::equal_to,
                                        projected<iterator_t<R>, Proj>, const T*>
    constexpr remove_copy_result<borrowed_iterator_t<R>, O>
      remove_copy(R&& r, O result, const T& value, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>,
+            class Proj = identity, class T = projected_value_t<I, Proj>>
+    requires indirectly_copyable<I, O> &&
+              indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
+    remove_copy_result<I, O>
+      remove_copy(Ep&& exec, I first, S last, O result,  OutS result_last,
+                   const T& value, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
+            class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
+              indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
+    remove_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      remove_copy(Ep&& exec, R&& r, OutR&& result_r, const T& value, Proj proj = {});    @_// freestanding-deleted_@

  template<class I, class O>
    using remove_copy_if_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_copyable<I, O>
    constexpr remove_copy_if_result<I, O>
      remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
  template<input_range R, weakly_incrementable O, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr remove_copy_if_result<borrowed_iterator_t<R>, O>
      remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>,
+            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    requires indirectly_copyable<I, O>
+    remove_copy_if_result<I, O>
+      remove_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
+                      Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
+            class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
+    remove_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      remove_copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<permutable I, sentinel_for<I> S, class Proj = identity,
            indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
    constexpr subrange<I> unique(I first, S last, C comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R>
      unique(R&& r, C comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity,
+            indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
+    requires permutable<I>
+    subrange<I> unique(Ep&& exec, I first, S last, C comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
+    requires permutable<iterator_t<R>>
+    borrowed_subrange_t<R> unique(Ep&& exec, R&& r, C comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using unique_copy_result = in_out_result<I, O>;

  template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
            indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
    requires indirectly_copyable<I, O> &&
              (forward_iterator<I> ||
              (input_iterator<O> && same_as<iter_value_t<I>, iter_value_t<O>>) ||
              indirectly_copyable_storable<I, O>)
    constexpr unique_copy_result<I, O>
      unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
  template<input_range R, weakly_incrementable O, class Proj = identity,
            indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
    requires indirectly_copyable<iterator_t<R>, O> &&
              (forward_iterator<iterator_t<R>> ||
              (input_iterator<O> && same_as<range_value_t<R>, iter_value_t<O>>) ||
              indirectly_copyable_storable<iterator_t<R>, O>)
    constexpr unique_copy_result<borrowed_iterator_t<R>, O>
      unique_copy(R&& r, O result, C comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>, class Proj = identity,
+            indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
+    requires indirectly_copyable<I, O>
+    unique_copy_result<I, O>
+      unique_copy(Ep&& exec, I first, S last, O result, OutS result_last,
+                   C comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
+            class Proj = identity,
+            indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
+    unique_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      unique_copy(Ep&& exec, R&& r, OutR&& result_r,
+                   C comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<bidirectional_iterator I, sentinel_for<I> S>
    requires permutable<I>
    constexpr I reverse(I first, S last);
  template<bidirectional_range R>
    requires permutable<iterator_t<R>>
    constexpr borrowed_iterator_t<R> reverse(R&& r);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
+    requires permutable<I>
+    I reverse(Ep&& exec, I first, S last);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R>
+    requires permutable<iterator_t<R>>
+    borrowed_iterator_t<R> reverse(Ep&& exec, R&& r);    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using reverse_copy_result = in_out_result<I, O>;

  template<bidirectional_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr reverse_copy_result<I, O>
      reverse_copy(I first, S last, O result);
  template<bidirectional_range R, weakly_incrementable O>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr reverse_copy_result<borrowed_iterator_t<R>, O>
      reverse_copy(R&& r, O result);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>
+    requires indirectly_copyable<I, O>
+    reverse_copy_result<I, O>
+      reverse_copy(Ep&& exec, I first, S last, O result, OutS result_last);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
+    reverse_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      reverse_copy(Ep&& exec, R&& r, OutR&& result_r);    @_// freestanding-deleted_@
}

namespace ranges {
  template<permutable I, sentinel_for<I> S>
    constexpr subrange<I> rotate(I first, I middle, S last);
  template<forward_range R>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R> rotate(R&& r, iterator_t<R> middle);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
+    requires permutable<I>
+    subrange<I> rotate(Ep&& exec, I first, I middle, S last);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R>
+    requires permutable<iterator_t<R>>
+    borrowed_subrange_t<R> rotate(Ep&& exec, R&& r, iterator_t<R> middle);    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using rotate_copy_result = in_out_result<I, O>;

  template<forward_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr rotate_copy_result<I, O>
      rotate_copy(I first, I middle, S last, O result);
  template<forward_range R, weakly_incrementable O>
    requires indirectly_copyable<iterator_t<R>, O>
    constexpr rotate_copy_result<borrowed_iterator_t<R>, O>
      rotate_copy(R&& r, iterator_t<R> middle, O result);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O, sized_sentinel_for<O> OutS>
+    requires indirectly_copyable<I, O>
+    ranges::rotate_copy_result<I, O>
+      ranges::rotate_copy(Ep&& exec, I first, I middle, S last, O result, OutS result_last);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
+    ranges::rotate_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
+      ranges::rotate_copy(Ep&& exec, R&& r, iterator_t<R> middle, OutR&& result_r);    @_// freestanding-deleted_@
}

namespace ranges {
  template<permutable I, sentinel_for<I> S>
    constexpr subrange<I> shift_left(I first, S last, iter_difference_t<I> n);
  template<forward_range R>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R> shift_left(R&& r, range_difference_t<R> n);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
+    requires permutable<I>
+    subrange<I> shift_left(Ep&& exec, I first, S last, iter_difference_t<I> n);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R>
+    requires permutable<iterator_t<R>>
+    borrowed_subrange_t<R> shift_left(Ep&& exec, R&& r, range_difference_t<R> n);    @_// freestanding-deleted_@
}

namespace ranges {
  template<permutable I, sentinel_for<I> S>
    constexpr subrange<I> shift_right(I first, S last, iter_difference_t<I> n);
  template<forward_range R>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R> shift_right(R&& r, range_difference_t<R> n);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
+    requires permutable<I>
+    subrange<I> shift_right(Ep&& exec, I first, S last, iter_difference_t<I> n);    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R>
+    requires permutable<iterator_t<R>>
+    borrowed_subrange_t<R> shift_right(Ep&& exec, R&& r, range_difference_t<R> n);    @_// freestanding-deleted_@
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I
      sort(I first, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      sort(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Comp = ranges::less, class Proj = identity>
+    requires sortable<I, Comp, Proj>
+    I sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less,
+            class Proj = identity>
+    requires sortable<iterator_t<R>, Comp, Proj>
+    borrowed_iterator_t<R> sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      stable_sort(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Comp = ranges::less, class Proj = identity>
+    requires sortable<I, Comp, Proj>
+    I stable_sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less,
+            class Proj = identity>
+    requires sortable<iterator_t<R>, Comp, Proj>
+    borrowed_iterator_t<R> stable_sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I
      partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      partial_sort(R&& r, iterator_t<R> middle, Comp comp = {},
                    Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Comp = ranges::less, class Proj = identity>
+    requires sortable<I, Comp, Proj>
+    I partial_sort(Ep&& exec, I first, I middle, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less,
+            class Proj = identity>
+    requires sortable<iterator_t<R>, Comp, Proj>
+    borrowed_iterator_t<R> partial_sort(Ep&& exec, R&& r, iterator_t<R> middle,
+                                         Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using partial_sort_copy_result = in_out_result<I, O>;

  template<input_iterator I1, sentinel_for<I1> S1,
            random_access_iterator I2, sentinel_for<I2> S2,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
              indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
    constexpr partial_sort_copy_result<I1, I2>
      partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, random_access_range R2, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
              sortable<iterator_t<R2>, Comp, Proj2> &&
              indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
                                        projected<iterator_t<R2>, Proj2>>
    constexpr partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
      partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
                        Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
+              indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
+    partial_sort_copy_result<I1, I2>
+      partial_sort_copy(Ep&& exec, I1 first, S1 last, I2 result_first, S2 result_last,
+                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
+    requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
+              sortable<iterator_t<R2>, Comp, Proj2> &&
+              indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
+                                         projected<iterator_t<R2>, Proj2>>
+    partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
+      partial_sort_copy(Ep&& exec, R1&& r, R2&& result_r, Comp comp = {},
+                         Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr bool is_sorted(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity, indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
+    bool is_sorted(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    bool is_sorted(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr borrowed_iterator_t<R>
      is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity,
+            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
+    I is_sorted_until(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    borrowed_iterator_t<R> is_sorted_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I
      nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Comp = ranges::less, class Proj = identity>
+    requires sortable<I, Comp, Proj>
+    I nth_element(Ep&& exec, I first, I nth, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less,
+            class Proj = identity>
+    requires sortable<iterator_t<R>, Comp, Proj>
+    borrowed_iterator_t<R> nth_element(Ep&& exec, R&& r, iterator_t<R> nth,
+                                        Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool is_partitioned(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+           class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    bool is_partitioned(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+           indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    bool is_partitioned(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<permutable I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    constexpr subrange<I>
      partition(I first, S last, Pred pred, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R>
      partition(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    subrange<I> partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires permutable<iterator_t<R>>
+    borrowed_subrange_t<R> partition(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<bidirectional_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_unary_predicate<projected<I, Proj>> Pred>
    requires permutable<I>
    constexpr subrange<I> stable_partition(I first, S last, Pred pred, Proj proj = {});
  template<bidirectional_range R, class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires permutable<iterator_t<R>>
    constexpr borrowed_subrange_t<R> stable_partition(R&& r, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    requires permutable<I>
+    subrange<I> stable_partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires permutable<iterator_t<R>>
+    borrowed_subrange_t<R> stable_partition(Ep&& exec, R&& r, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O1, class O2>
    using partition_copy_result = in_out_out_result<I, O1, O2>;

  template<input_iterator I, sentinel_for<I> S,
            weakly_incrementable O1, weakly_incrementable O2,
            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
    requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
    constexpr partition_copy_result<I, O1, O2>
      partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                      Proj proj = {});
  template<input_range R, weakly_incrementable O1, weakly_incrementable O2,
            class Proj = identity,
            indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
    requires indirectly_copyable<iterator_t<R>, O1> &&
              indirectly_copyable<iterator_t<R>, O2>
    constexpr partition_copy_result<borrowed_iterator_t<R>, O1, O2>
      partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            random_access_iterator O1, sized_sentinel_for<O1> OutS1,
+            random_access_iterator O2, sized_sentinel_for<O2> OutS2,
+            class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
+    requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
+    partition_copy_result<I, O1, O2>
+      partition_copy(Ep&& exec, I first, S last, O1 out_true, OutS1 last_true,
+                      O2 out_false, OutS2 last_false, Pred pred, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR1,
+           @_sized-random-access-range_@ OutR2, class Proj = identity,
+           indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
+    requires indirectly_copyable<iterator_t<R>, iterator_t<OutR1>> &&
+             indirectly_copyable<iterator_t<R>, iterator_t<OutR2>>
+    partition_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR1>, borrowed_iterator_t<OutR2>>
+      partition_copy(Ep&& exec, R&& r, OutR1&& out_true_r, OutR2&& out_false_r,
+                      Pred pred, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I1, class I2, class O>
    using merge_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,
            class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr merge_result<I1, I2, O>
      merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
            Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
      merge(R1&& r1, R2&& r2, O result,
            Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
+            class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
+    merge_result<I1, I2, O>
+      merge(Ep&& exec, I1 first1, S1 last1,
+             I2 first2, S2 last2, O result, OutS result_last,
+             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            @_sized-random-access-range_@ OutR, class Comp = ranges::less,
+            class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
+    merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
+      merge(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
+             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
            class Proj = identity>
    requires sortable<I, Comp, Proj>
    constexpr I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
  template<bidirectional_range R, class Comp = ranges::less, class Proj = identity>
    requires sortable<iterator_t<R>, Comp, Proj>
    constexpr borrowed_iterator_t<R>
      inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {},
                    Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Comp = ranges::less, class Proj = identity>
+    requires sortable<I, Comp, Proj>
+    I inplace_merge(Ep&& exec, I first, I middle, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less,
+            class Proj = identity>
+    requires sortable<iterator_t<R>, Comp, Proj>
+    borrowed_iterator_t<R> inplace_merge(Ep&& exec, R&& r, iterator_t<R> middle,
+                                          Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Proj1 = identity, class Proj2 = identity,
            indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
              ranges::less>
    constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                            Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Proj1 = identity,
            class Proj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
    constexpr bool includes(R1&& r1, R2&& r2, Comp comp = {},
                            Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Proj1 = identity, class Proj2 = identity,
+            indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less>
+    bool includes(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                   Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            class Proj1 = identity, class Proj2 = identity,
+            indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
+                                       projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
+    bool includes(Ep&& exec, R1&& r1, R2&& r2,
+                   Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I1, class I2, class O>
    using set_union_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_union_result<I1, I2, O>
      set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
      set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+           random_access_iterator I2, sized_sentinel_for<I2> S2,
+           random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
+           class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
+    set_union_result<I1, I2, O>
+      set_union(Ep&& exec, I1 first1, S1 last1,
+                 I2 first2, S2 last2, O result, OutS result_last,
+                 Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            @_sized-random-access-range_@ OutR, class Comp = ranges::less,
+            class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
+    set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
+      set_union(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
+                 Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I1, class I2, class O>
    using set_intersection_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_intersection_result<I1, I2, O>
      set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
      set_intersection(R1&& r1, R2&& r2, O result,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
+            class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
+    set_intersection_result<I1, I2, O>
+      set_intersection(Ep&& exec, I1 first1, S1 last1,
+                        I2 first2, S2 last2, O result, OutS result_last,
+                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            @_sized-random-access-range_@ OutR, class Comp = ranges::less,
+            class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
+    rages::set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
+      set_intersection(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
+                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I, class O>
    using set_difference_result = in_out_result<I, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_difference_result<I1, O>
      set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_difference_result<borrowed_iterator_t<R1>, O>
      set_difference(R1&& r1, R2&& r2, O result,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
+            class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
+    set_difference_result<I1, O>
+      set_difference(Ep&& exec, I1 first1, S1 last1,
+                      I2 first2, S2 last2, O result, OutS result_last,
+                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            @_sized-random-access-range_@ OutR, class Comp = ranges::less,
+            class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
+    set_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<OutR>>
+      set_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
+                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I1, class I2, class O>
    using set_symmetric_difference_result = in_in_out_result<I1, I2, O>;

  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            weakly_incrementable O, class Comp = ranges::less,
            class Proj1 = identity, class Proj2 = identity>
    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_symmetric_difference_result<I1, I2, O>
      set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                Comp comp = {}, Proj1 proj1 = {},
                                Proj2 proj2 = {});
  template<input_range R1, input_range R2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
    requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_symmetric_difference_result<borrowed_iterator_t<R1>,
                                              borrowed_iterator_t<R2>, O>
      set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
+            class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
+    set_symmetric_difference_result<I1, I2, O>
+      set_symmetric_difference(Ep&& exec, I1 first1, S1 last1,
+                                I2 first2, S2 last2, O result, OutS result_last,
+                                Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+           @_sized-random-access-range_@ OutR, class Comp = ranges::less,
+           class Proj1 = identity, class Proj2 = identity>
+    requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
+    set_symmetric_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
+      set_symmetric_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
+                                Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr bool is_heap(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity,
+            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
+    bool is_heap(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    bool is_heap(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
  template<random_access_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr borrowed_iterator_t<R>
      is_heap_until(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity,
+            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
+    I is_heap_until(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    borrowed_iterator_t<R>
+      is_heap_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr const T& min(const T& a, const T& b, Comp comp = {}, Proj proj = {});
  template<copyable T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr T min(initializer_list<T> r, Comp comp = {}, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
    constexpr range_value_t<R>
      min(R&& r, Comp comp = {}, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
+    range_value_t<R>
+      min(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr const T& max(const T& a, const T& b, Comp comp = {}, Proj proj = {});
  template<copyable T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr T max(initializer_list<T> r, Comp comp = {}, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
    constexpr range_value_t<R>
      max(R&& r, Comp comp = {}, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
+    range_value_t<R>
+      max(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class T>
    using minmax_result = min_max_result<T>;

  template<class T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr minmax_result<const T&>
      minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {});
  template<copyable T, class Proj = identity,
            indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
    constexpr minmax_result<T>
      minmax(initializer_list<T> r, Comp comp = {}, Proj proj = {});
  template<input_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
    constexpr minmax_result<range_value_t<R>>
      minmax(R&& r, Comp comp = {}, Proj proj = {});
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+          indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
+    minmax_result<range_value_t<R>>
+      minmax(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr borrowed_iterator_t<R>
      min_element(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity,
+            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
+    I min_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    borrowed_iterator_t<R>
+      min_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr borrowed_iterator_t<R>
      max_element(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity,
+            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
+    I max_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    borrowed_iterator_t<R>
+      max_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<class I>
    using minmax_element_result = min_max_result<I>;

  template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
    constexpr minmax_element_result<I>
      minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
  template<forward_range R, class Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
    constexpr minmax_element_result<borrowed_iterator_t<R>>
      minmax_element(R&& r, Comp comp = {}, Proj proj = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
+            class Proj = identity,
+            indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
+    minmax_element_result<I>
+      minmax_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
+            indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
+    minmax_element_result<borrowed_iterator_t<R>>
+      minmax_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});    @_// freestanding-deleted_@
}

namespace ranges {
  template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
            class Proj1 = identity, class Proj2 = identity,
            indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
              ranges::less>
    constexpr bool
      lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template<input_range R1, input_range R2, class Proj1 = identity,
            class Proj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
    constexpr bool
      lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});

+  template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
+            random_access_iterator I2, sized_sentinel_for<I2> S2,
+            class Proj1 = identity, class Proj2 = identity,
+            indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less>
+    bool lexicographical_compare(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
+            class Proj1 = identity, class Proj2 = identity,
+            indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
+                                        projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
+    bool lexicographical_compare(Ep&& exec, R1&& r1, R2&& r2, Comp comp = {},
+                                  Proj1 proj1 = {}, Proj2 proj2 = {});    @_// freestanding-deleted_@
}
```

## Modify [alg.all.of]{- .sref} ## {#modify_alg_all_of}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr bool ranges::all_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::all_of(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  bool ranges::all_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  bool ranges::all_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be:

- [1.1]{.pnum} `pred(*i)` for the overloads in namespace `std`;
- [1.2]{.pnum} `invoke(pred, invoke(proj, *i))` for the overloads in namespace `ranges`.

[2]{.pnum} *Returns*: `false` if *`E`* is `false` for some iterator `i` in the range `[first, last)`, and `true` otherwise.

[3]{.pnum} *Complexity*: At most `last - first` applications of the predicate and any projection.

## Modify [alg.any.of]{- .sref} ## {#modify_alg_any_of}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr bool ranges::any_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::any_of(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  bool ranges::any_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  bool ranges::any_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be:

- [1.1]{.pnum} `pred(*i)` for the overloads in namespace `std`;
- [1.2]{.pnum} `invoke(pred, invoke(proj, *i))` for the overloads in namespace `ranges`.

[2]{.pnum} *Returns*: `true` if *`E`* is `true` for some iterator `i` in the range `[first, last)`, and `false` otherwise.

[3]{.pnum} *Complexity*: At most `last - first` applications of the predicate and any projection.

## Modify [alg.none.of]{- .sref} ## {#modify_alg_none_of}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr bool ranges::none_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::none_of(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  bool ranges::none_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  bool ranges::none_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be:

- [1.1]{.pnum} `pred(*i)` for the overloads in namespace `std`;
- [1.2]{.pnum} `invoke(pred, invoke(proj, *i))` for the overloads in namespace `ranges`.

[2]{.pnum} *Returns*: `false` if *`E`* is `true` for some iterator `i` in the range `[first, last)`, and `true` otherwise.

[3]{.pnum} *Complexity*: At most `last - first` applications of the predicate and any projection.

## Modify [alg.contains]{- .sref} ## {#modify_alg_contains}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr bool ranges::contains(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr bool ranges::contains(R&& r, const T& value, Proj proj = {});
```

*Returns*: `ranges::find(std::move(first), last, value, proj) != last.`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  bool ranges::contains(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  bool ranges::contains(Ep&& exec, R&& r, const T& value, Proj proj = {});
```

*Returns*: `ranges::find(std::forward<Ep>(exec), first, last, value, proj) != last.`
:::

```cpp
template<forward_iterator I1, sentinel_for<I1> S1,
         forward_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::contains_subrange(R1&& r1, R2&& r2, Pred pred = {},
                                           Proj1 proj1 = {}, Proj2 proj2 = {});
```

*Returns*: `first2 == last2 || !ranges::search(first1, last1, first2, last2, pred, proj1, proj2).empty().`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  bool ranges::contains_subrange(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                                 Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  bool ranges::contains_subrange(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
```

*Returns*: `first2 == last2 || !ranges::search(std::forward<Ep>(exec), first1, last1, first2, last2, pred, proj1, proj2).empty().`
:::

## Modify [alg.foreach]{- .sref} ## {#modify_alg_foreach}

<!-- [Namespace `ranges` is used (or not used) inconsistently, in our opinion. The example can be found below
when `ranges::` is before `for_each` and `for_each_result` but not before `borrowed_iterator_t`. Another example
is `ranges::equal_to` and similar, e.g., in `find` algorithm signature.]{.draftnote audience="LWG"}. -->

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirectly_unary_invocable<projected<I, Proj>> Fun>
  constexpr ranges::for_each_result<I, Fun>
    ranges::for_each(I first, S last, Fun f, Proj proj = {});
template<input_range R, class Proj = identity,
         indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
  constexpr ranges::for_each_result<borrowed_iterator_t<R>, Fun>
    ranges::for_each(R&& r, Fun f, Proj proj = {});
```

*Effects*: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the range `[first, last)`, starting from `first`
and proceeding to `last - 1`.

[*Note X*: If the result of `invoke(proj, *i)` is a mutable reference, `f` can apply non-constant functions. — *end note*]

*Returns*: `{last, std::move(f)}.`

*Complexity*: Applies `f` and `proj` exactly `last - first` times.

*Remarks*: If `f` returns a result, the result is ignored.

[*Note X*: The overloads in namespace `ranges` require `Fun` to model `copy_constructible`. — *end note*]

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirectly_unary_invocable<projected<I, Proj>> Fun>
  I ranges::for_each(Ep&& exec, I first, S last, Fun f, Proj proj = {});

template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
  borrowed_iterator_t<R>
    ranges::for_each(Ep&& exec, R&& r, Fun f, Proj proj = {});
```

*Effects*: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the range `[first, last)`.

[*Note X*: If the result of `invoke(proj, *i)` is a mutable reference, `f` can apply non-constant functions. — *end note*]

*Returns*: `last.`

*Complexity*: Applies `f` and `proj` exactly `last - first` times.

*Remarks*:

- If `f` returns a result, the result is ignored.
- Implementations do not have the freedom granted under [algorithms.parallel.exec]{- .sref} to make arbitrary copies of
  elements from the input sequence.
- `f` may modify objects via its arguments ([algorithms.parallel.user]{- .sref}).

[*Note X*: Does not return a copy of its `Fun` parameter, since parallelization often does not permit efficient state
accumulation. — *end note*]
:::

```cpp
template<input_iterator I, class Proj = identity,
         indirectly_unary_invocable<projected<I, Proj>> Fun>
  constexpr ranges::for_each_n_result<I, Fun>
    ranges::for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});
```

*Preconditions*: `n >= 0` is `true`.

*Effects*: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the range `[first, first + n)` in order.

[*Note X*: If the result of `invoke(proj, *i)` is a mutable reference, `f` can apply non-constant functions. — *end note*]

*Returns*: `{first + n, std::move(f)}`.

*Remarks*: If `f` returns a result, the result is ignored.

[*Note X*: The overload in namespace `ranges` requires `Fun` to model `copy_constructible`. — *end note*]

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, class Proj = identity,
         indirectly_unary_invocable<projected<I, Proj>> Fun>
  I ranges::for_each_n(Ep&& exec, I first, iter_difference_t<I> n, Fun f, Proj proj = {});
```

*Preconditions*: `n >= 0` is `true`.

*Effects*: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the range `[first, first + n)`.

[*Note X*: If the result of `invoke(proj, *i)` is a mutable reference, `f` can apply non-constant functions. — *end note*]

*Returns*: `first + n`.

*Remarks*:

- If `f` returns a result, the result is ignored.
- Implementations do not have the freedom granted under [algorithms.parallel.exec]{- .sref} to make arbitrary copies of
  elements from the input sequence.
- `f` may modify objects via its arguments ([algorithms.parallel.user]{- .sref}).

[*Note X*: Does not return a copy of its `Fun` parameter, since parallelization often does not permit efficient state
accumulation. — *end note*]
:::

## Modify [alg.find]{- .sref} ## {#modify_alg_find}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr I ranges::find(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_iterator_t<R>
    ranges::find(R&& r, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  I ranges::find(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  borrowed_iterator_t<R> ranges::find(Ep&& exec, R&& r, const T& value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr I ranges::find_if(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_iterator_t<R>
    ranges::find_if(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  I ranges::find_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  borrowed_iterator_t<R> ranges::find_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr I ranges::find_if_not(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_iterator_t<R>
    ranges::find_if_not(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  I ranges::find_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  borrowed_iterator_t<R> ranges::find_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be:

- [1.1]{.pnum} `*i == value` for `find`;
- [1.2]{.pnum} `pred(*i) != false` for `find_if`;
- [1.3]{.pnum} `pred(*i) == false` for `find_if_not`;
- [1.4]{.pnum} `bool(invoke(proj, *i) == value)` for `ranges::find;`
- [1.5]{.pnum} `bool(invoke(pred, invoke(proj, *i)))` for `ranges::find_if`;
- [1.6]{.pnum} `bool(!invoke(pred, invoke(proj, *i)))` for `ranges::find_if_not`.

[2]{.pnum} *Returns*: The first iterator `i` in the range `[first, last)` for which *`E`* is `true`. Returns `last` if
no such iterator is found.

[3]{.pnum} *Complexity*: At most `last - first` applications of the corresponding predicate and any projection.

## Modify [alg.find.last]{- .sref} ## {#modify_alg_find_last}

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr subrange<I> ranges::find_last(I first, S last, const T& value, Proj proj = {});
template<forward_range R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_subrange_t<R> ranges::find_last(R&& r, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  subrange<I> ranges::find_last(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  borrowed_subrange_t<R> ranges::find_last(Ep&& exec, R&& r, const T& value, Proj proj = {});
```
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::find_last_if(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_subrange_t<R> ranges::find_last_if(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  subrange<I> ranges::find_last_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  borrowed_subrange_t<R> ranges::find_last_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::find_last_if_not(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_subrange_t<R> ranges::find_last_if_not(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  subrange<I> ranges::find_last_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  borrowed_subrange_t<R> ranges::find_last_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be:

- [1.1]{.pnum} `bool(invoke(proj, *i) == value)` for `ranges::find_last`;
- [1.2]{.pnum} `bool(invoke(pred, invoke(proj, *i)))` for `ranges::find_last_if`;
- [1.3]{.pnum} `bool(!invoke(pred, invoke(proj, *i)))` for `ranges::find_last_if_not`.

[2]{.pnum} *Returns*: Let `i` be the last iterator in the range `[first, last)` for which *`E`* is `true`. Returns `{i, last}`, or `{last, last}` if no such iterator is found.

[3]{.pnum} *Complexity*: At most `last - first` applications of the corresponding predicate and projection.

## Modify [alg.find.end]{- .sref} ## {#modify_alg_find_end}

```cpp
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr subrange<I1>
    ranges::find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_subrange_t<R1>
    ranges::find_end(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1, random_access_iterator I2,
         sized_sentinel_for<I2> S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  subrange<I1> ranges::find_end(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  borrowed_subrange_t<R1> ranges::find_end(Ep&& exec, R1&& r1, R2&& r2,
                                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[1]{.pnum} Let:

- [1.1]{.pnum} `pred` be `equal_to{}` for the overloads with no parameter `pred`;
- [1.2]{.pnum} *`E`* be:

  - [1.2.1]{.pnum} `pred(*(i + n), *(first2 + n))` for the overloads in namespace `std`;
  - [1.2.2]{.pnum} `invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n)))` for the overloads in namespace `ranges`;

- [1.3]{.pnum} `i` be `last1` if `[first2, last2)` is empty, or if `(last2 - first2) > (last1 - first1)` is `true`, or if
  there is no iterator in the range `[first1, last1 - (last2 - first2))` such that for every non-negative integer
  `n < (last2 - first2)`, *`E`* is `true`.

  Otherwise `i` is the last such iterator in `[first1, last1 - (last2 - first2))`.

[2]{.pnum} *Returns*:

- [2.1]{.pnum} `i` for the overloads in namespace `std`.
- [2.2]{.pnum} `{i, i + (i == last1 ? 0 : last2 - first2)}` for the overloads in namespace `ranges`.

[3]{.pnum} *Complexity*: At most `(last2 - first2) * (last1 - first1 - (last2 - first2) + 1)` applications of the corresponding
predicate and any projections.

## Modify [alg.find.first.of]{- .sref} ## {#modify_alg_find_first_of}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr I1 ranges::find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                                     Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, forward_range R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_iterator_t<R1>
    ranges::find_first_of(R1&& r1, R2&& r2, Pred pred = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  I1 ranges::find_first_of(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  borrowed_iterator_t<R1> ranges::find_first_of(Ep&& exec, R1&& r1, R2&& r2,
                                                Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[1]{.pnum} Let *`E`* be:

- [1.1]{.pnum} `*i == *j` for the overloads with no parameter `pred`;
- [1.2]{.pnum} `pred(*i, *j) != false` for the overloads with a parameter `pred` and no parameter `proj1`;
- [1.3]{.pnum} `bool(invoke(pred, invoke(proj1, *i), invoke(proj2, *j)))` for the overloads with parameters `pred` and `proj1`.

[2]{.pnum} *Effects*: Finds an element that matches one of a set of values.

[3]{.pnum} *Returns*: The first iterator `i` in the range `[first1, last1)` such that for some iterator `j` in the range
`[first2, last2)` *`E`* holds. Returns `last1` if `[first2, last2)` is empty or if no such iterator is found.

[4]{.pnum} *Complexity*: At most `(last1-first1) * (last2-first2)` applications of the corresponding predicate and any
projections.

## Modify [alg.adjacent.find]{- .sref} ## {#modify_alg_adjacent_find}

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_binary_predicate<projected<I, Proj>,
                                   projected<I, Proj>> Pred = ranges::equal_to>
  constexpr I ranges::adjacent_find(I first, S last, Pred pred = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_binary_predicate<projected<iterator_t<R>, Proj>,
                                   projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
  constexpr borrowed_iterator_t<R> ranges::adjacent_find(R&& r, Pred pred = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_binary_predicate<projected<I, Proj>, projected<I, Proj>> Pred = ranges::equal_to>
  I ranges::adjacent_find(Ep&& exec, I first, S last, Pred pred = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_binary_predicate<projected<iterator_t<R>, Proj>, projected<iterator_t<R>, Proj>> Pred
           = ranges::equal_to>
  borrowed_iterator_t<R> ranges::adjacent_find(Ep&& exec, R&& r, Pred pred = {}, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be:

- [1.1]{.pnum} `*i == *(i + 1)` for the overloads with no parameter `pred`;
- [1.2]{.pnum} `pred(*i, *(i + 1)) != false` for the overloads with a parameter `pred` and no parameter `proj`;
- [1.3]{.pnum} `bool(invoke(pred, invoke(proj, *i), invoke(proj, *(i + 1))))` for the overloads with both parameters `pred`
  and `proj`.

[2]{.pnum} *Returns*: The first iterator `i` such that both `i` and `i + 1` are in the range `[first, last)` for which *`E`*
holds. Returns `last` if no such iterator is found.

[3]{.pnum} *Complexity*: For the [non-parallel algorithm]{.add} overloads [with no `ExecutionPolicy`]{.rm}, exactly
min(`(i - first) + 1`,  `(last - first) - 1`) applications of the corresponding predicate, where `i` is `adjacent_find`'s
return value. For the [parallel algorithm]{.add} overloads [with an `ExecutionPolicy`]{.rm}, _O_(`last - first`)
applications of the corresponding predicate[, and no]{.rm}[. No]{.add} more than twice as many applications of any
projection.

## Modify [alg.count]{- .sref} ## {#modify_alg_count}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr iter_difference_t<I>
    ranges::count(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr range_difference_t<R>
    ranges::count(R&& r, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  iter_difference_t<I> ranges::count(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  range_difference_t<R> ranges::count(Ep&& exec, R&& r, const T& value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr iter_difference_t<I>
    ranges::count_if(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr range_difference_t<R>
    ranges::count_if(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  iter_difference_t<I> ranges::count_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  range_difference_t<R> ranges::count_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be:

- [1.1]{.pnum} `*i == value` for the overloads with no parameter `pred` or `proj`;
- [1.2]{.pnum} `pred(*i) != false` for the overloads with a parameter `pred` but no parameter `proj`;
- [1.3]{.pnum} `invoke(proj, *i) == value` for the overloads with a parameter `proj` but no parameter `pred`;
- [1.4]{.pnum} `bool(invoke(pred, invoke(proj, *i)))` for the overloads with both parameters `proj` and `pred`.

[2]{.pnum} *Effects*: Returns the number of iterators `i` in the range `[first, last)` for which *`E`* holds.

[3]{.pnum} *Complexity*: Exactly `last - first` applications of the corresponding predicate and any projection.

## Modify [alg.mismatch]{- .sref} ## {#modify_alg_mismatch}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr ranges::mismatch_result<I1, I2>
    ranges::mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr ranges::mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::mismatch(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  ranges::mismatch_result<I1, I2>
    ranges::mismatch(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  ranges::mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::mismatch(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[1]{.pnum} Let `last2` be `first2 + (last1 - first1)` for the overloads [in namespace `std`]{.add} with no parameter
`last2`[ or `r2`]{.rm}.

[2]{.pnum} Let *`E`* be:

- [2.1]{.pnum} `!(*(first1 + n) == *(first2 + n))` for the overloads with no parameter `pred`;
- [2.2]{.pnum} `pred(*(first1 + n), *(first2 + n)) == false` for the overloads with a parameter `pred` and no
  parameter `proj1`;
- [2.3]{.pnum} `!invoke(pred, invoke(proj1, *(first1 + n)), invoke(proj2, *(first2 + n)))` for the overloads with both
  parameters `pred` and `proj1`.

[3]{.pnum} Let *`N`* be min(`last1 - first1`,  `last2 - first2`).

[4]{.pnum} *Returns*: `{ first1 + n, first2 + n }`, where `n` is the smallest integer in `[0, @_N_@)` such that *`E`* holds,
or *`N`* if no such integer exists.

[5]{.pnum} *Complexity*: At most *`N`* applications of the corresponding predicate and any projections.

## Modify [alg.equal]{- .sref} ## {#modify_alg_equal}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::equal(I1 first1, S1 last1, I2 first2, S2 last2,
                               Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::equal(R1&& r1, R2&& r2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  bool ranges::equal(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  bool ranges::equal(Ep&& exec, R1&& r1, R2&& r2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[1]{.pnum} Let:

- [1.1]{.pnum} `last2` be `first2 + (last1 - first1)` for the overloads [in namespace `std`]{.add} with no parameter `last2`
  [or `r2`]{.rm};
- [1.2]{.pnum} `pred` be `equal_to{}` for the overloads with no parameter `pred`;
- [1.3]{.pnum} *`E`* be:

  - [1.3.1]{.pnum} `pred(*i, *(first2 + (i - first1)))` for the overloads with no parameter `proj1`;
  - [1.3.2]{.pnum} `invoke(pred, invoke(proj1, *i), invoke(proj2, *(first2 + (i - first1))))` for the overloads with
    parameter `proj1`.

[2]{.pnum} *Returns*: If `last1 - first1 != last2 - first2`, return `false`. Otherwise return `true` if *`E`* holds for
every iterator `i` in the range `[first1, last1)`. Otherwise, returns `false`.

[3]{.pnum} *Complexity*: If

- [3.1]{.pnum} the types of `first1`, `last1`, `first2`, and `last2` meet the *Cpp17RandomAccessIterator* requirements
  ([random.access.iterators]{- .sref}) and `last1 - first1 != last2 - first2` for the overloads in namespace `std`;
- [3.2]{.pnum} the types of `first1`, `last1`, `first2`, and `last2` pairwise model `sized_sentinel_for`
  ([iterator.concept.sizedsentinel]{- .sref}) and `last1 - first1 != last2 - first2` for the first [and third]{.add}
  overload[s]{.add} in namespace `ranges`, [or]{.add}
- [3.3]{.pnum} `R1` and `R2` each model `sized_range` and `ranges::distance(r1) != ranges::distance(r2)` for the second
  [and fourth]{.add} overload[s]{.add} in namespace `ranges`,

then no applications of the corresponding predicate and each projection; otherwise,

- [3.4]{.pnum} [For the overloads with no `ExecutionPolicy`, a]{.rm}[A]{.add}t most
  min(`last1 - first1`,  `last2 - first2`) applications of the corresponding predicate and any projections.
- [3.5]{.pnum} [For the overloads with an `ExecutionPolicy`,
  _O_(min(`last1 - first1`, `last2 - first2`)) applications of the corresponding predicate.]{.rm}

## Modify [alg.search]{- .sref} ## {#modify_alg_search}

```cpp
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
         sentinel_for<I2> S2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr subrange<I1>
    ranges::search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_subrange_t<R1>
    ranges::search(R1&& r1, R2&& r2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
    subrange<I1>
      ranges::search(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    borrowed_subrange_t<R1>
      ranges::search(Ep&& exec, R1&& r1, R2&& r2,
                     Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[3]{.pnum} *Returns*:

- [3.1]{.pnum} `{i, i + (last2 - first2)}`, where `i` is the first iterator in the range `[first1, last1 - (last2 - first2))`
  such that for every non-negative integer `n` less than `last2 - first2` the condition
  `bool(invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n))))` is `true`.
- [3.2]{.pnum} Returns `{last1, last1}` if no such iterator exists.

[4]{.pnum} *Complexity*: At most `(last1 - first1) * (last2 - first2)` applications of the corresponding predicate and projections.

```cpp
template<forward_iterator I, sentinel_for<I> S,
         class Pred = ranges::equal_to, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirectly_comparable<I, const T*, Pred, Proj>
  constexpr subrange<I>
    ranges::search_n(I first, S last, iter_difference_t<I> count,
                     const T& value, Pred pred = {}, Proj proj = {});
template<forward_range R, class Pred = ranges::equal_to,
         class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
  constexpr borrowed_subrange_t<R>
    ranges::search_n(R&& r, range_difference_t<R> count,
                     const T& value, Pred pred = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Pred = ranges::equal_to, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirectly_comparable<I, const T*, Pred, Proj>
    subrange<I>
      ranges::search_n(Ep&& exec, I first, S last, iter_difference_t<I> count,
                       const T& value, Pred pred = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Pred = ranges::equal_to,
         class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
    borrowed_subrange_t<R>
      ranges::search_n(Ep&& exec, R&& r, range_difference_t<R> count,
                       const T& value, Pred pred = {}, Proj proj = {});
```
:::

[9]{.pnum} *Returns*: `{i, i + count}` where `i` is the first iterator in the range `[first, last - count)` such that for
every non-negative integer `n` less than `count`, the following condition holds:
`invoke(pred, invoke(proj, *(i + n)), value)`. Returns `{last, last}` if no such iterator is found.

[10]{.pnum} *Complexity*: At most `last - first` applications of the corresponding predicate and projection.

## Modify [alg.starts.with]{- .sref} ## {#modify_alg_starts_with}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity,
         class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::starts_with(R1&& r1, R2&& r2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
```

*Returns*: `ranges::mismatch(std::move(first1), last1, std::move(first2), last2, pred, proj1, proj2).in2 == last2`[.]{.add}

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  bool ranges::starts_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  bool ranges::starts_with(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

*Returns*: `ranges::mismatch(std::forward<Ep>(exec), std::move(first1), last1, std::move(first2), last2, pred, proj1, proj2).in2 == last2`.
:::

## Modify [alg.ends.with]{- .sref} ## {#modify_alg_ends_with}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires (forward_iterator<I1> || sized_sentinel_for<S1, I1>) &&
           (forward_iterator<I2> || sized_sentinel_for<S2, I2>) &&
           indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                   Proj1 proj1 = {}, Proj2 proj2 = {});
```
Let `N1` be `last1 - first1` and `N2` be `last2 - first2`.

*Returns*: `false` if `N1 < N2`, otherwise `ranges::equal(std::move(first1) + (N1 - N2), last1, std::move(first2), last2, pred, proj1, proj2)`[.]{.add}

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
  bool ranges::ends_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                         Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
Let `N1` be `last1 - first1` and `N2` be `last2 - first2`.

*Returns*: `false` if `N1 < N2`, otherwise `ranges::equal(std::forward<Ep>(exec), std::move(first1) + (N1 - N2), last1, std::move(first2), last2, pred, proj1, proj2)`.
:::

```cpp
template<input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity,
         class Proj2 = identity>
  requires (forward_range<R1> || sized_range<R1>) &&
           (forward_range<R2> || sized_range<R2>) &&
           indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::ends_with(R1&& r1, R2&& r2, Pred pred = {},
                                   Proj1 proj1 = {}, Proj2 proj2 = {});
```
Let `N1` be `ranges::distance(r1)` and `N2` be `ranges::distance(r2)`.

*Returns*: `false` if `N1 < N2`, otherwise `ranges::equal(views::drop(ranges::ref_view(r1), N1 - static_cast<decltype(N1)>(N2)), r2, pred, proj1, proj2)`[.]{.add}

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  bool ranges::ends_with(Ep&& exec, R1&& r1, R2&& r2,
                         Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

Let `N1` be `ranges::distance(r1)` and `N2` be `ranges::distance(r2)`.

*Returns*: `false` if `N1 < N2`, otherwise `ranges::equal(std::forward<Ep>, views::drop(ranges::ref_view(r1), N1 - static_cast<decltype(N1)>(N2)), r2, pred, proj1, proj2)`.
:::

## Modify [alg.copy]{- .sref} ## {#modify_copy}

```cpp
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 copy(ExecutionPolicy&& exec,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_copyable<I, O>
  ranges::copy_result<I, O> ranges::copy(Ep&& exec, I first, S last, O result, OutS result_last);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::copy(Ep&& exec, R&& r, OutR&& result_r);
```
<!-- [For `partial_sort_copy` the range-as-the-output parameter type is called `R2`. For `uninitialized_copy` and `uninitialized_move`
it is called `OR`. For the new overloads we call it `OutR`. We should probably align the names.
The same question applies to the names `S2` and `OutS` of the sentinel-for-the-output parameter.]{.draftnote audience="LWG"} -->

[x]{.pnum} Let `result_last` be `result + (last - first)` for the overload in namespace `std`.

[x]{.pnum} Let *`N`* be min(`last - first`, `result_last - result`).
:::

[6]{.pnum} *Preconditions*: The ranges `[first, last)` and ``[result, result + @[`(last - first)`]{.rm}[_N_]{.add}@)`` do not overlap.

[7]{.pnum} *Effects*: Copies elements in the range `[first, @[last]{.rm}[first + _N_]{.add}@)` into the range
``[result, result + @[`(last - first)`]{.rm}[_N_]{.add}@)``. For each non-negative integer
``n < @[`(last - first)`]{.rm}[_N_]{.add}@``, performs `*(result + n) = *(first + n)`.

[8]{.pnum} *Returns*:[ `result + (last - first)`.]{.rm}

::: add
- [x.1]{.pnum} `result + @_N_@` for the overload in namespace `std`.
- [x.2]{.pnum} `{first + @_N_@, result + @_N_@}` for the overloads in namespace `ranges`.
:::

[9]{.pnum} *Complexity*: Exactly `@[(last - first)]{.rm}@@[_N_]{.add}@` assignments.

```cpp
template<input_iterator I, weakly_incrementable O>
  requires indirectly_copyable<I, O>
  constexpr ranges::copy_n_result<I, O>
    ranges::copy_n(I first, iter_difference_t<I> n, O result);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, random_access_iterator O,
         sized_sentinel_for<O> OutS>
  requires indirectly_copyable<I, O>
  ranges::copy_n_result<I, O>
    ranges::copy_n(Ep&& exec, I first, iter_difference_t<I> n, O result, OutS result_last);
```

[x]{.pnum} Let *`M`* be max(0, `n`).

[x]{.pnum} Let `result_last` be `result + @_M_@` for the overloads with no parameter `result_last`.
:::

[10]{.pnum} Let *`N`* be [max(0, `n`)]{.rm}[min(`result_last - result`, *`M`*)]{.add}.

[11]{.pnum} *Mandates*: The type `Size` is convertible to an integral type ([conv.integral]{- .sref}, [class.conv]{- .sref}).

[12]{.pnum} *Effects*: For each non-negative integer *`i`* < *`N`*, performs `*(result + @_i_@) = *(first + @_i_@)`.

[13]{.pnum} *Returns*:

- [13.1]{.pnum} `result + @_N_@` for the overloads in namespace `std`.
- [13.2]{.pnum} `{first + @_N_@, result + @_N_@}` for the overload[s]{.add} in namespace `ranges`.

[14]{.pnum} *Complexity*: Exactly *`N`* assignments.

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O>
  constexpr ranges::copy_if_result<I, O>
    ranges::copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::copy_if_result<borrowed_iterator_t<R>, O>
    ranges::copy_if(R&& r, O result, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O>
  ranges::copy_if_result<I, O>
    ranges::copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
                    Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
         class Proj = identity, indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, Proj proj = {});
```
:::

[15]{.pnum} Let `@_E_[(i)]{.add}@` be:

- [15.1]{.pnum} `bool(pred(*i))` for the overloads in namespace `std`;
- [15.2]{.pnum} `bool(invoke(pred, invoke(proj, *i)))` for the overloads in namespace `ranges`[,]{.rm}[.]{.add}

::: rm
and *`N`* be the number of iterators `i` in the range `[first, last)` for which the condition *`E`* holds.
:::

::: add
[x]{.pnum} Let:

- [x.1]{.pnum} *`M`* be the number of iterators `i` in the range `[first, last)` for which the condition `@_E_@(i)` holds;
- [x.2]{.pnum} `result_last` be `result + @_M_@` for the overloads with no parameter `result_last` or `result_r`;
- [x.3]{.pnum} *`N`* be min(*`M`*, `result_last - result`).
:::

[16]{.pnum} *Preconditions*: The ranges `[first, last)` and
``[result, result + @[`(last - first)`]{.rm}[_N_]{.add}@)`` do not overlap.

[*Note 1*: For the [parallel algorithm]{.add} overload [with an `ExecutionPolicy`]{.rm}[in namespace `std`]{.add},
there [might]{.rm}[can]{.add} be a performance cost if `iterator_traits<ForwardIterator1>::value_type` [is not]{.rm}[does not meet the]{.add}
*Cpp17MoveConstructible* (Table 31) [requirements]{.add}. [For the parallel algorithm overloads in namespace `ranges`, there
can be a performance cost if `iter_value_t<I>` does not model `move_constructible`.]{.add} — *end note*]

[17]{.pnum} *Effects*: Copies [all of the]{.rm}[the first *`N`*]{.add} elements referred to by the iterator `i` in the range
`[first, last)` for which `@_E_[(i)]{.add}@` is `true` [into the range `[result, result + @_N_@)`]{.add}.

[18]{.pnum} *Returns*:

- [18.1]{.pnum} `result + @_N_@` for the overloads in namespace `std`.
- [18.2]{.pnum} `{last, result + @_N_@}` for the overloads in namespace `ranges`[, if *`N`* is equal to *`M`*]{.add}.
- [18.x]{.pnum} [Otherwise, `{j, result_last}` for the overloads in namespace `ranges`,
  where `j` is the iterator in `[first, last)` for which `@_E_@(j)` holds and there are exactly *`N`*
  iterators `i` in `[first, j)` for which `@_E_@(i)` holds.]{.add}

[19]{.pnum} *Complexity*: [Exactly]{.rm}[At most]{.add} `last - first` applications of the corresponding predicate and any projection.

[20]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}).

## Modify [alg.move]{- .sref} ## {#modify_move}

```cpp
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 move(ExecutionPolicy&& exec,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_movable<I, O>
  ranges::move_result<I, O> ranges::move(Ep&& exec, I first, S last, O result, OutS result_last);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR>
  requires indirectly_movable<iterator_t<R>, iterator_t<OutR>>
  ranges::move_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::move(Ep&& exec, R&& r, OutR&& result_r);
```

[x]{.pnum} Let *`E`* be:

- [x.1]{.pnum} `std::move(*(first + @_n_@))` for the overload in namespace `std`;
- [x.2]{.pnum} `ranges::iter_move(first + @_n_@)` for the overloads in namespace `ranges`.

[x]{.pnum} Let `result_last` be `result + (last - first)` for the overload in namespace `std`.
:::

[6]{.pnum} Let *`N`* be [min(]{.add}`last - first`[, `result_last - result`)]{.add}.

[7]{.pnum} *Preconditions*: The ranges `[first, last)` and `[result, result + @_N_@)` do not overlap.

[8]{.pnum} *Effects*: Moves elements in the range `[first, @[last]{.rm}[first + _N_]{.add}@)` into the range
`[result, result + @_N_@)`. For each non-negative integer `@_n_@ < @_N_@`,
performs ``*(result + @_n_@) = @[`std::move(*(first + _n_))`]{.rm}[_E_]{.add}@``.

[9]{.pnum} *Returns*:[ `result + @_N_@`.]{.rm}

::: add
- [x.1]{.pnum} `result + @_N_@` for the overload in namespace `std`.
- [x.2]{.pnum} `{first + @_N_@, result + @_N_@}` for the overloads in namespace `ranges`.
:::

[10]{.pnum} *Complexity*: Exactly *`N`* assignments.

## Modify [alg.swap]{- .sref} ## {#modify_swap}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2>
  requires indirectly_swappable<I1, I2>
  constexpr ranges::swap_ranges_result<I1, I2>
    ranges::swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
template<input_range R1, input_range R2>
  requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
  constexpr ranges::swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::swap_ranges(R1&& r1, R2&& r2);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2>
  requires indirectly_swappable<I1, I2>
  ranges::swap_ranges_result<I1, I2>
    ranges::swap_ranges(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2>
  requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
  ranges::swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::swap_ranges(Ep&& exec, R1&& r1, R2&& r2);
```
:::

[1]{.pnum} Let:

- [1.1]{.pnum} `last2` be `first2 + (last1 - first1)` for the overloads [in namespace `std`]{.add} with no parameter named `last2`;
- [1.2]{.pnum} *`M`* be min(`last1 - first1`,  `last2 - first2`).

[2]{.pnum} *Preconditions*: The two ranges `[first1, last1)` and `[first2, last2)` do not overlap. For the overloads in
namespace `std`, `*(first1 + @_n_@)` is swappable with ([swappable.requirements]{- .sref}) `*(first2 + @_n_@)`.

[3]{.pnum} *Effects*: For each non-negative integer `@_n_@ < @_M_@` performs:

- [3.1]{.pnum} `swap(*(first1 + @_n_@), *(first2 + @_n_@))` for the overloads in namespace `std`;
- [3.2]{.pnum} `ranges::iter_swap(first1 + @_n_@, first2 + @_n_@)` for the overloads in namespace `ranges`.

[4]{.pnum} *Returns*:

- [4.1]{.pnum} `last2` for the overloads in namespace `std`.
- [4.2]{.pnum} `{first1 + @_M_@, first2 + @_M_@}` for the overloads in namespace `ranges`.

[5]{.pnum} *Complexity*: Exactly *`M`* swaps.

## Modify [alg.transform]{- .sref} ## {#modify_transform}

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
  constexpr ranges::unary_transform_result<I, O>
    ranges::transform(I first1, S last1, O result, F op, Proj proj = {});
template<input_range R, weakly_incrementable O, copy_constructible F,
         class Proj = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
  constexpr ranges::unary_transform_result<borrowed_iterator_t<R>, O>
    ranges::transform(R&& r, O result, F op, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
  ranges::unary_transform_result<I, O>
    ranges::transform(Ep&& exec, I first, S last, O result, OutS result_last,
                      F op, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
         copy_constructible F, class Proj = identity>
  requires indirectly_writable<iterator_t<OutR>, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
  ranges::unary_transform_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::transform(Ep&& exec, R&& r, OutR&& result_r, F op, Proj proj = {});
```
:::

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, copy_constructible F, class Proj1 = identity,
         class Proj2 = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
                                         projected<I2, Proj2>>>
  constexpr ranges::binary_transform_result<I1, I2, O>
    ranges::transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         copy_constructible F, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
                                         projected<iterator_t<R2>, Proj2>>>
  constexpr ranges::binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::transform(R1&& r1, R2&& r2, O result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O,  sized_sentinel_for<O> OutS,
         copy_constructible F, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>, projected<I2, Proj2>>>
  ranges::binary_transform_result<I1, I2, O>
    ranges::transform(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, O result,
                      OutS result_last, F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         @_sized-random-access-range_@ OutR, copy_constructible F, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_writable<iterator_t<OutR>,
             indirect_result_t<F&, projected<iterator_t<R1>, Proj1>, projected<iterator_t<R2>, Proj2>>>
  ranges::binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::transform(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[1]{.pnum} Let:

- [1.1]{.pnum} `last2` be `first2 + (last1 - first1)` for the overloads [in namespace `std`]{.add} with parameter `first2`
  but no parameter `last2`;
- [1.2]{.pnum} `@[_N_]{.rm}[_M_]{.add}@` be `last1 - first1` for unary transforms, or min(`last1 - first1`,  `last2 - first2`)
  for binary transforms;

::: add
- [1.x]{.pnum} `result_last` be `result + @_M_@` for the overloads with no parameter `result_last` or `result_r`;
- [1.x]{.pnum} *`N`* be min(*`M`*, `result_last - result`);
:::
- [1.3]{.pnum} *`E`* be

  - [1.3.1]{.pnum} `op(*(first1 + (i - result)))` for unary transforms defined in namespace `std`;
  - [1.3.2]{.pnum} `binary_op(*(first1 + (i - result)), *(first2 + (i - result)))` for binary transforms defined in namespace
    `std`;
  - [1.3.3]{.pnum} `invoke(op, invoke(proj, *(first1 + (i - result))))` for unary transforms defined in namespace `ranges`;
  - [1.3.4]{.pnum} `invoke(binary_op, invoke(proj1, *(first1 + (i - result))), invoke(proj2, *(first2 + (i - result))))` for
    binary transforms defined in namespace `ranges`.

[2]{.pnum} *Preconditions*: [For parallel algorithm overloads `op` and `binary_op` satisfy the requirements specified in
[algorithms.parallel.user]{- .sref}.]{.add} `op` and `binary_op` do not invalidate iterators or subranges, nor modify
elements in the ranges

- [2.1]{.pnum} `[first1, first1 + @_N_@]`,
- [2.2]{.pnum} `[first2, first2 + @_N_@]`, and
- [2.3]{.pnum} `[result, result + @_N_@]`.

[3]{.pnum} *Effects*: Assigns through every iterator `i` in the range `[result, result + @_N_@)` a new corresponding value
equal to *`E`*.

[4]{.pnum} *Returns*:

- [4.1]{.pnum} `result + @_N_@` for the overloads defined in namespace `std`.
- [4.2]{.pnum} `{first1 + @_N_@, result + @_N_@}` for unary transforms defined in namespace `ranges`.
- [4.3]{.pnum} `{first1 + @_N_@, first2 + @_N_@, result + @_N_@}` for binary transforms defined in namespace `ranges`.

[5]{.pnum} *Complexity*: Exactly *`N`* applications of `op` or `binary_op`, and any projections. This requirement also applies
to the [parallel algorithm]{.add} overload[s]{.add}[ with an `ExecutionPolicy`]{.rm}.

[6]{.pnum} *Remarks*: `result` may be equal to `first1` or `first2`.

## Modify [alg.replace]{- .sref} ## {#modify_replace}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T1 = projected_value_t<I, Proj>, class T2 = T1>
  requires indirectly_writable<I, const T2&> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
  constexpr I
    ranges::replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
template<input_range R, class Proj = identity,
         class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
  requires indirectly_writable<iterator_t<R>, const T2&> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
  constexpr borrowed_iterator_t<R>
    ranges::replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T1 = projected_value_t<I, Proj>, class T2 = T1>
  requires indirectly_writable<I, const T2&> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
  I ranges::replace(Ep&& exec, I first, S last,
                    const T1& old_value, const T2& new_value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
  requires indirectly_writable<iterator_t<R>, const T2&> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
  borrowed_iterator_t<R>
    ranges::replace(Ep&& exec, R&& r,
                    const T1& old_value, const T2& new_value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_writable<I, const T&>
  constexpr I ranges::replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_writable<iterator_t<R>, const T&>
  constexpr borrowed_iterator_t<R>
    ranges::replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_writable<I, const T&>
  I ranges::replace_if(Ep&& exec, I first, S last, Pred pred,
                       const T& new_value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_writable<iterator_t<R>, const T&>
  borrowed_iterator_t<R>
    ranges::replace_if(Ep&& exec, R&& r, Pred pred,
                       const T& new_value, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be

- [1.1]{.pnum} `bool(*i == old_value)` for `replace`;
- [1.2]{.pnum} `bool(pred(*i))` for `replace_if`;
- [1.3]{.pnum} `bool(invoke(proj, *i) == old_value)` for `ranges::replace`;
- [1.4]{.pnum} `bool(invoke(pred, invoke(proj, *i)))` for `ranges::replace_if`.

[2]{.pnum} *Mandates*: `new_value` is writable ([iterator.requirements.general]{- .sref}) to `first`.

[3]{.pnum} *Effects*: Substitutes elements referred by the iterator `i` in the range `[first, last)` with `new_value`,
when *`E`* is `true`.

[4]{.pnum} *Returns*: `last` for the overloads in namespace `ranges`.

[5]{.pnum} *Complexity*: Exactly `last - first` applications of the corresponding predicate and any projection.

```cpp
template<input_iterator I, sentinel_for<I> S, class O,
         class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
  requires indirectly_copyable<I, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
           output_iterator<O, const T2&>
  constexpr ranges::replace_copy_result<I, O>
    ranges::replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                         Proj proj = {});
template<input_range R, class O, class Proj = identity,
         class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = iter_value_t<O>>
  requires indirectly_copyable<iterator_t<R>, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
           && output_iterator<O, const T2&>
  constexpr ranges::replace_copy_result<borrowed_iterator_t<R>, O>
    ranges::replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                         Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>,
         class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
  requires indirectly_copyable<I, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
           indirectly_writable<O, const T2&>
  ranges::replace_copy_result<I, O>
    ranges::replace_copy(Ep&& exec, I first, S last, O result, OutS result_last,
                         const T1& old_value, const T2& new_value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
         class Proj = identity, class T1 = projected_value_t<iterator_t<R>, Proj>,
         class T2 = range_value_t<OutR>>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*> &&
           indirectly_writable<iterator_t<OutR>, const T2&>
  ranges::replace_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::replace_copy(Ep&& exec, R&& r, OutR&& result_r,
                         const T1& old_value, const T2& new_value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S,class O, class T = iter_value_t<O>,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O> && output_iterator<O, const T&>
  constexpr ranges::replace_copy_if_result<I, O>
    ranges::replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                            Proj proj = {});
template<input_range R, class O, class T = iter_value_t<O>, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, O> && output_iterator<O, const T&>
  constexpr ranges::replace_copy_if_result<borrowed_iterator_t<R>, O>
    ranges::replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                            Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>, class T = iter_value_t<O>,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O> && indirectly_writable<O, const T&>
  ranges::replace_copy_if_result<I, O>
    ranges::replace_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
                            Pred pred, const T& new_value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
         class T = range_value_t<OutR>, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
           indirectly_writable<iterator_t<OutR>, const T&>
  ranges::replace_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::replace_copy_if(Ep&& exec, R&& r, OutR&& result_r,
                            Pred pred, const T& new_value, Proj proj = {});
```
:::

[6]{.pnum} Let *`E`* be

- [6.1]{.pnum} `bool(*(first + (i - result)) == old_value)` for `replace_copy`;
- [6.2]{.pnum} `bool(pred(*(first + (i - result))))` for `replace_copy_if`;
- [6.3]{.pnum} `bool(invoke(proj, *(first + (i - result))) == old_value)` for `ranges::replace_copy`;
- [6.4]{.pnum} `bool(invoke(pred, invoke(proj, *(first + (i - result)))))` for `ranges::replace_copy_if`.

::: add
[x]{.pnum} Let

- [x.1]{.pnum} `result_last` be `result + (last - first)` for the overloads with no parameter `result_last` or `result_r`;
- [x.2]{.pnum} *`N`* be min(`last - first`, `result_last - result`).
:::

[7]{.pnum} *Mandates*: The results of the expressions `*first` and `new_value` are writable
([iterator.requirements.general]{- .sref}) to `result`.

[8]{.pnum} *Preconditions*: The ranges `[first, last)` and
``[result, result + @[`(last - first)`]{.rm}[_N_]{.add}@)`` do not overlap.

[9]{.pnum} *Effects*: Assigns through every iterator `i` in the range
``[result, result + @[`(last - first)`]{.rm}[_N_]{.add}@)`` a new corresponding value

- [9.1]{.pnum} `new_value` if *`E`* is `true` or
- [9.2]{.pnum} `*(first + (i - result))` otherwise.

[10]{.pnum} *Returns*:

- [10.1]{.pnum} ``result + @[`(last - first)`]{.rm}[_N_]{.add}@`` for the overloads in namespace `std`.
- [10.2]{.pnum} ``{@[last]{.rm}[first + _N_]{.add}@, result + @[`(last - first)`]{.rm}[_N_]{.add}@}`` for the
  overloads in namespace `ranges`.

[11]{.pnum} *Complexity*: Exactly [`last - first`]{.rm}[*`N`*]{.add} applications of the corresponding predicate
and any projection.

## Modify [alg.fill]{- .sref} ## {#modify_fill}

```cpp
template<class O, sentinel_for<O> S, class T = iter_value_t<O>>
  requires output_iterator<O, const T&>
  constexpr O ranges::fill(O first, S last, const T& value);
template<class R, class T = range_value_t<R>>
  requires output_range<R, const T&>
  constexpr borrowed_iterator_t<R> ranges::fill(R&& r, const T& value);
template<class O, class T = iter_value_t<O>>
  requires output_iterator<O, const T&>
  constexpr O ranges::fill_n(O first, iter_difference_t<O> n, const T& value);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator O, sized_sentinel_for<O> S,
         class T = iter_value_t<O>>
  requires indirectly_writable<O, const T&>
  O ranges::fill(Ep&& exec, O first, S last, const T& value);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class T = range_value_t<R>>
  requires indirectly_writable<iterator_t<R>, const T&>
  borrowed_iterator_t<R> ranges::fill(Ep&& exec, R&& r, const T& value);
template<@_execution-policy_@ Ep, random_access_iterator O, class T = iter_value_t<O>>
  requires indirectly_writable<O, const T&>
  O ranges::fill_n(Ep&& exec, O first, iter_difference_t<O> n, const T& value);
```
:::

[1]{.pnum} Let *`N`* be max(0, `n`) for the `fill_n` algorithms, and `last - first` for the `fill` algorithms.

[2]{.pnum} *Mandates*: The expression value is writable ([iterator.requirements.general]{- .sref}) to the output iterator.
The type `Size` is convertible to an integral type ([conv.integral]{- .sref}, [class.conv]{- .sref}).

[3]{.pnum} *Effects*: Assigns value through all the iterators in the range `[first, first + @_N_@)`.

[4]{.pnum} *Returns*: `first + @_N_@`.

[5]{.pnum} *Complexity*: Exactly *`N`* assignments.

## Modify [alg.generate]{- .sref} ## {#modify_generate}

```cpp
template<input_or_output_iterator O, sentinel_for<O> S, copy_constructible F>
  requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
  constexpr O ranges::generate(O first, S last, F gen);
template<class R, copy_constructible F>
  requires invocable<F&> && output_range<R, invoke_result_t<F&>>
  constexpr borrowed_iterator_t<R> ranges::generate(R&& r, F gen);
template<input_or_output_iterator O, copy_constructible F>
  requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
  constexpr O ranges::generate_n(O first, iter_difference_t<O> n, F gen);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator O, sized_sentinel_for<O> S, copy_constructible F>
  requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
  O ranges::generate(Ep&& exec, O first, S last, F gen);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, copy_constructible F>
  requires invocable<F&> && indirectly_writable<iterator_t<R>, invoke_result_t<F&>>
  borrowed_iterator_t<R> ranges::generate(Ep&& exec, R&& r, F gen);
template<@_execution-policy_@ Ep, random_access_iterator O, copy_constructible F>
  requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
  O ranges::generate_n(Ep&& exec, O first, iter_difference_t<O> n, F gen);
```
:::

[1]{.pnum} Let *`N`* be max(0, `n`) for the `generate_n` algorithms, and `last - first` for the `generate` algorithms.

[2]{.pnum} *Mandates*: `Size` is convertible to an integral type ([conv.integral]{- .sref}, [class.conv]{- .sref}).

[3]{.pnum} *Effects*: Assigns the result of successive evaluations of `gen()` through each iterator in the range
`[first, first + @_N_@)`.

[4]{.pnum} *Returns*: `first + @_N_@`.

[5]{.pnum} *Complexity*: Exactly *`N`* evaluations of `gen()` and assignments.

[6]{.pnum} [*Remarks*: `gen` may modify objects via its arguments for parallel algorithm overloads ([algorithms.parallel.user]{- .sref}).]{.add}

## Modify [alg.remove]{- .sref} ## {#modify_remove}

```cpp
template<permutable I, sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr subrange<I> ranges::remove(I first, S last, const T& value, Proj proj = {});
template<forward_range R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires permutable<iterator_t<R>> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_subrange_t<R>
    ranges::remove(R&& r, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  subrange<I> ranges::remove(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires permutable<iterator_t<R>> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  borrowed_subrange_t<R> ranges::remove(Ep&& exec, R&& r, const T& value, Proj proj = {});
```
:::

```cpp
template<permutable I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::remove_if(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::remove_if(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  subrange<I> ranges::remove_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::remove_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[1]{.pnum} Let *`E`* be

- [1.1]{.pnum} `bool(*i == value)` for `remove`;
- [1.2]{.pnum} `bool(pred(*i))` for `remove_if`;
- [1.3]{.pnum} `bool(invoke(proj, *i) == value)` for `ranges::remove`;
- [1.4]{.pnum} `bool(invoke(pred, invoke(proj, *i)))` for `ranges::remove_if`.

[2]{.pnum} *Preconditions*: For the algorithms in namespace `std`, the type of `*first` meets the *Cpp17MoveAssignable*
requirements (Table 33).

[3]{.pnum} *Effects*: Eliminates all the elements referred to by iterator `i` in the range `[first, last)` for which
*`E`* holds.

[4]{.pnum} *Returns*: Let *`j`* be the end of the resulting range. Returns:

- [4.1]{.pnum} *`j`* for the overloads in namespace `std`.
- [4.2]{.pnum} `{@_j_@, last}` for the overloads in namespace `ranges`.

[5]{.pnum} *Complexity*: Exactly `last - first` applications of the corresponding predicate and any projection.

[6]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}).

[7]{.pnum} [*Note 1*: Each element in the range `[ret, last)`, where `ret` is the returned value, has a valid but
unspecified state, because the algorithms can eliminate elements by moving from elements that were originally in that range.
— *end note*]

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
         class Proj = identity, class T = projected_value_t<I, Proj>>
  requires indirectly_copyable<I, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr ranges::remove_copy_result<I, O>
    ranges::remove_copy(I first, S last, O result, const T& value, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirectly_copyable<iterator_t<R>, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr ranges::remove_copy_result<borrowed_iterator_t<R>, O>
    ranges::remove_copy(R&& r, O result, const T& value, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>,
         class Proj = identity, class T = projected_value_t<I, Proj>>
  requires indirectly_copyable<I, O> &&
           indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
  ranges::remove_copy_result<I, O>
    ranges::remove_copy(Ep&& exec, I first, S last, O result,  OutS result_last,
                        const T& value, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
           indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  ranges::remove_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::remove_copy(Ep&& exec, R&& r, OutR&& result_r, const T& value, Proj proj = {});
```
:::

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O>
  constexpr ranges::remove_copy_if_result<I, O>
    ranges::remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::remove_copy_if_result<borrowed_iterator_t<R>, O>
    ranges::remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O>
  ranges::remove_copy_if_result<I, O>
    ranges::remove_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
                           Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::remove_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::remove_copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, Proj proj = {});
```
:::

[8]{.pnum} Let `@_E_[(i)]{.add}@` be

- [8.1]{.pnum} `bool(*i == value)` for `remove_copy`;
- [8.2]{.pnum} `bool(pred(*i))` for `remove_copy_if`;
- [8.3]{.pnum} `bool(invoke(proj, *i) == value)` for `ranges::remove_copy`;
- [8.4]{.pnum} `bool(invoke(pred, invoke(proj, *i)))` for `ranges::remove_copy_if`.

::: rm
[9]{.pnum} Let *`N`* be the number of elements in `[first, last)` for which *`E`* is `false`.
:::

::: add
[x]{.pnum} Let

- [x.1]{.pnum} *`M`* be the number of iterators `i` in `[first, last)` for which `@_E_@(i)` is `false`;
- [x.2]{.pnum} `result_last` be `result + @_M_@` for the overloads with no parameter `result_last` or `result_r`;
- [x.3]{.pnum} *`N`* be min(*`M`*, `result_last - result`).
:::

[10]{.pnum} *Mandates*: `*first` is writable ([iterator.requirements.general]{- .sref}) to `result`.

[11]{.pnum} *Preconditions*: The ranges `[first, last)` and ``[result, result + @[`(last - first)`]{.rm}[_N_]{.add}@)``
do not overlap.

[*Note 2*: For the [parallel algorithm]{.add} overloads [with an `ExecutionPolicy`]{.rm}[in namespace `std`]{.add}, there
[might]{.rm}[can]{.add} be a performance cost if `iterator_traits<ForwardIterator1>::value_type` does not meet the
*Cpp17MoveConstructible* (Table 31) requirements. [For the parallel algorithm overloads in namespace `ranges`, there can
be a performance cost if `iter_value_t<I>` does not model `move_constructible`.]{.add} — *end note*]

[12]{.pnum} *Effects*: Copies [all the]{.rm}[the first *`N`*]{.add} elements referred to by the iterator `i` in the range
`[first, last)` for which `@_E_[(i)]{.add}@` is `false` [into the range `[result, result + @_N_@)`]{.add}.

[13]{.pnum} *Returns*:

- [13.1]{.pnum} `result + @_N_@`, for the algorithms in namespace `std`.
- [13.2]{.pnum} `{last, result + @_N_@}` for the overloads in namespace `ranges`[, if *`N`* is equal to *`M`*]{.add}.
- [13.x]{.pnum} [Otherwise, `{j, result_last}`, for the algorithms in namespace `ranges`,
  where `j` is the iterator in `[first, last)` for which `@_E_@(j)` is `false` and there are exactly *`N`*
  iterators `i` in `[first, j)` for which `@_E_@(i)` is `false`.]{.add}

[14]{.pnum} *Complexity*: [Exactly]{.rm}[At most]{.add} `last - first` applications of the corresponding predicate and any
projection.

[15]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}).

## Modify [alg.unique]{- .sref} ## {#modify_unique}
```cpp
template<permutable I, sentinel_for<I> S, class Proj = identity,
         indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
  constexpr subrange<I> ranges::unique(I first, S last, C comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::unique(R&& r, C comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity,
         indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
  requires permutable<I>
  subrange<I> ranges::unique(Ep&& exec, I first, S last, C comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::unique(Ep&& exec, R&& r, C comp = {}, Proj proj = {});
```
:::

[1]{.pnum} Let `pred` be `equal_to{}` for the overloads with no parameter `pred`, and let *`E`* be

- [1.1]{.pnum} `bool(pred(*(i - 1), *i))` for the overloads in namespace `std`;
- [1.2]{.pnum} `bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i)))` for the overloads in namespace `ranges`.

[2]{.pnum} *Preconditions*: For the overloads in namespace `std`, `pred` is an equivalence relation and the type of
`*first` meets the *Cpp17MoveAssignable* requirements (Table 33).

[3]{.pnum} *Effects*: For a nonempty range, eliminates all but the first element from every consecutive group of
equivalent elements referred to by the iterator `i` in the range `[first + 1, last)` for which *`E`* is `true`.

[4]{.pnum} *Returns*: Let *`j`* be the end of the resulting range. Returns:

- [4.1]{.pnum} *`j`* for the overloads in namespace `std`.
- [4.2]{.pnum} `{@_j_@, last}` for the overloads in namespace `ranges`.

[5]{.pnum} *Complexity*: For nonempty ranges, exactly `(last - first) - 1` applications of the corresponding predicate and
no more than twice as many applications of any projection.

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
         indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
  requires indirectly_copyable<I, O> &&
           (forward_iterator<I> ||
            (input_iterator<O> && same_as<iter_value_t<I>, iter_value_t<O>>) ||
            indirectly_copyable_storable<I, O>)
  constexpr ranges::unique_copy_result<I, O>
    ranges::unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
         indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires indirectly_copyable<iterator_t<R>, O> &&
           (forward_iterator<iterator_t<R>> ||
            (input_iterator<O> && same_as<range_value_t<R>, iter_value_t<O>>) ||
            indirectly_copyable_storable<iterator_t<R>, O>)
  constexpr ranges::unique_copy_result<borrowed_iterator_t<R>, O>
    ranges::unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>, class Proj = identity,
         indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
  requires indirectly_copyable<I, O>
  ranges::unique_copy_result<I, O>
    ranges::unique_copy(Ep&& exec, I first, S last, O result, OutS result_last,
                        C comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR,
         class Proj = identity,
         indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::unique_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::unique_copy(Ep&& exec, R&& r, OutR&& result_r,
                        C comp = {}, Proj proj = {});
```
:::

[6]{.pnum} Let `pred` be `equal_to{}` for the overloads in namespace `std` with no parameter `pred`,
and let `@_E_[(i)]{.add}@` be

- [6.1]{.pnum} `bool(pred(*i, *(i - 1)))` for the overloads in namespace `std`;
- [6.2]{.pnum} `bool(invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1))))` for the overloads in namespace `ranges`.

::: add
Let

- [x.1]{.pnum} *`M`* be the number of iterators `i` in the range `[first + 1, last)` for which `@_E_@(i)` is `false`.
- [x.1]{.pnum} `result_last` be `result + @_M_@ + 1` for the overloads with no parameter `result_last` or `result_r`;
- [x.3]{.pnum} *`N`* be min(`@_M_@ + 1`, `result_last - result`).
:::

[7]{.pnum} *Mandates*: `*first` is writable ([iterator.requirements.general]{- .sref}) to `result`.

[8]{.pnum} *Preconditions*:

- [8.1]{.pnum} The ranges `[first, last)` and ``[result, result + @[`(last - first)`]{.rm}[_N_]{.add}@)`` do not overlap.
- [8.2]{.pnum} For the overloads in namespace `std`:

  - [8.2.1]{.pnum} The comparison function is an equivalence relation.
  - [8.2.2]{.pnum} For the overloads with no `ExecutionPolicy`, let `T` be the value type of `InputIterator`. If
    `InputIterator` models `forward_iterator` ([iterator.concept.forward]{- .sref}), then there are no additional
    requirements for `T`. Otherwise, if `OutputIterator` meets the *Cpp17ForwardIterator* requirements and its value type
    is the same as `T`, then `T` meets the *Cpp17CopyAssignable* (Table 34) requirements. Otherwise, `T` meets both the
    *Cpp17CopyConstructible* (Table 32) and *Cpp17CopyAssignable* requirements.

    [[*Note 1*: For the overloads with an `ExecutionPolicy`, there might be a performance cost if the value type of
    `ForwardIterator1` does not meet both the *Cpp17CopyConstructible* and *Cpp17CopyAssignable* requirements. — *end note*]]{.rm}

[[*Note 1*: For the parallel algorihtm overloads in namespace `std`, there can be a performance cost if the value type of
`ForwardIterator1` does not meet both the *Cpp17CopyConstructible* and *Cpp17CopyAssignable* requirements. For the
parallel algorithm overloads in namespace `ranges`, there can be a performance cost if `iter_value_t<I>` does not model both
`copy_constructible` and `copy_assignable`. — *end note*]]{.add}

[9]{.pnum} *Effects*: Copies only the first element from [every]{.rm}[*`N`*]{.add} consecutive group[s]{.add} of
[equal]{.rm}[equivalent]{.add} elements referred to by the iterator `i` in the range `[first @[+ 1]{.add}@, last)`
for which `@_E_[(i)]{.add}@` holds [into the range `[result, result + @_N_@)`]{.add}.
<!-- [Modifications in the middle of the sentence are to fix the wording by aligning with `unique`.]{.draftnote audience="LWG"} -->

[10]{.pnum} *Returns*:

- [10.1]{.pnum} `result + @_N_@` for the overloads in namespace `std`.
- [10.2]{.pnum} `{last, result + @_N_@}` for the overloads in namespace `ranges`[, if *`N`* is equal to `@_M_@ + 1`]{.add}.
- [10.x]{.pnum} [Otherwise, `{j, result_last}` for the overloads in namespace `ranges`, where `j` is
the iterator in `[first + 1, last)` for which `@_E_@(j)` is `false` and there are exactly `@_N_@ - 1` iterators `i`
in `[first + 1, j)` for which `@_E_@(i)` is `false`.]{.add}

[11]{.pnum} *Complexity*: [Exactly]{.rm}[At most]{.add} `last - first - 1` applications of the corresponding predicate and
no more than twice as many applications of any projection.

## Modify [alg.reverse]{- .sref} ## {#modify_reverse}

```cpp
template<bidirectional_iterator I, sentinel_for<I> S>
  requires permutable<I>
  constexpr I ranges::reverse(I first, S last);
template<bidirectional_range R>
  requires permutable<iterator_t<R>>
  constexpr borrowed_iterator_t<R> ranges::reverse(R&& r);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
  requires permutable<I>
  I ranges::reverse(Ep&& exec, I first, S last);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R>
  requires permutable<iterator_t<R>>
  borrowed_iterator_t<R> ranges::reverse(Ep&& exec, R&& r);
```
:::

[1]{.pnum} *Preconditions*: For the overloads in namespace `std`, `BidirectionalIterator` meets the *Cpp17ValueSwappable*
requirements ([swappable.requirements]{- .sref}).

[2]{.pnum} *Effects*: For each non-negative integer `i < (last - first) / 2`, applies `std::iter_swap`, or
`ranges::iter_swap` for the overloads in namespace `ranges`, to all pairs of iterators `first + i`, `(last - i) - 1`.

[3]{.pnum} *Returns*: `last` for the overloads in namespace `ranges`.

[4]{.pnum} *Complexity*: Exactly `(last - first)/2` swaps.

```cpp
template<bidirectional_iterator I, sentinel_for<I> S, weakly_incrementable O>
  requires indirectly_copyable<I, O>
  constexpr ranges::reverse_copy_result<I, O>
    ranges::reverse_copy(I first, S last, O result);
template<bidirectional_range R, weakly_incrementable O>
  requires indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::reverse_copy_result<borrowed_iterator_t<R>, O>
    ranges::reverse_copy(R&& r, O result);
```

[5]{.pnum} Let *`N`* be `last - first`.

[6]{.pnum} *Preconditions*: The ranges `[first, last)` and `[result, result + @_N_@)` do not overlap.

[7]{.pnum} *Effects*: Copies the range `[first, last)` to the range `[result, result + @_N_@)` such that for every
non-negative integer `i < @_N_@` the following assignment takes place: `*(result + @_N_@ - 1 - i) = *(first + i)`.

[8]{.pnum} *Returns*:

- [8.1]{.pnum} `result + @_N_@` for the overloads in namespace `std`.
- [8.2]{.pnum} `{last, result + @_N_@}` for the overloads in namespace `ranges`.

[9]{.pnum} *Complexity*: Exactly *`N`* assignments.

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_copyable<I, O>
  ranges::reverse_copy_result<I, O>
    ranges::reverse_copy(Ep&& exec, I first, S last, O result, OutS result_last);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::reverse_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::reverse_copy(Ep&& exec, R&& r, OutR&& result_r);
```

[x]{.pnum} Let *`N`* be min(`last - first`, `result_last - result`), and let *`NEW_FIRST`* be `first + (last - first) - @_N_@`.

[x]{.pnum} *Preconditions*: The ranges `[first, last)` and `[result, result + @_N_@)` do not overlap.

[x]{.pnum} *Effects*: Copies the range `[@*NEW_FIRST*@, last)` to the range `[result, result + @_N_@)` such that for every
non-negative integer `i < @_N_@` the following assignment takes place: `*(result + @_N_@ - 1 - i) = *(@*NEW_FIRST*@ + i)`.

[x]{.pnum} *Returns*: `{@*NEW_FIRST*@, result + @_N_@}`.

[While the return type for the parallel and non-parallel algorithm overloads in the namespace `ranges` is the same, the
semantics is different because for the parallel range algorithm overloads `result_last - result` can be insufficient to copy
all data from the input.]{.note}

[x]{.pnum} *Complexity*: Exactly *`N`* assignments.
:::

## Modify [alg.rotate]{- .sref} ## {#modify_rotate}

```cpp
template<permutable I, sentinel_for<I> S>
  constexpr subrange<I> ranges::rotate(I first, I middle, S last);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
  requires permutable<I>
  subrange<I> ranges::rotate(Ep&& exec, I first, I middle, S last);
```
:::

[1]{.pnum} *Preconditions*: `[first, middle)` and `[middle, last)` are valid ranges. For the overloads in namespace `std`,
`ForwardIterator` meets the *Cpp17ValueSwappable* requirements ([swappable.requirements]{- .sref}), and the type of `*first`
meets the *Cpp17MoveConstructible* (Table 31) and *Cpp17MoveAssignable* (Table 33) requirements.

[2]{.pnum} *Effects*: For each non-negative integer `i < (last - first)`, places the element from the position `first + i`
into position `first + (i + (last - middle)) % (last - first)`.

[*Note 1*: This is a left rotate. — *end note*]

[3]{.pnum} *Returns*:

- [3.1]{.pnum} `first + (last - middle)` for the overloads in namespace `std`.
- [3.2]{.pnum} `{first + (last - middle), last}` for the overload in namespace `ranges`.

[4]{.pnum} *Complexity*: At most `last - first` swaps.

```cpp
template<forward_range R>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::rotate(R&& r, iterator_t<R> middle);
```
*Effects*: Equivalent to: `return ranges::rotate(ranges::begin(r), middle, ranges::end(r));`

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::rotate(Ep&& exec, R&& r, iterator_t<R> middle);
```
*Effects*: Equivalent to: `return ranges::rotate(std::forward<Ep>(exec), ranges::begin(r), middle, ranges::end(r));`
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, weakly_incrementable O>
    requires indirectly_copyable<I, O>
    constexpr ranges::rotate_copy_result<I, O>
      ranges::rotate_copy(I first, I middle, S last, O result);
```

[6]{.pnum} Let *`N`* be `last - first`.

[7]{.pnum} *Preconditions*: `[first, middle)` and `[middle, last)` are valid ranges. The ranges `[first, last)` and
`[result, result + @_N_@)` do not overlap.

[8]{.pnum} *Effects*: Copies the range `[first, last)` to the range `[result, result + @_N_@)` such that for each non-negative
integer `i < @_N_@` the following assignment takes place: `*(result + i) = *(first + (i + (middle - first)) % @_N_@)`.

[9]{.pnum} *Returns*:

- [9.1]{.pnum} `result + @_N_@` for the overloads in namespace `std`.
- [9.2]{.pnum} `{last, result + @_N_@}` for the overload in namespace `ranges`.

[10]{.pnum} *Complexity*: Exactly *`N`* assignments.

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O, sized_sentinel_for<O> OutS>
  requires indirectly_copyable<I, O>
  ranges::rotate_copy_result<I, O>
    ranges::rotate_copy(Ep&& exec, I first, I middle, S last, O result, OutS result_last);
```

[x]{.pnum} Let *`M`* be `last - first` and *`N`* be min(*`M`*, `result_last - result`).

[x]{.pnum} *Preconditions*: `[first, middle)` and `[middle, last)` are valid ranges. The ranges `[first, last)` and
`[result, result + @_N_@)` do not overlap.

[x]{.pnum} *Effects*: Copies the range `[first, last)` to the range `[result, result + @_N_@)` such that for each non-negative
integer `i < @_N_@` the following assignment takes place: `*(result + i) = *(first + (i + (middle - first)) % @_M_@)`.

[x]{.pnum} *Returns*: `{first + (@_N_@ + (middle - first)) % @_M_@, result + @_N_@}`.

[While the return type for the parallel and non-parallel algorithm overloads in the namespace `ranges` is the same, the
semantics is different because for the parallel range algorithm overloads `result_last - result` can be insufficient to copy
all data from the input.]{.note}

[x]{.pnum} *Complexity*: Exactly *`N`* assignments.
:::

```cpp
template<forward_range R, weakly_incrementable O>
  requires indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::rotate_copy_result<borrowed_iterator_t<R>, O>
    ranges::rotate_copy(R&& r, iterator_t<R> middle, O result);
```

*Effects*: Equivalent to: `return ranges::rotate_copy(ranges::begin(r), middle, ranges::end(r), std::move(result));`

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::rotate_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::rotate_copy(Ep&& exec, R&& r, iterator_t<R> middle, OutR&& result_r);
```
*Effects*: Equivalent to: `return ranges::rotate_copy(std::forward<Ep>(exec), ranges::begin(r), middle, ranges::end(r), ranges::begin(result_r), ranges::end(result_r));`
:::

## Modify [alg.shift]{- .sref} ## {#modify_shift}

```cpp
template<permutable I, sentinel_for<I> S>
  constexpr subrange<I> ranges::shift_left(I first, S last, iter_difference_t<I> n);
template<forward_range R>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::shift_left(R&& r, range_difference_t<R> n)
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
  requires permutable<I>
  subrange<I> ranges::shift_left(Ep&& exec, I first, S last, iter_difference_t<I> n);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::shift_left(Ep&& exec, R&& r, range_difference_t<R> n);
```
:::

[1]{.pnum} *Preconditions*: `n >= 0` is `true`. For the overloads in namespace `std`, the type of `*first` meets the
*Cpp17MoveAssignable* requirements.

[2]{.pnum} *Effects*: If `n == 0` or `n >= last - first`, does nothing. Otherwise, moves the element from position
`first + n + i` into position `first + i` for each non-negative integer `i < (last - first) - n`. For the
[non-parallel algorithm]{.add} overloads [without an `ExecutionPolicy` template parameter]{.rm}, does so in order starting
from `i = 0` and proceeding to `i = (last - first) - n - 1`.

[3]{.pnum} *Returns*: Let *`NEW_LAST`* be `first + (last - first - n)` if `n < last - first`, otherwise `first`.
[Returns:]{.add}

- [3.1]{.pnum} *`NEW_LAST`* for the overloads in namespace `std`.
- [3.2]{.pnum} `{first, @_NEW_LAST_@}` for the overloads in namespace `ranges`.

[4]{.pnum} *Complexity*: At most `(last - first) - n` assignments.

```cpp
template<permutable I, sentinel_for<I> S>
  constexpr subrange<I> ranges::shift_right(I first, S last, iter_difference_t<I> n);
template<forward_range R>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::shift_right(R&& r, range_difference_t<R> n);
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S>
  requires permutable<I>
  subrange<I> ranges::shift_right(Ep&& exec, I first, S last, iter_difference_t<I> n);
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::shift_right(Ep&& exec, R&& r, range_difference_t<R> n);
```
:::

[5]{.pnum} *Preconditions*: `n >= 0` is `true`. For the overloads in namespace `std`, the type of `*first` meets the
*Cpp17MoveAssignable* requirements, and `ForwardIterator` meets the *Cpp17BidirectionalIterator* requirements
([bidirectional.iterators]{- .sref}) or the *Cpp17ValueSwappable* requirements.

[6]{.pnum} *Effects*: If `n == 0` or `n >= last - first`, does nothing. Otherwise, moves the element from position
`first + i` into position `first + n + i` for each non-negative integer `i < (last - first) - n`. Does so in order starting
from `i = (last - first) - n - 1` and proceeding to `i = 0` if

- [6.1]{.pnum} for the [non-parallel algorithm]{.add} overload in namespace `std` [without an `ExecutionPolicy`
  template parameter]{.rm}, `ForwardIterator` meets the *Cpp17BidirectionalIterator* requirements,
- [6.2]{.pnum} for the [non-parallel algorithm]{.add} overloads in namespace `ranges`, `I` models  `bidirectional_iterator`.

[7]{.pnum} *Returns*: Let *`NEW_FIRST`* be `first + n` if `n < last - first`, otherwise `last`.
[Returns:]{.add}

- [7.1]{.pnum} *`NEW_FIRST`* for the overloads in namespace `std`.
- [7.2]{.pnum} `{@_NEW_FIRST_@, last}` for the overloads in namespace `ranges`.

[8]{.pnum} *Complexity*: At most `(last - first) - n` assignments or swaps.

## Modify [sort]{- .sref} ## {#modify_sort}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I
    ranges::sort(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::sort(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

[1]{.pnum} Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

[2]{.pnum} *Preconditions*: For the overloads in namespace `std`, `RandomAccessIterator` meets the *Cpp17ValueSwappable*
requirements ([swappable.requirements]{- .sref}) and the type of `*first` meets the *Cpp17MoveConstructible* (Table 31)
and *Cpp17MoveAssignable* (Table 33) requirements.

[3]{.pnum} *Effects*: Sorts the elements in the range `[first, last)` with respect to `comp` and `proj`.

[4]{.pnum} *Returns*: `last` for the overloads in namespace `ranges`.

[5]{.pnum} *Complexity*: Let *`N`* be `last - first`. `@_O_@(@_N_@log@_N_@)` comparisons and projections.

## Modify [stable.sort]{- .sref} ## {#modify_stable_sort}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I ranges::stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::stable_sort(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::stable_sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::stable_sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

[1]{.pnum} Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

[2]{.pnum} *Preconditions*: For the overloads in namespace `std`, `RandomAccessIterator` meets the *Cpp17ValueSwappable*
requirements ([swappable.requirements]{- .sref}) and the type of `*first` meets the *Cpp17MoveConstructible* (Table 31)
and *Cpp17MoveAssignable* (Table 33) requirements.

[3]{.pnum} *Effects*: Sorts the elements in the range `[first, last)` with respect to `comp` and `proj`.

[4]{.pnum} *Returns*: `last` for the overloads in namespace `ranges`.

[5]{.pnum} *Complexity*: Let *`N`* be `last - first`. If enough extra memory is available, `@_N_@log(@_N_@)` comparisons.
Otherwise, at most `@_N_@log@^2^@(@_N_@)` comparisons. In either case, twice as many projections as the number of comparisons.

[6]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}).

## Modify [partial.sort]{- .sref} ## {#modify_partial_sort}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I
    ranges::partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::partial_sort(Ep&& exec, I first, I middle, S last, Comp comp = {}, Proj proj = {});
```
:::

[1]{.pnum} Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

[2]{.pnum} *Preconditions*: `[first, middle)` and `[middle, last)` are valid ranges. For the overloads in namespace `std`,
`RandomAccessIterator` meets the *Cpp17ValueSwappable* requirements ([swappable.requirements]{- .sref}) and the type of
`*first` meets the *Cpp17MoveConstructible* (Table 31) and *Cpp17MoveAssignable* (Table 33) requirements.

[3]{.pnum} *Effects*: Places the first `middle - first` elements from the range `[first, last)` as sorted with respect
to `comp` and `proj` into the range `[first, middle)`. The rest of the elements in the range `[middle, last)` are placed
in an unspecified order.

[4]{.pnum} *Returns*: `last` for the overload in namespace `ranges`.

[5]{.pnum} *Complexity*: Approximately `(last - first) * log(middle - first)` comparisons, and twice as many projections.

```cpp
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::partial_sort(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::partial_sort(ranges::begin(r), middle, ranges::end(r), comp, proj);`

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::partial_sort(Ep&& exec, R&& r, iterator_t<R> middle,
                                              Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::partial_sort(std::forward<Ep>(exec), ranges::begin(r), middle, ranges::end(r), comp, proj);`
:::

## Modify [partial.sort.copy]{- .sref} ## {#modify_partial_sort_copy}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, random_access_iterator I2, sentinel_for<I2> S2,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
           indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
  constexpr ranges::partial_sort_copy_result<I1, I2>
    ranges::partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, random_access_range R2, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
           sortable<iterator_t<R2>, Comp, Proj2> &&
           indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>>
  constexpr ranges::partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
           indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
  ranges::partial_sort_copy_result<I1, I2>
    ranges::partial_sort_copy(Ep&& exec, I1 first, S1 last, I2 result_first, S2 result_last,
                              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
           sortable<iterator_t<R2>, Comp, Proj2> &&
           indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>>
  ranges::partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::partial_sort_copy(Ep&& exec, R1&& r, R2&& result_r, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[1]{.pnum} Let *`N`* be min(`last - first`,  `result_last - result_first`). Let `comp` be `less{}`, and `proj1` and `proj2`
be `identity{}` for the overloads with no parameters by those names.

[2]{.pnum} *Mandates*: For the overloads in namespace `std`, the expression `*first` is writable
([iterator.requirements.general]{- .sref}) to `result_first`.

[3]{.pnum} *Preconditions*: For the overloads in namespace `std`, `RandomAccessIterator` meets the *Cpp17ValueSwappable*
requirements ([swappable.requirements]{- .sref}), the type of `*result_first` meets the *Cpp17MoveConstructible* (Table 31)
and *Cpp17MoveAssignable* (Table 33) requirements.

[4]{.pnum} For iterators `a1` and `b1` in `[first, last)`, and iterators `x2` and `y2` in `[result_first, result_last)`,
after evaluating the assignment `*y2 = *b1`, let *`E`* be the value of

`bool(invoke(comp, invoke(proj1, *a1), invoke(proj2, *y2)))`.

Then, after evaluating the assignment `*x2 = *a1`, *`E`* is equal to

`bool(invoke(comp, invoke(proj2, *x2), invoke(proj2, *y2)))`.

[*Note 1*: Writing a value from the input range into the output range does not affect how it is ordered by `comp` and
`proj1` or `proj2`. — *end note*]

[5]{.pnum} *Effects*: Places the first *`N`* elements as sorted with respect to `comp` and `proj2` into the range
`[result_first, result_first + @_N_@)`.

[6]{.pnum} *Returns*:

- [6.1]{.pnum} `result_first + @_N_@` for the overloads in namespace `std`.
- [6.2]{.pnum} `{last, result_first + @_N_@}` for the overloads in namespace `ranges`.

[7]{.pnum} *Complexity*: Approximately `(last - first) * log@_N_@` comparisons, and twice as many projections.

## Modify [is.sorted]{- .sref} ## {#modify_is_sorted}

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_sorted(R&& r, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::is_sorted_until(first, last, comp, proj) == last;`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  bool ranges::is_sorted(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  bool ranges::is_sorted(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::is_sorted_until(std::forward<Ep>(exec), first, last, comp, proj) == last;`
:::

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  I ranges::is_sorted_until(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  borrowed_iterator_t<R> ranges::is_sorted_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

6 Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

7 *Returns*: The last iterator `i` in `[first, last]` for which the range `[first, i)` is sorted with respect to `comp` and
`proj`.

8 *Complexity*: Linear.

## Modify [alg.nth.element]{- .sref} ## {#modify_nth_element}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I
    ranges::nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Comp = ranges::less, class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::nth_element(Ep&& exec, I first, I nth, S last, Comp comp = {}, Proj proj = {});
```
:::

[1]{.pnum} Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

[2]{.pnum} *Preconditions*: `[first, nth)` and `[nth, last)` are valid ranges. For the overloads in namespace `std`,
`RandomAccessIterator` meets the *Cpp17ValueSwappable* requirements ([swappable.requirements]{- .sref}), and the type of
`*first` meets the *Cpp17MoveConstructible* (Table 31) and *Cpp17MoveAssignable* (Table 33) requirements.

[3]{.pnum} *Effects*: After `nth_element` the element in the position pointed to by `nth` is the element that would be in
that position if the whole range were sorted with respect to `comp` and `proj`, unless `nth == last`. Also for every
iterator `i` in the range `[first, nth)` and every iterator `j` in the range `[nth, last)` it holds that:
`bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))` is `false`.

[4]{.pnum} *Returns*: `last` for the overload in namespace `ranges`.

[5]{.pnum} *Complexity*: For the [non-parallel algorithm]{.add} overloads [with no `ExecutionPolicy`]{.rm}, linear on
average. For the [parallel algorithm]{.add} overloads [with an `ExecutionPolicy`]{.rm}, `@_O_@(@_N_@)` applications of the
predicate, and `@_O_@(@_N_@log@_N_@)` swaps, where `@_N_@ = last - first`.

```cpp
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::nth_element(ranges::begin(r), nth, ranges::end(r), comp, proj);`

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::nth_element(Ep&& exec, R&& r, iterator_t<R> nth,
                                             Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::nth_element(std::forward<Ep>(exec), ranges::begin(r), nth, ranges::end(r), comp, proj);`
:::

## Modify [alg.partitions]{- .sref} ## {#modify_partitions}

```cpp
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr bool ranges::is_partitioned(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::is_partitioned(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  bool ranges::is_partitioned(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  bool ranges::is_partitioned(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[1]{.pnum} Let `proj` be `identity{}` for the overloads with no parameter named `proj`.

[2]{.pnum} *Returns*: `true` if and only if the elements `e` of `[first, last)` are partitioned with respect to the
expression `bool(invoke(pred, invoke(proj, e)))`.

[3]{.pnum} *Complexity*: Linear. At most `last - first` applications of `pred` and `proj`.

```cpp
template<permutable I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  constexpr subrange<I>
    ranges::partition(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::partition(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
          class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  subrange<I> ranges::partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::partition(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[4]{.pnum} Let `proj` be `identity{}` for the overloads with no parameter named `proj` and let `@_E_@(@_x_@)` be
`bool(invoke(pred, invoke(proj, @_x_@)))`.

[5]{.pnum} *Preconditions*: For the overloads in namespace `std`, `ForwardIterator` meets the *Cpp17ValueSwappable*
requirements ([swappable.requirements]{- .sref}).

[6]{.pnum} *Effects*: Places all the elements `e` in `[first, last)` that satisfy `@_E_@(e)` before all the elements that
do not.

[7]{.pnum} *Returns*: Let `i` be an iterator such that `@_E_@(*j)` is `true` for every iterator `j` in `[first, i)` and
`false` for every iterator `j` in `[i, last)`. Returns:

- [7.1]{.pnum} `i` for the overloads in namespace `std`.
- [7.2]{.pnum} `{i, last}` for the overloads in namespace `ranges`.

[8]{.pnum} *Complexity*: Let `@_N_@ = last - first`:

- [8.1]{.pnum} For the [non-parallel algorithm]{.add} overload[s]{.add} [with no `ExecutionPolicy`]{.rm}, exactly *`N`*
  applications of the predicate and projection. At most `@_N_@ / 2` swaps if the type of `first` meets the
  *Cpp17BidirectionalIterator* requirements for the overloads in namespace `std` or models `bidirectional_iterator` for the
  overloads in namespace `ranges`, and at most *`N`* swaps otherwise.
- [8.2]{.pnum} For the [parallel algorithm]{.add} overload[s]{.add} [with an `ExecutionPolicy`]{.rm}, `@_O_@(@_N_@log@_N_@)`
  swaps and `@_O_@(@_N_@)` applications of the predicate.

```cpp
template<bidirectional_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_unary_predicate<projected<I, Proj>> Pred>
  requires permutable<I>
  constexpr subrange<I> ranges::stable_partition(I first, S last, Pred pred, Proj proj = {});
template<bidirectional_range R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::stable_partition(R&& r, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires permutable<I>
  subrange<I> ranges::stable_partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires permutable<iterator_t<R>>
  borrowed_subrange_t<R> ranges::stable_partition(Ep&& exec, R&& r, Pred pred, Proj proj = {});
```
:::

[9]{.pnum} Let `proj` be `identity{}` for the overloads with no parameter named `proj` and let `@_E_@(@_x_@)` be
`bool(invoke(pred, invoke(proj, x)))`.

[10]{.pnum} *Preconditions*: For the overloads in namespace `std`, `BidirectionalIterator` meets the *Cpp17ValueSwappable*
requirements ([swappable.requirements]{- .sref}) and the type of `*first` meets the *Cpp17MoveConstructible* (Table 31)
and *Cpp17MoveAssignable* (Table 33) requirements.

[11]{.pnum} *Effects*: Places all the elements `e` in `[first, last)` that satisfy `@_E_@(e)` before all the elements that
do not. The relative order of the elements in both groups is preserved.

[12]{.pnum} *Returns*: Let `i` be an iterator such that for every iterator `j` in `[first, i)`, `@_E_@(*j)` is `true`, and
for every iterator `j` in the range `[i, last)`, `@_E_@(*j)` is `false`. Returns:

- [12.1]{.pnum} `i` for the overloads in namespace `std`.
- [12.2]{.pnum} `{i, last}` for the overloads in namespace `ranges`.

[13]{.pnum} *Complexity*: Let `@_N_@ = last - first`:

- [13.1]{.pnum} For the [non-parallel algorithm]{.add} overloads [with no `ExecutionPolicy`]{.rm}, at most
  `@_N_@log@~2~_N_@` swaps, but only `@_O_@(@_N_@)` swaps if there is enough extra memory. Exactly *`N`* applications of
  the predicate and projection.
- [13.2]{.pnum} For the [parallel algorithm]{.add} overload[s]{.add} [with an `ExecutionPolicy`]{.rm},
  `@_O_@(@_N_@log@_N_@)` swaps and `@_O_@(@_N_@)` applications of the predicate.

```cpp
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O1, weakly_incrementable O2,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
  constexpr ranges::partition_copy_result<I, O1, O2>
    ranges::partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                           Proj proj = {});
template<input_range R, weakly_incrementable O1, weakly_incrementable O2,
         class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, O1> &&
           indirectly_copyable<iterator_t<R>, O2>
  constexpr ranges::partition_copy_result<borrowed_iterator_t<R>, O1, O2>
    ranges::partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         random_access_iterator O1, sized_sentinel_for<O1> OutS1,
         random_access_iterator O2, sized_sentinel_for<O2> OutS2,
         class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
  requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
  ranges::partition_copy_result<I, O1, O2>
    ranges::partition_copy(Ep&& exec, I first, S last, O1 out_true, OutS1 last_true,
                           O2 out_false, OutS2 last_false, Pred pred, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, @_sized-random-access-range_@ OutR1,
         @_sized-random-access-range_@ OutR2, class Proj = identity,
         indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires indirectly_copyable<iterator_t<R>, iterator_t<OutR1>> &&
           indirectly_copyable<iterator_t<R>, iterator_t<OutR2>>
  ranges::partition_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR1>, borrowed_iterator_t<OutR2>>
    ranges::partition_copy(Ep&& exec, R&& r, OutR1&& out_true_r, OutR2&& out_false_r,
                           Pred pred, Proj proj = {});
```
:::

[14]{.pnum} Let `proj` be `identity{}` for the overloads with no parameter named `proj` and let `@_E_@(@_x_@)` be
`bool(invoke(pred, invoke(proj, x)))`.

::: add
[x]{.pnum} For the overloads with no parameters `last_true`, `last_false`, `out_true_r`, or `out_false_r`, let

- [x.1]{.pnum} *`M`* be the number of iterators `i` in `[first, last)` for which `@_E_@(*i)` is `true`,
  and *`K`* be `last - first - @_M_@`;
- [x.2]{.pnum} `last_true` be `out_true + @_M_@`, and `last_false` be `out_false + @_K_@`.

[x]{.pnum} For the overloads with parameters `last_true`, `last_false`, `out_true_r`, or `out_false_r`, let *`M`* be
`last_true - out_true` and *`K`* be `last_false - out_false`.

[x]{.pnum} Let

- [x.1]{.pnum} *`i1`* be the iterator in `[first, last)` for which `@_E_@(*@_i1_@)` is `true` and there are exactly *`M`*
  iterators `j` in `[first, @_i1_@)` for which `@_E_@(*j)` is `true`, or `last` if no such iterator exists;
- [x.2]{.pnum} *`i2`* be the iterator in `[first, last)` for which `@_E_@(*@_i2_@)` is `false` and there are exactly *`K`*
  iterators `j` in `[first, @_i2_@)` for which `@_E_@(*j)` is `false`, or `last` if no such iterator exists;
- [x.3]{.pnum} *`N`* be min(`@_i1_@ - first`, `@_i2_@ - first`).
:::

[15]{.pnum} *Mandates*: For the overloads in namespace `std`, the expression `*first` is writable
([iterator.requirements.general]{- .sref}) to `out_true` and `out_false`.

[16]{.pnum} *Preconditions*: The input range and output ranges do not overlap.

[*Note 1*: For the [parallel algorithm]{.add} overload [with an `ExecutionPolicy`]{.rm}[in namespace `std`]{.add},
there [might]{.rm}[can]{.add} be a performance cost if `first`'s value type does not meet the *Cpp17CopyConstructible*
requirements. [For the parallel algorithm overloads in namespace `ranges`, there can be a performance
cost if `first`'s value type does not model `copy_constructible`.]{.add} — *end note*]

[17]{.pnum} *Effects*: For each iterator `i` in ``[first, @@[last]{.rm}[`first + @_N_@`]{.add}@@)``, copies `*i`
to the output range [beginning with `out_true`]{.rm}[`[out_true, last_true)`]{.add} if `@_E_@(*i)` is `true`,
or to the output range [beginning with `out_false`]{.rm}[`[out_false, last_false)`]{.add} otherwise.

[18]{.pnum} *Returns*: Let `o1` be [the end of the output range beginning at `out_true`]{.rm}[the iterator past the last
copied element in the output range `[out_true, last_true)`]{.add}, and `o2` [the end of the output range beginning at
`out_false`]{.rm}[be the iterator past the last copied element in the output range `[out_false, last_false)`]{.add}.
Returns[:]{.add}

- [18.1]{.pnum} `{o1, o2}` for the overloads in namespace `std`.
- [18.2]{.pnum} `{@[last]{.rm}[first + _N_]{.add}@, o1, o2}` for the overloads in namespace `ranges`.

[19]{.pnum} *Complexity*: [Exactly]{.rm}[At most]{.add} `last - first` applications of `pred` and `proj`.

## Modify [alg.merge]{- .sref} ## {#modify_merge}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,
         class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::merge_result<I1, I2, O>
    ranges::merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::merge(R1&& r1, R2&& r2, O result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::merge_result<I1, I2, O>
    ranges::merge(Ep&& exec, I1 first1, S1 last1,
                  I2 first2, S2 last2, O result, OutS result_last,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         @_sized-random-access-range_@ OutR, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::merge(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

::: rm
[1]{.pnum} Let *`N`* be `(last1 - first1) + (last2 - first2)`. Let `comp` be `less{}`, `proj1` be `identity{}`, and
`proj2` be `identity{}`, for the overloads with no parameters by those names.
:::

::: add
[x]{.pnum} Let:

- [x.1]{.pnum} *`N`* be:

  - [x.1.1]{.pnum} `(last1 - first1) + (last2 - first2)` for the overloads with no parameter `result_last` or `result_r`;
  - [x.1.2]{.pnum} min(`(last1 - first1) + (last2 - first2)`, `result_last - result`) for the overloads with parameters
    `result_last` or `result_r`;

- [x.2]{.pnum} `comp` be `less{}`, `proj1` be `identity{}`, and `proj2` be `identity{}`, for the overloads with no
  parameters by those names;
- [x.3]{.pnum} *`E`* be `bool(invoke(comp, invoke(proj2, e2), invoke(proj1, e1)))`;
- [x.4]{.pnum} *`K`* be the smallest integer in `[0, last1 - first1)` such that for the element `e1` in the position
`first1 + @_K_@` there are at least *`N - K`* elements `e2` in `[first2, last2)` for which *`E`* holds, and be equal to
`last1 - first1` if no such integer exists. [`first1 + @_K_@` points to the position past the last element to be copied.]{.note}
:::

[2]{.pnum} *Preconditions*: The ranges `[first1, last1)` and `[first2, last2)` are sorted with respect to
`comp` and `proj1` or `proj2`, respectively. The resulting range does not overlap with either of the original ranges.

[3]{.pnum} *Effects*: Copies [all the elements of the two ranges]{.rm}[the first `@_K_@` elements of the range]{.add}
`[first1, last1)` and [the first `@_N_ - _K_@` elements of the range]{.add} `[first2, last2)` into the range
``[result, @@[result_last]{.rm}[`result + @_N_@`]{.add}@@)``[, where `result_last` is `result + @_N_@`]{.rm}. If an element
`a` precedes `b` in an input range, `a` is copied into the output range before `b`. If `e1` is an element of
`[first1, last1)` and `e2` of `[first2, last2)`, `e2` is copied into the output range before `e1` if and only if
[`bool(invoke(comp, invoke(proj2, e2), invoke(proj1, e1)))`]{.rm}[*`E`*]{.add} is `true`.

[4]{.pnum} *Returns*:

- [4.1]{.pnum} [`result_last`]{.rm}[`result + @_N_@`]{.add} for the overloads in namespace `std`.
- [4.2]{.pnum} [`{last1, last2, result_last}`]{.rm}[`{first1 + @_K_@, first2 + @_N_ - _K_@, result + @_N_@}`]{.add}
  for the overloads in namespace `ranges`.

[5]{.pnum} *Complexity*:

- [5.1]{.pnum} For the [non-parallel algorithm]{.add} overloads [with no `ExecutionPolicy`]{.rm}, at most `@_N_@ − 1`
  comparisons and applications of each projection.
- [5.2]{.pnum} For the [parallel algorithm]{.add} overloads [with an `ExecutionPolicy`]{.rm}, `@_O_@(@_N_@)` comparisons
  [and applications of each projection]{.add}.

[6]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}).

```cpp
template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<I, Comp, Proj>
  constexpr I ranges::inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Comp = ranges::less, class Proj = identity>
  requires sortable<I, Comp, Proj>
  I ranges::inplace_merge(Ep&& exec, I first, I middle, S last, Comp comp = {}, Proj proj = {});
```
:::

[7]{.pnum} Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

[8]{.pnum} *Preconditions*: `[first, middle)` and `[middle, last)` are valid ranges sorted with respect to `comp` and
`proj`. For the overloads in namespace `std`, `BidirectionalIterator` meets the *Cpp17ValueSwappable* requirements
([swappable.requirements]{- .sref}) and the type of `*first` meets the *Cpp17MoveConstructible* (Table 31) and
*Cpp17MoveAssignable* (Table 33) requirements.

[9]{.pnum} *Effects*: Merges two sorted consecutive ranges `[first, middle)` and `[middle, last)`, putting the result of
the merge into the range `[first, last)`. The resulting range is sorted with respect to `comp` and `proj`.

[10]{.pnum} *Returns*: `last` for the overload in namespace `ranges`.

[11]{.pnum} *Complexity*: Let `@_N_@ = last - first`:

- [11.1]{.pnum} For the [non-parallel algorithm]{.add} overloads [with no `ExecutionPolicy`]{.rm}, and if enough additional
  memory is available, exactly `@_N_@ − 1` comparisons.
- [11.2]{.pnum} Otherwise, `@_O_@(@_N_@log@_N_@)` comparisons.

In either case, twice as many projections as comparisons.

[12]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}).

```cpp
template<bidirectional_range R, class Comp = ranges::less, class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::inplace_merge(ranges::begin(r), middle, ranges::end(r), comp, proj);`

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Comp = ranges::less,
         class Proj = identity>
  requires sortable<iterator_t<R>, Comp, Proj>
  borrowed_iterator_t<R> ranges::inplace_merge(Ep&& exec, R&& r, iterator_t<R> middle,
                                               Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::inplace_merge(std::forward<Ep>(exec), ranges::begin(r), middle, ranges::end(r), comp, proj);`
:::

## Modify [includes]{- .sref} ## {#modify_includes}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<I1, Proj1>,
                                    projected<I2, Proj2>> Comp = ranges::less>
  constexpr bool ranges::includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Proj1 = identity,
         class Proj2 = identity,
         indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  constexpr bool ranges::includes(R1&& r1, R2&& r2, Comp comp = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less>
  bool ranges::includes(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  bool ranges::includes(Ep&& exec, R1&& r1, R2&& r2,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[1]{.pnum} Let `comp` be `less{}`, `proj1` be `identity{}`, and `proj2` be `identity{}`, for the overloads with no
parameters by those names.

[2]{.pnum} *Preconditions*: The ranges `[first1, last1)` and `[first2, last2)` are sorted with respect to `comp` and
`proj1` or `proj2`, respectively.

[3]{.pnum} *Returns*: `true` if and only if `[first2, last2)` is a subsequence of `[first1, last1)`.

[*Note 1*: A sequence *`S`* is a subsequence of another sequence *`T`* if *`S`* can be obtained from *`T`* by removing
some, all, or none of *`T`*'s elements and keeping the remaining elements in the same order. — *end note*]

[4]{.pnum} *Complexity*: At most `2 * ((last1 - first1) + (last2 - first2)) - 1` comparisons and applications of each
projection.

## Modify [set.union]{- .sref} ## {#modify_set_union}

<!-- [For `set_*` algorithms, would it make sense to describe more formally what it means for an element to be present in a set?
The notion is actively used in the wording, while its meaning is non-trivial in the case of multiple equivalent elements,
requiring extra clarifications in Remarks.]{.draftnote audience="LWG"} -->

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_union_result<I1, I2, O>
    ranges::set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_union_result<I1, I2, O>
    ranges::set_union(Ep&& exec, I1 first1, S1 last1,
                      I2 first2, S2 last2, O result, OutS result_last,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         @_sized-random-access-range_@ OutR, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::set_union(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

::: rm
[1]{.pnum} Let `comp` be `less{}`, and `proj1` and `proj2` be `identity{}` for the overloads with no parameters by those
names.
:::

::: add
[x]{.pnum} Let:

- [x.1]{.pnum} `comp` be `less{}`, and `proj1` and `proj2` be `identity{}` for the overloads with no parameters by those names;
- [x.2]{.pnum} *`M`* be `(last1 - first1)` plus the number of elements in `[first2, last2)` that are not present in `[first1, last1)`;
- [x.3]{.pnum} `result_last` be `result + @_M_@` for the overloads with no parameter `result_last` or `result_r`;
- [x.4]{.pnum} *`N`* be min(`@_M_@`, `result_last - result`).
:::

[2]{.pnum} *Preconditions*: The ranges `[first1, last1)` and `[first2, last2)` are sorted with respect to `comp` and
`proj1` or `proj2`, respectively. The resulting range does not overlap with either of the original ranges.

[3]{.pnum} *Effects*: Constructs a sorted union of [the]{.rm}[*`N`*]{.add} elements from the two ranges; that is, the set of
elements that are present in one or both of the ranges.

[4]{.pnum} *Returns*: [Let `result_last` be the end of the constructed range. Returns]{.rm}

- [4.1]{.pnum} `result_last` for the overloads in namespace `std`.
- [4.2]{.pnum} `{last1, last2, @[result_last]{.rm}[result + _N_]{.add}@}` for the overloads in namespace
  `ranges`[, if *`N `* is equal to *`M`*]{.add}.
- [4.x]{.pnum} [Otherwise, `{j1, j2, result_last}` for the overloads in namespace `ranges`,
  where the iterators `j1` and `j2` point to positions past the last copied or skipped elements in `[first1, last1)` and
  `[first2, last2)`, respectively.]{.add}

[5]{.pnum} *Complexity*: At most `2 * ((last1 - first1) + (last2 - first2)) - 1` comparisons and applications of each
projection.

[6]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}). If `[first1, last1)` contains *m*
elements that are equivalent to each other and `[first2, last2)` contains *n* elements that are equivalent to them,
then all *m* elements from the first range are copied to the output range, in order, and then
the final max(*n* − *m*, 0) elements from the second range are copied to the output range, in order.

## Modify [set.intersection]{- .sref} ## {#modify_set_intersection}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_intersection_result<I1, I2, O>
    ranges::set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::set_intersection(R1&& r1, R2&& r2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_intersection_result<I1, I2, O>
    ranges::set_intersection(Ep&& exec, I1 first1, S1 last1,
                             I2 first2, S2 last2, O result, OutS result_last,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         @_sized-random-access-range_@ OutR, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::set_intersection(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

::: rm
[1]{.pnum} Let `comp` be `less{}`, and `proj1` and `proj2` be `identity{}` for the overloads with no parameters by those
names.
:::

::: add
[x]{.pnum} Let

- [x.1]{.pnum} `comp` be `less{}`, and `proj1` and `proj2` be `identity{}` for the overloads with no parameters by those
  names;
- [x.2]{.pnum} *`M`* be the number of elements in `[first1, last1)` that are present in `[first2, last2)`;
- [x.3]{.pnum} `result_last` be `result + @_M_@` for the overloads with no parameter `result_last` or `result_r`;
- [x.4]{.pnum} *`N`* be min(*`M`*, `result_last - result`).
:::

[2]{.pnum} *Preconditions*: The ranges `[first1, last1)` and `[first2, last2)` are sorted with respect to `comp` and `proj1`
or `proj2`, respectively. The resulting range does not overlap with either of the original ranges.

[3]{.pnum} *Effects*: Constructs a sorted intersection of [the]{.rm}[*`N`*]{.add} elements from the two ranges; that is,
the set of elements that are present in both of the ranges.

[4]{.pnum} *Returns*: [Let `result_last` be the end of the constructed range. Returns]{.rm}

- [4.1]{.pnum} `result_last` for the overloads in namespace `std`.
- [4.2]{.pnum} `{last1, last2, @[result_last]{.rm}[result + _N_]{.add}@}`for the overloads in namespace
  `ranges`[, if *`N`* is equal to *`M`*]{.add}.
- [4.x]{.pnum} [Otherwise, `{j1, j2, result_last}` for the overloads in namespace
  `ranges`, where the iterators `j1` and `j2` point to positions past the last copied or skipped elements in
  `[first1, last1)` and `[first2, last2)`, respectively.]{.add}

[5]{.pnum} *Complexity*: At most `2 * ((last1 - first1) + (last2 - first2)) - 1` comparisons and applications of each
projection.

[6]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}). If `[first1, last1)` contains *m* elements that are
equivalent to each other and `[first2, last2)` contains *n* elements that are equivalent to them, the first
min(*m*, *n*) elements are copied from the first range to the output range, in order.

## Modify [set.difference]{- .sref} ## {#modify_set_difference}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_difference_result<I1, O>
    ranges::set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_difference_result<borrowed_iterator_t<R1>, O>
    ranges::set_difference(R1&& r1, R2&& r2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_difference_result<I1, O>
    ranges::set_difference(Ep&& exec, I1 first1, S1 last1,
                           I2 first2, S2 last2, O result, OutS result_last,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         @_sized-random-access-range_@ OutR, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<OutR>>
    ranges::set_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

::: rm
[1]{.pnum} Let `comp` be `less{}`, and `proj1` and `proj2` be `identity{}` for the overloads with no parameters by those
names.
:::

::: add
[x]{.pnum} Let

- [x.1]{.pnum} `comp` be `less{}`, and `proj1` and `proj2` be `identity{}` for the overloads with no parameters by those
  names;
- [x.2]{.pnum} *`M`* be the number of elements in `[first1, last1)` that are not present in `[first2, last2)`;
- [x.3]{.pnum} `result_last` be `result + @_M_@` for the overloads with no parameter `result_last` or `result_r`;
- [x.4]{.pnum} *`N`* be min(*`M`*, `result_last - result`).
:::

[2]{.pnum} *Preconditions*: The ranges `[first1, last1)` and `[first2, last2)` are sorted with respect to `comp` and `proj1`
or `proj2`, respectively. The resulting range does not overlap with either of the original ranges.

[3]{.pnum} *Effects*: Copies [the]{.rm}[*`N`*]{.add} elements of the range `[first1, last1)` which are not present in the
range `[first2, last2)` to the range [beginning at `result`]{.rm}[`[result, result + @_N_@)`]{.add}.
The elements in the constructed range are sorted.

[4]{.pnum} *Returns*: [Let `result_last` be the end of the constructed range. Returns]{.rm}

- [4.1]{.pnum} `result_last` for the overloads in namespace `std`.
- [4.2]{.pnum} `{last1, @[result_last]{.rm}[result + _N_]{.add}@}` for the overloads in namespace
  `ranges`[, if *`N`* is equal to *`M`*]{.add}.
- [4.x]{.pnum} [Otherwise, `{j1, result_last}` for the overloads in namespace `ranges`,
  where the iterator `j1` points to the position past the last copied or skipped element in `[first1, last1)`.]{.add}

[5]{.pnum} *Complexity*: At most `2 * ((last1 - first1) + (last2 - first2)) - 1` comparisons and applications of each
projection.

[6]{.pnum} *Remarks*: If `[first1, last1)` contains *m* elements that are equivalent to each other and `[first2, last2)`
contains *n* elements that are equivalent to them, the last max(*m* − *n*, 0) elements from `[first1, last1)` are
copied to the output range, in order.

## Modify [set.symmetric.difference]{- .sref} ## {#modify_set_symmetric_difference}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_symmetric_difference_result<I1, I2, O>
    ranges::set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                     Comp comp = {}, Proj1 proj1 = {},
                                     Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_symmetric_difference_result<borrowed_iterator_t<R1>,
                                                    borrowed_iterator_t<R2>, O>
    ranges::set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_symmetric_difference_result<I1, I2, O>
    ranges::set_symmetric_difference(Ep&& exec, I1 first1, S1 last1,
                                     I2 first2, S2 last2, O result, OutS result_last,
                                     Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         @_sized-random-access-range_@ OutR, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_symmetric_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
    ranges::set_symmetric_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
                                     Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

::: rm
[1]{.pnum} Let `comp` be `less{}`, and `proj1` and `proj2` be `identity{}` for the overloads with no parameters by those
names.
:::

::: add
[x]{.pnum} Let

- [x.1]{.pnum} `comp` be `less{}`, and `proj1` and `proj2` be `identity{}` for the overloads with no parameters by those
  names;
- [x.2]{.pnum} *`K`* be the number of elements in `[first1, last1)` that are not present in `[first2, last2)`;
- [x.3]{.pnum} *`M`* be the number of elements in `[first2, last2)` that are not present in `[first1, last1)`;
- [x.3]{.pnum} `result_last` be `result + @_K_ + _M_@` for the overloads with no parameter `result_last` or `result_r`;
- [x.4]{.pnum} *`N`* be min(`@_K_ + _M_@`, `result_last - result`).
:::

[2]{.pnum} *Preconditions*: The ranges `[first1, last1)` and `[first2, last2)` are sorted with respect to `comp` and `proj1`
or `proj2`, respectively. The resulting range does not overlap with either of the original ranges.

[3]{.pnum} *Effects*: Copies the elements of the range `[first1, last1)` that are not present in the range
`[first2, last2)`, and the elements of the range `[first2, last2)` that are not present in the range `[first1, last1)` to
the range [beginning at `result`]{.rm}[`[result, result + @_N_@)`]{.add}. The elements in the constructed range are sorted.

[4]{.pnum} *Returns*:[ Let `result_last` be the end of the constructed range. Returns]{.rm}

- [4.1]{.pnum} `result_last` for the overloads in namespace `std`.
- [4.2]{.pnum} ``{last1, last2, @@[result_last]{.rm}[`result + @_N_@`]{.add}@@}`` for the overloads in
  namespace `ranges`[, if *`N`* is equal to `@_K_@ + @_M_@`]{.add}.
- [4.x]{.pnum} [Otherwise, `{j1, j2, result_last}` for the overloads in namespace `ranges`,
  where the iterators `j1` and `j2` point to positions past the last copied or skipped elements in `[first1, last1)`
  and `[first2, last2)`, respectively.]{.add}

[5]{.pnum} *Complexity*: At most `2 * ((last1 - first1) + (last2 - first2)) - 1` comparisons and applications of each
projection.

[6]{.pnum} *Remarks*: Stable ([algorithm.stable]{- .sref}). If `[first1, last1)` contains *m* elements that are
equivalent to each other and `[first2, last2)` contains *n* elements that are equivalent to them, then |*m* − *n*|
of those elements shall be copied to the output range: the last *m* − *n* of these elements from `[first1, last1)`
if *m* > *n*, and the last *n* − *m* of these elements from `[first2, last2)` if *m* < *n*. In either
case, the elements are copied in order.

## Modify [is.heap]{- .sref} ## {#modify_is_heap}

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_heap(R&& r, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::is_heap_until(first, last, comp, proj) == last;`

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  bool ranges::is_heap(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  bool ranges::is_heap(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
*Effects*: Equivalent to: `return ranges::is_heap_until(std::forward<Ep>(exec), first, last, comp, proj) == last;`
:::

```cpp
template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  I ranges::is_heap_until(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  borrowed_iterator_t<R>
    ranges::is_heap_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

6 Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

7 *Returns*: The last iterator `i` in `[first, last]` for which the range `[first, i)` is a heap with respect to `comp`
and `proj`.

8 *Complexity*: Linear.

## Modify [alg.min.max]{- .sref} ## {#modify_alg_min_max}

```cpp
template<input_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  constexpr range_value_t<R>
    ranges::min(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  range_value_t<R>
    ranges::min(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

[5]{.pnum} *Preconditions*: `ranges::distance(r) > 0`. For the overloads in namespace `std`, `T` meets the
*Cpp17CopyConstructible* requirements. For the first form, `T` meets the *Cpp17LessThanComparable* requirements (Table 29).

[6]{.pnum} *Returns*: The smallest value in the input range. Returns a copy of the leftmost element when several elements
are equivalent to the smallest.

[7]{.pnum} *Complexity*: Exactly `ranges::distance(r) - 1` comparisons and twice as many applications of the projection,
if any.

[8]{.pnum} *Remarks*: An invocation may explicitly specify an argument for the template parameter `T` of the overloads in
namespace `std`.

```cpp
template<input_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  constexpr range_value_t<R>
    ranges::max(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  range_value_t<R>
    ranges::max(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

[13]{.pnum} *Preconditions*: `ranges::distance(r) > 0`. For the overloads in namespace `std`, `T` meets the
*Cpp17CopyConstructible* requirements. For the first form, `T` meets the *Cpp17LessThanComparable* requirements (Table 29).

[14]{.pnum} *Returns*: The largest value in the input range. Returns a copy of the leftmost element when several elements
are equivalent to the largest.

[15]{.pnum} *Complexity*: Exactly `ranges::distance(r) - 1` comparisons and twice as many applications of the projection,
if any.

[16]{.pnum} *Remarks*: An invocation may explicitly specify an argument for the template parameter `T` of the overloads in
namespace `std`.

```cpp
template<input_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  constexpr ranges::minmax_result<range_value_t<R>>
    ranges::minmax(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
  ranges::minmax_result<range_value_t<R>>
    ranges::minmax(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

[21]{.pnum} *Preconditions*: `ranges::distance(r) > 0`. For the overloads in namespace `std`, `T` meets the
*Cpp17CopyConstructible* requirements. For the first form, type `T` meets the *Cpp17LessThanComparable* requirements
(Table 29).

[22]{.pnum} *Returns*: Let `X` be the return type. Returns `X{x, y}`, where `x` is a copy of the leftmost element with the
smallest value and `y` a copy of the rightmost element with the largest value in the input range.

[23]{.pnum} *Complexity*: At most (3/2)`ranges::distance(r)` applications of the corresponding predicate and twice as many
applications of the projection, if any.

[24]{.pnum} *Remarks*: An invocation may explicitly specify an argument for the template parameter `T` of the overloads in
namespace `std`.

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::min_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::min_element(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  I ranges::min_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  borrowed_iterator_t<R>
    ranges::min_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

[25]{.pnum} Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

[26]{.pnum} *Returns*: The first iterator `i` in the range `[first, last)` such that for every iterator `j` in the range
`[first, last)`,

`bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))`

is `false`. Returns `last` if `first == last`.

[27]{.pnum} *Complexity*: Exactly max(`last - first - 1`, 0) comparisons and twice as many projections.

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::max_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::max_element(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  I ranges::max_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  borrowed_iterator_t<R>
    ranges::max_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

[28]{.pnum} Let `comp` be `less{}` and `proj` be `identity{}` for the overloads with no parameters by those names.

[29]{.pnum} *Returns*: The first iterator `i` in the range `[first, last)` such that for every iterator `j` in the range
`[first, last)`,

`bool(invoke(comp, invoke(proj, *i), invoke(proj, *j)))`

is `false`. Returns `last` if `first == last`.

[30]{.pnum} *Complexity*: Exactly max(`last - first - 1`, 0) comparisons and twice as many projections.

```cpp
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  constexpr ranges::minmax_element_result<I>
    ranges::minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr ranges::minmax_element_result<borrowed_iterator_t<R>>
    ranges::minmax_element(R&& r, Comp comp = {}, Proj proj = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S,
         class Proj = identity,
         indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
  ranges::minmax_element_result<I>
    ranges::minmax_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R, class Proj = identity,
         indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  ranges::minmax_element_result<borrowed_iterator_t<R>>
    ranges::minmax_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
```
:::

[31]{.pnum} *Returns*: `{first, first}` if `[first, last)` is empty, otherwise `{m, M}`, where `m` is the first iterator in
`[first, last)` such that no iterator in the range refers to a smaller element, and where `M` is the last iterator in
`[first, last)` such that no iterator in the range refers to a larger element.

[32]{.pnum} *Complexity*: Let *N* be `last - first`. At most  max(⌊$\frac{3}{2}$(*N* − 1)⌋, 0) comparisons and twice
as many applications of the projection, if any.

## Modify [alg.lex.comparison]{- .sref} ## {#modify_alg_lex_comparison}

```cpp
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<I1, Proj1>,
                                    projected<I2, Proj2>> Comp = ranges::less>
  constexpr bool
    ranges::lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Proj1 = identity,
         class Proj2 = identity,
         indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  constexpr bool
    ranges::lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
```

::: add
```cpp
template<@_execution-policy_@ Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
         random_access_iterator I2, sized_sentinel_for<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less>
  bool ranges::lexicographical_compare(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
                                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@_execution-policy_@ Ep, @_sized-random-access-range_@ R1, @_sized-random-access-range_@ R2,
         class Proj1 = identity, class Proj2 = identity,
         indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  bool ranges::lexicographical_compare(Ep&& exec, R1&& r1, R2&& r2, Comp comp = {},
                                       Proj1 proj1 = {}, Proj2 proj2 = {});
```
:::

[1]{.pnum} *Returns*: `true` if and only if the sequence of elements defined by the range `[first1, last1)` is
lexicographically less than the sequence of elements defined by the range `[first2, last2)`.

[2]{.pnum} *Complexity*: At most 2 min(`last1 - first1`, `last2 - first2`) applications of the corresponding comparison and
each projection, if any.

[3]{.pnum} *Remarks*: If two sequences have the same number of elements and their corresponding elements (if any) are
equivalent, then neither sequence is lexicographically less than the other. If one sequence is a proper prefix of the
other, then the shorter sequence is lexicographically less than the longer sequence. Otherwise, the lexicographical
comparison of the sequences yields the same result as the comparison of the first corresponding pair of elements that are
not equivalent.

[4]{.pnum}

::: example
 `ranges::lexicographical_compare(I1, S1, I2, S2, Comp, Proj1, Proj2)` can be implemented as:

```cpp
for ( ; first1 != last1 && first2 != last2 ; ++first1, (void) ++first2) {
  if (invoke(comp, invoke(proj1, *first1), invoke(proj2, *first2))) return true;
  if (invoke(comp, invoke(proj2, *first2), invoke(proj1, *first1))) return false;
}
return first1 == last1 && first2 != last2;
```
:::

[5]{.pnum} [*Note 1*: An empty sequence is lexicographically less than any non-empty sequence, but not less than any empty
sequence. — *end note*]

## Modify [memory.syn]{- .sref} ## {#modify_memory_syn}

<!-- [Parallel overloads of the C++17 specialized `<memory>` algorithms exist only in the `<memory>` synopsis.
We followed the same approach for the new overloads in the `std::ranges` namespace. Should it be changed?]{.draftnote audience="LWG"} -->

```cpp
@_// [specialized.algorithms], specialized algorithms_@
@_// [special.mem.concepts], special memory concepts_@
template<class I>
  concept @_nothrow-input-iterator_@ = @_see below_@;       @_// exposition only_@
template<class I>
  concept @_nothrow-forward-iterator_@ = @_see below_@;     @_// exposition only_@
```
::: add
```cpp
template<class I>
  concept @_nothrow-bidirectional-iterator_@ = @_see below_@;  @_// exposition only_@
template<class I>
  concept @_nothrow-random-access-iterator_@ = @_see below_@;  @_// exposition only_@
```
:::

```cpp
template<class S, class I>
  concept @_nothrow-sentinel-for_@ = @_see below_@;         @_// exposition only_@
```
::: add
```cpp
template<class S, class I>
  concept @_nothrow-sized-sentinel-for_@ = @_see below_@;   @_// exposition only_@
```
:::
```cpp
template<class R>
  concept @_nothrow-input-range_@ = @_see below_@;          @_// exposition only_@
template<class R>
  concept @_nothrow-forward-range_@ = @_see below_@;        @_// exposition only_@
```
::: add
```cpp
template<class I>
  concept @_nothrow-bidirectional-range_@ = @_see below_@;     @_// exposition only_@
template<class I>
  concept @_nothrow-random-access-range_@ = @_see below_@;     @_// exposition only_@
template<class I>
  concept @_nothrow-sized-random-access-range_@ = @_see below_@;     @_// exposition only_@
```
:::

```diff
namespace ranges {
  template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
    requires default_initializable<iter_value_t<I>>
      I uninitialized_default_construct(I first, S last);                         @_// freestanding_@
  template<@_nothrow-forward-range_@ R>
    requires default_initializable<range_value_t<R>>
      borrowed_iterator_t<R> uninitialized_default_construct(R&& r);              @_// freestanding_@

  template<@_nothrow-forward-iterator_@ I>
    requires default_initializable<iter_value_t<I>>
      I uninitialized_default_construct_n(I first, iter_difference_t<I> n);       @_// freestanding_@

+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for_@<I> S>
+    requires default_initializable<iter_value_t<I>>
+      I uninitialized_default_construct(Ep&& exec,        @_// freestanding-deleted_,@
+                                        I first, S last); @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-sized-random-access-range_@ R>
+    requires default_initializable<range_value_t<R>>
+      borrowed_iterator_t<R> uninitialized_default_construct(Ep&& exec, @_// freestanding-deleted_,@
+                                                             R&& r);    @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
+    requires default_initializable<iter_value_t<I>>
+      I uninitialized_default_construct_n(Ep&& exec, I first,      @_// freestanding-deleted_,@
+                                          iter_difference_t<I> n); @_// see [algorithms.parallel.overloads]_@
}

namespace ranges {
  template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
    requires default_initializable<iter_value_t<I>>
      I uninitialized_value_construct(I first, S last);                           @_// freestanding_@
  template<@_nothrow-forward-range_@ R>
    requires default_initializable<range_value_t<R>>
      borrowed_iterator_t<R> uninitialized_value_construct(R&& r);                @_// freestanding_@

  template<@_nothrow-forward-iterator_@ I>
    requires default_initializable<iter_value_t<I>>
      I uninitialized_value_construct_n(I first, iter_difference_t<I> n);         @_// freestanding_@

+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for<_@I> S>
+    requires default_initializable<iter_value_t<I>>
+      I uninitialized_value_construct(Ep&& exec,                      @_// freestanding-deleted_,@
+                                      I first, S last);               @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-sized-random-access-range_@ R>
+    requires default_initializable<range_value_t<R>>
+      borrowed_iterator_t<R> uninitialized_value_construct(Ep&& exec, @_// freestanding-deleted_,@
+                                                           R&& r);    @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
+    requires default_initializable<iter_value_t<I>>
+      I uninitialized_value_construct_n(Ep&& exec, I first,           @_// freestanding-deleted_,@
+                                        iter_difference_t<I> n);      @_// see [algorithms.parallel.overloads]_@
}

namespace ranges {
  template<class I, class O>
    using uninitialized_copy_result = in_out_result<I, O>;                        @_// freestanding_@
  template<input_iterator I, sentinel_for<I> S1,
           @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S2>
    requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
      uninitialized_copy_result<I, O>
        uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);               @_// freestanding_@
  template<input_range IR, @_nothrow-forward-range_@ OR>
    requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
      uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
        uninitialized_copy(IR&& in_range, OR&& out_range);                        @_// freestanding_@

  template<class I, class O>
    using uninitialized_copy_n_result = in_out_result<I, O>;                      @_// freestanding_@
  template<input_iterator I, @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S>
    requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
      uninitialized_copy_n_result<I, O>
        uninitialized_copy_n(I ifirst, iter_difference_t<I> n,                    @_// freestanding_@
                             O ofirst, S olast);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S1,
+           @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S2>
+    requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
+      uninitialized_copy_result<I, O>
+        uninitialized_copy(Ep&& exec, I ifirst, S1 ilast,       @_// freestanding-deleted_,@
+                           O ofirst, S2 olast);                 @_// see [algorithms.parallel.overloads]_@
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ IR, @_nothrow-sized-random-access-range_@ OR>
+    requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
+      uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
+        uninitialized_copy(Ep&& exec, IR&& in_range,            @_// freestanding-deleted_,@
+                           OR&& out_range);                     @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, random_access_iterator I, @_nothrow-random-access-iterator_@ O,
+          @_nothrow-sized-sentinel-for_@<O> S>
+    requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
+      uninitialized_copy_n_result<I, O>
+        uninitialized_copy_n(Ep&& exec, I ifirst, iter_difference_t<I> n, @_// freestanding-deleted_,@
+                             O ofirst, S olast);                          @_// see [algorithms.parallel.overloads]_@
}

namespace ranges {
  template<class I, class O>
    using uninitialized_move_result = in_out_result<I, O>;                        @_// freestanding_@
  template<input_iterator I, sentinel_for<I> S1,
           @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S2>
    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
      uninitialized_move_result<I, O>
        uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);              @_// freestanding_@
  template<input_range IR, @_nothrow-forward-range_@ OR>
    requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
      uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
        uninitialized_move(IR&& in_range, OR&& out_range);                       @_// freestanding_@

  template<input_iterator I,
            @_nothrow-forward-iterator_@ O, @_nothrow-sentinel-for_@<O> S>
    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
      uninitialized_move_n_result<I, O>
        uninitialized_move_n(I ifirst, iter_difference_t<I> n,                   @_// freestanding_@
                             O ofirst, S olast);

+  template<@_execution-policy_@ Ep, random_access_iterator I, sized_sentinel_for<I> S1,
+          @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S2>
+    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
+      uninitialized_move_result<I, O>
+        uninitialized_move(Ep&& exec, I ifirst, S1 ilast,  @_// freestanding-deleted_,@
+                           O ofirst, S2 olast);            @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_sized-random-access-range_@ IR, @_nothrow-sized-random-access-range_@ OR>
+    requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
+      uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
+        uninitialized_move(Ep&& exec, IR&& in_range,       @_// freestanding-deleted_,@
+                           OR&& out_range);                @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, random_access_iterator I,
+      @_nothrow-random-access-iterator_@ O, @_nothrow-sized-sentinel-for_@<O> S>
+    requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
+      uninitialized_move_n_result<I, O>
+        uninitialized_move_n(Ep&& exec, I ifirst, iter_difference_t<I> n, @_// freestanding-deleted_,@
+                             O ofirst, S olast);                          @_// see [algorithms.parallel.overloads]_@
}

namespace ranges {
  template<@_nothrow-forward-iterator_@ I, @_nothrow-sentinel-for_@<I> S, class T>
    requires constructible_from<iter_value_t<I>, const T&>
      I uninitialized_fill(I first, S last, const T& x);                          @_// freestanding_@
  template<@_nothrow-forward-range_@ R, class T>
    requires constructible_from<range_value_t<R>, const T&>
      borrowed_iterator_t<R> uninitialized_fill(R&& r, const T& x);               @_// freestanding_@

  template<@_nothrow-forward-iterator_@ I, class T>
    requires constructible_from<iter_value_t<I>, const T&>
      I uninitialized_fill_n(I first, iter_difference_t<I> n, const T& x);        @_// freestanding_@

+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for_@<I> S, class T>
+    requires constructible_from<iter_value_t<I>, const T&>
+      I uninitialized_fill(Ep&& exec, I first, S last,                      @_// freestanding-deleted_,@
+                           const T& x);                                     @_// see [algorithms.parallel.overloads]_@
+  template<@_execution-policy_@ Ep, @_nothrow-sized-random-access-range_@ R, class T>
+    requires constructible_from<range_value_t<R>, const T&>
+      borrowed_iterator_t<R> uninitialized_fill(Ep&& exec, R&& r,           @_// freestanding-deleted_,@
+                                                const T& x);                @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, class T>
+    requires constructible_from<iter_value_t<I>, const T&>
+      I uninitialized_fill_n(Ep&& exec, I first,                            @_// freestanding-deleted_,@
+                             iter_difference_t<I> n, const T& x);           @_// see [algorithms.parallel.overloads]_@
}

namespace ranges {
  template<@_nothrow-input-iterator_@ I, @_nothrow-sentinel-for_@<I> S>
    requires destructible<iter_value_t<I>>
      constexpr I destroy(I first, S last) noexcept;                              @_// freestanding_@
  template<@_nothrow-input-range_@ R>
    requires destructible<range_value_t<R>>
      constexpr borrowed_iterator_t<R> destroy(R&& r) noexcept;                   @_// freestanding_@

  template<@_nothrow-input-iterator_@ I>
    requires destructible<iter_value_t<I>>
      constexpr I destroy_n(I first, iter_difference_t<I> n) noexcept;            @_// freestanding_@

+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I, @_nothrow-sized-sentinel-for_@<I> S>
+    requires destructible<iter_value_t<I>>
+      I destroy(Ep&& exec,                                           @_// freestanding-deleted_,@
+                I first, S last) noexcept;                           @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-sized-random-access-range_@ R>
+    requires destructible<range_value_t<R>>
+      borrowed_iterator_t<R> destroy(Ep&& exec,                      @_// freestanding-deleted_,@
+                                     R&& r) noexcept;                @_// see [algorithms.parallel.overloads]_@
+
+  template<@_execution-policy_@ Ep, @_nothrow-random-access-iterator_@ I>
+    requires destructible<iter_value_t<I>>
+      I destroy_n(Ep&& exec, I first,                                @_// freestanding-deleted_,@
+                  iter_difference_t<I> n) noexcept;                  @_// see [algorithms.parallel.overloads]_@
}
```

## Add exposition only concepts to [special.mem.concepts]{- .sref} ## {#modify_special_mem_concepts}

```cpp
template<class S, class I>
concept @_nothrow-sentinel-for_@ = sentinel_for<S, I>; @_// exposition only_@
```

Types `S` and `I` model `@_nothrow-sentinel-for_@` only if no exceptions are thrown from copy construction,
move construction, copy assignment, move assignment, or comparisons between valid values of type `I` and `S`.

[*Note X*: This concept allows some `sentinel_for` ([iterator.concept.sentinel]) operations to throw exceptions. — *end note*]

::: add
```cpp
template<class S, class I>
concept @_nothrow-sized-sentinel-for_@ = @_// exposition only_@
  @_nothrow-sentinel-for_@<S, I> &&
  sized_sentinel_for<S, I>;
```

Types `S` and `I` model `@_nothrow-sized-sentinel-for_@` only if no exceptions are thrown from the `-` operator
for valid values of type `I` and `S`.

[*Note X*: This concept allows some `sized_sentinel_for` ([iterator.concept.sizedsentinel]) operations to throw exceptions. — *end note*]
:::

```cpp
template<class I>
concept @_nothrow-forward-iterator_@ = @_// exposition only_@
  @_nothrow-input-iterator_@<I> &&
  forward_iterator<I> &&
  @_nothrow-sentinel-for_@<I, I>;
```

[*Note X*: This concept allows some `forward_iterator` ([iterator.concept.forward]) operations to throw exceptions. — *end note*]

```cpp
template<class R>
concept @_nothrow-forward-range_@ = @_// exposition only_@
  @_nothrow-input-range_@<R> &&
  @_nothrow-forward-iterator_@<iterator_t<R>>;
```

::: add
```cpp
template<class I>
concept @_nothrow-bidirectional-iterator_@ = @_// exposition only_@
  @_nothrow-forward-iterator_@<I> &&
  bidirectional_iterator<I>;
```

A type `I` models `@_nothrow-bidirectional-iterator_@` only if no exceptions are thrown from decrementing valid iterators.

[*Note X*: This concept allows some `bidirectional_iterator` ([iterator.concept.bidir]) operations to throw exceptions. — *end note*]

```cpp
template<class R>
concept @_nothrow-bidirectional-range_@ = @_// exposition only_@
  @_nothrow-forward-range_@<R> &&
  @_nothrow-bidirectional-iterator_@<iterator_t<R>>;
```
```cpp
template<class I>
concept @_nothrow-random-access-iterator_@ = @_// exposition only_@
  @_nothrow-bidirectional-iterator_@<I> &&
  random_access_iterator<I> &&
  @_nothrow-sized-sentinel-for_@<I, I>;
```

A type `I` models `@_nothrow-random-access-iterator_@` only if no exceptions are thrown from comparisons of valid
iterators, or the `-`, `+`, `-=`, `+=`, `[]` operators on valid values of type `I` and `iter_difference_t<I>`.

[*Note X*: This concept allows some `random_access_iterator` ([iterator.concept.random.access]) operations to throw exceptions. — *end note*]

```cpp
template<class R>
concept @_nothrow-random-access-range_@ = @_// exposition only_@
  @_nothrow-bidirectional-range_@<R> &&
  @_nothrow-random-access-iterator_@<iterator_t<R>>;

template<class R>
concept @_nothrow-sized-random-access-range_@ = @_// exposition only_@
  @_nothrow-random-access-range_@<R> && sized_range<R>;
```

A type `R` models *`nothrow-sized-random-access-range`* only if no exceptions are thrown from the call to `ranges::size`
on an object of type `R`.
:::

# Revision history # {#revision_history}

## R8 => R9 ## {#r8_r9}

- Make cosmetic improvements to formal wording

## R7 => R8 ## {#r7_r8}

- Significantly improve wording after multiple LWG review sessions

## R6 => R7 ## {#r6_r7}

- Update the design description and the wording to reflect the LEWG decision on where algorithms with bounded output
  should stop
- Mark new overloads as *freestanding-deleted*
- Rename the *`random-access-sized-range`* exposition only concept to *`sized-random-access-range`*
- Improve the wording for `copy_if`, `remove_copy[_if]`, `unique_copy`, and `merge`
- Put the questions we have for LWG as drafting notes next to the relevant wording

## R5 => R6 ## {#r5_r6}

- Add `rotate_copy` back into the scope
- Fix wording for `reverse_copy` and `merge`
- Mention the consequences of the bounded output for algorithm return values
- Explain the design choices for `rotate_copy`, `reverse_copy`, and `partition_copy`
- Add missing wording for the remaining algorithms: `set_union`, `set_intersection`, `set_difference`,
  `set_symmetric_difference`, and `partition_copy`
- Update analysis on using views in parallel context

## R4 => R5 ## {#r4_r5}

- Add the necessary wording to [algorithm.syn]{- .sref}
- Add the contextual algorithms description to the wording, even if no changes are made
- Add *`random-access-sized-range`* as an exposition-only concept for wording simplification
- Suggest to bump the existing feature testing macro as was voted in LEWG
- Shorten the `ExecutionPolicy` parameter, italicize *`execution-policy`* concept in wording
- Support `result_last` or similar for the algorithms where range-as-the-output is a novelty
  (`copy`, `transform`, etc.), unless stated otherwise in "Issues to address" or in "Out-of-scope"
- Modify `fill` and `generate` algorithms family to use `indirectly_writable` instead of `output_iterator` and
  `output_range` for design consistency
- Add sentinel-for-output for `copy_n` algorithm family
- Add short descriptions of the new exposition-only concepts to the design overview
- Remove `rotate_copy` from scope due to design issues

## R3 => R4 ## {#r3_r4}

- Revert back to range-as-the-output design aspect, change the formal wording accordingly
- Revert back to requiring all ranges to be sized (`&&` instead of `||`)
- Clarify which execution policies are supported
- Clarify that new APIs extend algorithm function objects in `std::ranges`
- Add the feature test macro
- Add implementation experience and thoughts on implementability
- Fix known bugs in the signatures
- Address other feedback from SG1 and SG9:
    - Decide on constraining the execution policy template parameter
    - List all the algorithms that are being given execution policy overloads
    - List range algorithms that are being excluded

## R2 => R3 ## {#r2_r3}

- Use `iterator` as an output
- Add wording

## R1 => R2 ## {#r1_r2}

- Summarize proposed differences from the serial range algorithms and from the non-range parallel algorithms
- Allow all but one input sequences to be unbounded
- List existing algorithms that take ranges for output
- Update arguments and mitigation for using ranges for output
- Add more arguments in support of random access ranges
- Fix the signatures of `for_each` to match the proposed design

## R0 => R1 ## {#r0_r1}

- Address the feedback from SG1 and SG9 review
- Add more information about iterator constraints
- Propose `range` as an output for the algorithms
- Require ranges to be bounded

# Polls # {#polls}

## LEWG, Hagenberg, 2025 ## {#lewg_hagenberg_2025}

**Poll 1**: In "copy_if" and similar algorithms modify the behaviour into: return the first element
which wasn’t copied which comply with the predicate or sentinel.
<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>11
    <td>12
    <td>1
    <td>0
    <td>0
  </tr>
</table>

**Poll 2**: Apply the design and wording changes described above and forward P3179R7 including following algorithms:
"contains", "for_each", "for_each_n", "copy", "copy_n", "copy_if", "rotate_copy",  "reverse_copy", "partition_copy",
"merge", "set_union" and algorithms with the similar pattern and forward the paper to LWG for C++26.
<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>11
    <td>9
    <td>2
    <td>0
    <td>0
  </tr>
</table>

## SG9, Wroclaw, 2024 ## {#sg9_wroclaw_2024}

**Poll 1**: Change `mismatch` and `equal` to require `sized_range` for both inputs ("`&&` instead of `||`").
<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>4
    <td>3
    <td>1
    <td>0
    <td>0
  </tr>
</table>

**Poll 2**: Change `transform` to require `sized_range` for both inputs ("`&&` instead of `||`"),
with the plan to relax these constraints once we have a way to statically detect infinite ranges.
<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>3
    <td>3
    <td>0
    <td>1
    <td>1
  </tr>
</table>

**Poll 3**: We want to remove the "legacy" overload that includes only an iterator as output for convenience, because we know it's unsafe.
<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>4
    <td>4
    <td>0
    <td>0
    <td>0
  </tr>
</table>

**Poll 4** Forward [@P3179R3] with the changes in [@P3490R0] (as updated above) to LEWG for inclusion in C++26 with these changes polled above.

<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>4
    <td>5
    <td>0
    <td>0
    <td>0
  </tr>
</table>

## SG1, Wroclaw, 2024 ## {#sg1_wroclaw_2024}

Forward [@P3179R3] to LEWG with the following notes:

1. The intention is that algorithms call `begin`/`end` only once, in serial code
     (we do not think any new words are needed)
2. The intention is that `mismatch`, `transform` and `equal` assume the unsized range
     is at least as large as the sized one (UB / precondition) or require && sized

<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>4
    <td>8
    <td>0
    <td>0
    <td>0
  </tr>
</table>

## Joint SG1 + SG9, St. Louis, 2024 ## {#sg1_sg9_st_louis_2024}

**Poll**: Continue work on [@P3179R2] for IS'26 with these notes:
1. RandomAccess for inputs and outputs
2. Iterators for outputs
3. We believe the overloads are worth it

<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>7
    <td>4
    <td>2
    <td>1
    <td>0
  </tr>
</table>

## SG9, Tokyo, 2024 ## {#sg9_tokyo_2024}

**Poll 1**: `for_each` shouldn't return the callable
<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>2
    <td>4
    <td>2
    <td>0
    <td>0
  </tr>
</table>

**Poll 2**: Parallel `std::ranges` algos should return the same type as serial `std::ranges` algos

<table>
  <tr>
    <td>Unanimous consent.
  </tr>
</table>

**Poll 3**: Parallel ranges algos should require `forward_range`, not `random_access_range`

<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>3
    <td>2
    <td>3
    <td>1
    <td>1
  </tr>
</table>

**Poll 4**: Range-based parallel algos should require const operator()

<table>
  <tr>
    <th>SF
    <th>F
    <th>N
    <th>A
    <th>SA
  </tr>
  <tr>
    <td>0
    <td>7
    <td>2
    <td>0
    <td>0
  </tr>
</table>

# Acknowledgments # {#acknowledgements}

- Thanks to Jonathan Mueller for the wording review and providing useful feedback.
- Thanks to Mikhail Dvorskiy for the implementation experience.
