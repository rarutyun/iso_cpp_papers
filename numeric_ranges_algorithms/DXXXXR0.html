<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-05-19" />
  <title>Parallel and non-parallel numeric range algorithms</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
</style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ background-color: #f6f8fa; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { } 
code span.al { color: #ff0000; } 
code span.an { } 
code span.at { } 
code span.bn { color: #9f6807; } 
code span.bu { color: #9f6807; } 
code span.cf { color: #00607c; } 
code span.ch { color: #9f6807; } 
code span.cn { } 
code span.co { color: #008000; font-style: italic; } 
code span.cv { color: #008000; font-style: italic; } 
code span.do { color: #008000; } 
code span.dt { color: #00607c; } 
code span.dv { color: #9f6807; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #9f6807; } 
code span.fu { } 
code span.im { } 
code span.in { color: #008000; } 
code span.kw { color: #00607c; } 
code span.op { color: #af1915; } 
code span.ot { } 
code span.pp { color: #6f4e37; } 
code span.re { } 
code span.sc { color: #9f6807; } 
code span.ss { color: #9f6807; } 
code span.st { color: #9f6807; } 
code span.va { } 
code span.vs { color: #9f6807; } 
code span.wa { color: #008000; font-weight: bold; } 
code.diff {color: #898887}
code.diff span.va {color: #00AA00}
code.diff span.st {color: #bf0303}
</style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "ยง"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "โต"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Parallel and non-parallel
numeric range algorithms</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>DXXXXR0</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2025-05-19</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      SG1,SG9,LEWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Ruslan Arutyunyan<br>&lt;<a href="mailto:ruslan.arutyunyan@intel.com" class="email">ruslan.arutyunyan@intel.com</a>&gt;<br>
      Mark Hoemmen<br>&lt;<a href="mailto:mhoemmen@nvidia.com" class="email">mhoemmen@nvidia.com</a>&gt;<br>
      Alexey Kukanov<br>&lt;<a href="mailto:alexey.kukanov@intel.com" class="email">alexey.kukanov@intel.com</a>&gt;<br>
      Bryce Adelstein Lelbach<br>&lt;<a href="mailto:brycelelbach@gmail.com" class="email">brycelelbach@gmail.com</a>&gt;<br>
      Abhilash Majumder<br>&lt;<a href="mailto:abmajumder@nvidia.com" class="email">abmajumder@nvidia.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#authors" id="toc-authors"><span class="toc-section-number">1</span> Authors</a></li>
<li><a href="#revision-history" id="toc-revision-history"><span class="toc-section-number">2</span> Revision history</a></li>
<li><a href="#abstract" id="toc-abstract"><span class="toc-section-number">3</span> Abstract</a></li>
<li><a href="#design" id="toc-design"><span class="toc-section-number">4</span> Design</a>
<ul>
<li><a href="#what-algorithms-to-include" id="toc-what-algorithms-to-include"><span class="toc-section-number">4.1</span> What algorithms to include?</a>
<ul>
<li><a href="#what-we-propose" id="toc-what-we-propose"><span class="toc-section-number">4.1.1</span> What we propose</a></li>
<li><a href="#current-set-of-numeric-algorithms" id="toc-current-set-of-numeric-algorithms"><span class="toc-section-number">4.1.2</span> Current set of numeric
algorithms</a></li>
<li><a href="#transform_-algorithms-andor-projections" id="toc-transform_-algorithms-andor-projections"><span class="toc-section-number">4.1.3</span> <code>transform_*</code>
algorithms (and/or projections)</a></li>
<li><a href="#the-lost-algorithm-noncommutative-parallel-reduction" id="toc-the-lost-algorithm-noncommutative-parallel-reduction"><span class="toc-section-number">4.1.4</span> โThe lost algorithmโ:
Noncommutative parallel reduction?</a></li>
<li><a href="#algorithms-with-a-ranges-proposal-in-flight" id="toc-algorithms-with-a-ranges-proposal-in-flight"><span class="toc-section-number">4.1.5</span> Algorithms with a ranges
proposal in flight</a></li>
<li><a href="#algorithms-that-do-not-need-ranges-versions" id="toc-algorithms-that-do-not-need-ranges-versions"><span class="toc-section-number">4.1.6</span> Algorithms that do not need
ranges versions</a></li>
<li><a href="#we-dont-propose-reduce_first" id="toc-we-dont-propose-reduce_first"><span class="toc-section-number">4.1.7</span> We donโt propose
<code>reduce_first</code></a></li>
<li><a href="#we-dont-propose-reduce_with_iter" id="toc-we-dont-propose-reduce_with_iter"><span class="toc-section-number">4.1.8</span> We donโt propose
<code>reduce_with_iter</code></a></li>
<li><a href="#summary-algorithms-that-we-propose-here" id="toc-summary-algorithms-that-we-propose-here"><span class="toc-section-number">4.1.9</span> Summary: Algorithms that we
propose here</a></li>
</ul></li>
<li><a href="#range-categories-and-return-types" id="toc-range-categories-and-return-types"><span class="toc-section-number">4.2</span> Range categories and return
types</a></li>
<li><a href="#constexpr-parallel-algorithms" id="toc-constexpr-parallel-algorithms"><span class="toc-section-number">4.3</span> Constexpr parallel
algorithms?</a></li>
<li><a href="#rangesreduce-design" id="toc-rangesreduce-design"><span class="toc-section-number">4.4</span> <code>ranges::reduce</code>
design</a>
<ul>
<li><a href="#no-default-parameters" id="toc-no-default-parameters"><span class="toc-section-number">4.4.1</span> No default parameters</a></li>
<li><a href="#for-return-type-imitate-rangesfold_left-not-stdreduce" id="toc-for-return-type-imitate-rangesfold_left-not-stdreduce"><span class="toc-section-number">4.4.2</span> For return type, imitate
<code>ranges::fold_left</code>, not <code>std::reduce</code></a></li>
</ul></li>
<li><a href="#constraining-parallel-ranges-numeric-algorithms" id="toc-constraining-parallel-ranges-numeric-algorithms"><span class="toc-section-number">4.5</span> Constraining parallel ranges
numeric algorithms</a></li>
</ul></li>
<li><a href="#implementation" id="toc-implementation"><span class="toc-section-number">5</span> Implementation</a></li>
<li><a href="#wording" id="toc-wording"><span class="toc-section-number">6</span> Wording</a>
<ul>
<li><a href="#update-feature-test-macro" id="toc-update-feature-test-macro"><span class="toc-section-number">6.1</span> Update feature test macro</a></li>
<li><a href="#change-numeric.ops.overview" id="toc-change-numeric.ops.overview"><span class="toc-section-number">6.2</span> Change [numeric.ops.overview]</a>
<ul>
<li><a href="#add-declaration-of-exposition-only-concepts" id="toc-add-declaration-of-exposition-only-concepts"><span class="toc-section-number">6.2.1</span> Add declaration of
exposition-only concepts</a></li>
<li><a href="#add-declarations-of-parallel-ranges-reduce-overloads" id="toc-add-declarations-of-parallel-ranges-reduce-overloads"><span class="toc-section-number">6.2.2</span> Add declarations of parallel
ranges <code>reduce</code> overloads</a></li>
<li><a href="#add-declarations-of-parallel-ranges-inclusive_scan" id="toc-add-declarations-of-parallel-ranges-inclusive_scan"><span class="toc-section-number">6.2.3</span> Add declarations of parallel
ranges <code>inclusive_scan</code></a></li>
<li><a href="#add-declarations-of-parallel-ranges-exclusive_scan" id="toc-add-declarations-of-parallel-ranges-exclusive_scan"><span class="toc-section-number">6.2.4</span> Add declarations of parallel
ranges <code>exclusive_scan</code></a></li>
<li><a href="#add-wording-for-algorithms" id="toc-add-wording-for-algorithms"><span class="toc-section-number">6.2.5</span> Add wording for
algorithms</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 data-number="1" id="authors"><span class="header-section-number">1</span> Authors<a href="#authors" class="self-link"></a></h1>
<ul>
<li><p>Ruslan Arutyunyan (Intel)</p></li>
<li><p>Mark Hoemmen (NVIDIA)</p></li>
<li><p>Alexey Kukanov (Intel)</p></li>
<li><p>Bryce Adelstein Lelbach (NVIDIA)</p></li>
<li><p>Abhilash Majumder (NVIDIA)</p></li>
</ul>
<h1 data-number="2" id="revision-history"><span class="header-section-number">2</span> Revision history<a href="#revision-history" class="self-link"></a></h1>
<ul>
<li>Revision 0 to be submitted 2025-??-??</li>
</ul>
<h1 data-number="3" id="abstract"><span class="header-section-number">3</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>We propose ranges overloads (both parallel and nonparallel) of the
following algorithms.</p>
<ul>
<li><p><code>reduce</code>, unary <code>transform_reduce</code>, and
binary <code>transform_reduce</code></p></li>
<li><p><code>inclusive_scan</code> and
<code>transform_inclusive_scan</code></p></li>
<li><p><code>exclusive_scan</code> and
<code>transform_exclusive_scan</code></p></li>
</ul>
<p>We also propose adding convenience wrappers <code>ranges::sum</code>
and <code>ranges::product</code> for special cases of
<code>reduce</code> with addition and multiplication, respectively.</p>
<h1 data-number="4" id="design"><span class="header-section-number">4</span> Design<a href="#design" class="self-link"></a></h1>
<h2 data-number="4.1" id="what-algorithms-to-include"><span class="header-section-number">4.1</span> What algorithms to include?<a href="#what-algorithms-to-include" class="self-link"></a></h2>
<h3 data-number="4.1.1" id="what-we-propose"><span class="header-section-number">4.1.1</span> What we propose<a href="#what-we-propose" class="self-link"></a></h3>
<p>We propose ranges overloads (both parallel and nonparallel) of the
following algorithms.</p>
<ul>
<li><p><code>reduce</code>, unary <code>transform_reduce</code>, and
binary <code>transform_reduce</code></p></li>
<li><p><code>inclusive_scan</code> and
<code>transform_inclusive_scan</code></p></li>
<li><p><code>exclusive_scan</code> and
<code>transform_exclusive_scan</code></p></li>
</ul>
<p>We also propose parallel and non-parallel convenience wrappers
<code>ranges::sum(r)</code> as
<code>ranges::reduce(r, plus{}, range_value_t&lt;R&gt;())</code> and
<code>ranges::product(r)</code> as
<code>ranges::reduce(r, multiplies{}, range_value_t&lt;R&gt;(1))</code>.</p>
<p>The following sections explain why we propose these algorithms and
not others. This relates to other aspects of the design besides
algorithm selection, such as whether to include optional projection
parameters.</p>
<h3 data-number="4.1.2" id="current-set-of-numeric-algorithms"><span class="header-section-number">4.1.2</span> Current set of numeric
algorithms<a href="#current-set-of-numeric-algorithms" class="self-link"></a></h3>
<p><a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a>,
โC++ Parallel Range Algorithms,โ is in the last stages of wording review
as of the publication date. P3179R8 explicitly defers adding ranges
versions of the numeric algorithms. This proposal does that. As such, we
focus on the numeric algorithms, that is, the 11 algorithms in
<a href="https://eel.is/c++draft/numeric.ops">[numeric.ops]</a>.</p>
<ul>
<li><p><code>iota</code></p></li>
<li><p><code>accumulate</code></p></li>
<li><p><code>inner_product</code></p></li>
<li><p><code>partial_sum</code></p></li>
<li><p><code>adjacent_difference</code></p></li>
<li><p><code>reduce</code></p></li>
<li><p><code>inclusive_scan</code></p></li>
<li><p><code>exclusive_scan</code></p></li>
<li><p><code>transform_reduce</code></p></li>
<li><p><code>transform_inclusive_scan</code></p></li>
<li><p><code>transform_exclusive_scan</code></p></li>
</ul>
<p>We donโt have to add ranges versions of all these algorithms. Several
already have a ranges version in C++23, possibly with a different name.
Some others could be omitted because they have straightforward
replacements using existing views and other ranges algorithms. We
carefully read the two proposals
<a href="https://wg21.link/P2214R2">P2214R2</a>, โA Plan for C++23
Ranges,โ and <a href="https://wg21.link/P2760R1">P2760R1</a>, โA Plan
for C++26 Ranges,โ in order to inform our algorithm selections. In some
cases that we will explain below, usability and performance concerns led
us to disagree with their conclusions.</p>
<h3 data-number="4.1.3" id="transform_-algorithms-andor-projections"><span class="header-section-number">4.1.3</span> <code>transform_*</code>
algorithms (and/or projections)<a href="#transform_-algorithms-andor-projections" class="self-link"></a></h3>
<h4 data-number="4.1.3.1" id="summary"><span class="header-section-number">4.1.3.1</span> Summary<a href="#summary" class="self-link"></a></h4>
<p>We propose</p>
<ul>
<li><p>providing both unary and binary
<code>ranges::transform_reduce</code> as well as
<code>ranges::reduce</code>,</p></li>
<li><p>providing <code>ranges::transform_{in,ex}clusive_scan</code> as
well as <code>ranges::{in,ex}clusive_scan</code>, and</p></li>
<li><p><em>not</em> providing projections for any of these
algorithms.</p></li>
</ul>
<h4 data-number="4.1.3.2" id="do-we-want-transform_-algorithms-andor-projections"><span class="header-section-number">4.1.3.2</span> Do we want
<code>transform_*</code> algorithms and/or projections?<a href="#do-we-want-transform_-algorithms-andor-projections" class="self-link"></a></h4>
<p>We start with two questions.</p>
<ol type="1">
<li><p>Should the existing C++17 algorithms
<code>transform_reduce</code>, <code>transform_inclusive_scan</code>,
and <code>transform_exclusive_scan</code> have ranges versions, or does
it suffice to have ranges versions of <code>reduce</code>,
<code>inclusive_scan</code>, and <code>exclusive_scan</code>?</p></li>
<li><p>Should ranges versions of <code>reduce</code>,
<code>inclusive_scan</code>, and <code>exclusive_scan</code> take
optional projections, just like <code>ranges::for_each</code> and other
ranges algorithms do?</p></li>
</ol>
<p>We use words like โshouldโ because the ranges library doesnโt
actually <em>need</em> <code>transform_*</code> algorithms or
projections for functional completeness. These questions are about
usability and optimization, including the way that certain kinds of
ranges constructs can hinder parallelization on different kinds of
hardware.</p>
<h4 data-number="4.1.3.3" id="unary-transforms-projections-and-transform_view-are-functionally-equivalent"><span class="header-section-number">4.1.3.3</span> Unary transforms,
projections, and <code>transform_view</code> are functionally
equivalent<a href="#unary-transforms-projections-and-transform_view-are-functionally-equivalent" class="self-link"></a></h4>
<p>The above two questions are related, since a projection can have the
same effect as a <code>transform_*</code> function. This aligns with
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html#algorithms-should-take-invokable-projections">Section
13.2 of N4128</a>, which explains why ranges algorithms take optional
projections โeverywhere it makes sense.โ</p>
<blockquote>
<p>Wherever appropriate, algorithms should optionally take
<em>INVOKE</em>-able <em>projections</em> that are applied to each
element in the input sequence(s). This, in effect, allows users to
trivially transform each input sequence for the sake of that single
algorithm invocation.</p>
</blockquote>
<p>Projecting the input of <code>reduce</code> has the same effect as
unary <code>transform_reduce</code>. Here is an example, in which
<code>get_element</code> is a customization point object like the one
proposed in <a href="https://wg21.link/p2769r3">P2769R3</a>, such that
<code>get_element&lt;k&gt;</code> gets the <code>k</code>-th element of
an object that participates in the tuple or structured binding
protocol.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_proj <span class="op">=</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span>v1, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_proj <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_xform <span class="op">=</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span>v1, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_xform <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span></code></pre></div>
<p>Even without projections, the <code>transform_*</code> algorithms can
be replaced by a combination of <code>transform_view</code> and the
non-<code>transform</code> algorithm.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_tv <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>, init, std<span class="op">::</span>plus<span class="op">{})</span>;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_tv <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span></code></pre></div>
<h4 data-number="4.1.3.4" id="scan-algorithms-work-like-unary-transform_reduce"><span class="header-section-number">4.1.3.4</span> Scan algorithms work like
unary <code>transform_reduce</code><a href="#scan-algorithms-work-like-unary-transform_reduce" class="self-link"></a></h4>
<p>Regarding scan algorithms,
<a href="https://wg21.link/p2214r2">P2214R2</a> points out that
<code>ranges::transform_inclusive_scan(r, o, f, g)</code> can be
rewritten as
<code>ranges::inclusive_scan(r | views::transform(g), o, f)</code>. The
latter formulation saves users from needing to remember which of
<code>f</code> and <code>g</code> is the transform (unary) operation,
and which is the binary operation. Making the ranges version of the
algorithm take an optional projection would be exactly equivalent to
adding a <code>transform_*</code> version that does not take a
projection: e.g., <code>ranges::inclusive_scan(r, o, f, g)</code> with
<code>g</code> as the projection would do exactly the same thing as
<code>ranges::transform_inclusive_scan(r, o, f, g)</code> with
<code>g</code> as the transform operation.</p>
<h4 data-number="4.1.3.5" id="binary-transform_reduce-is-functionally-equivalent-to-reduce-and-zip_transform_view"><span class="header-section-number">4.1.3.5</span> Binary
<code>transform_reduce</code> is functionally equivalent to
<code>reduce</code> and <code>zip_transform_view</code><a href="#binary-transform_reduce-is-functionally-equivalent-to-reduce-and-zip_transform_view" class="self-link"></a></h4>
<p>Expressing binary <code>transform_reduce</code> using only
<code>reduce</code> requires <code>zip_transform_view</code> or
something like it.</p>
<h4 data-number="4.1.3.6" id="study-rangestransform-for-design-hints"><span class="header-section-number">4.1.3.6</span> Study
<code>ranges::transform</code> for design hints<a href="#study-rangestransform-for-design-hints" class="self-link"></a></h4>
<p>Questions about transforms and projections suggest studying
<code>ranges::transform</code> for design hints. This leads us to two
more questions.</p>
<ol type="1">
<li><p>If transforms and projections are equivalent, then why does
<code>std::ranges::transform</code> take an optional
projection?</p></li>
<li><p>If binary transform is equivalent to unary transform of a
<code>zip_transform_view</code>, then why does binary
<code>std::ranges::transform</code> exist?</p></li>
</ol>
<p>It can help to look at examples. Here is a binary transform example
without projections, that uses a single big lambda. Users have to read
the big lambda to see what it does. So does the compiler, which can
hinder optimization if itโs not good at inlining.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span><span class="dt">int</span>, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v2<span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">13</span>, <span class="st">&quot;thirteen&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">17</span>, <span class="st">&quot;seventeen&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">19</span>, <span class="st">&quot;nineteen&quot;</span><span class="op">}}</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span>std<span class="op">::</span>from_range, std<span class="op">::</span>views<span class="op">::</span>repeat<span class="op">(</span><span class="dv">0</span>, <span class="dv">3</span><span class="op">))</span>;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Without projections: Big, opaque lambda</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, v2, out<span class="op">.</span>begin<span class="op">()</span>,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x, <span class="kw">auto</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>x<span class="op">)</span> <span class="op">+</span> get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>y<span class="op">)</span>; <span class="op">})</span>;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> expected<span class="op">{</span><span class="dv">65</span>, <span class="dv">119</span>, <span class="dv">209</span><span class="op">}</span>;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span></code></pre></div>
<p>Constrast this with use of projections. Users can read out loud what
this does. It also separates the โselectionโ or โqueryโ part of the
transform from the โarithmeticโ or โcomputationโ part. The power of the
ranges abstraction is that users can factor computation on a range from
the logic to iterate over that range. Itโs natural to extend this
separation to selection logic as well.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span><span class="dt">int</span>, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v2<span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">13</span>, <span class="st">&quot;thirteen&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">17</span>, <span class="st">&quot;seventeen&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">19</span>, <span class="st">&quot;nineteen&quot;</span><span class="op">}}</span>;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span>std<span class="op">::</span>from_range, std<span class="op">::</span>views<span class="op">::</span>repeat<span class="op">(</span><span class="dv">0</span>, <span class="dv">3</span><span class="op">))</span>;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">// With projections: More readable</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, v2, out<span class="op">.</span>begin<span class="op">()</span>,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> expected<span class="op">{</span><span class="dv">65</span>, <span class="dv">119</span>, <span class="dv">209</span><span class="op">}</span>;</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span></code></pre></div>
<p>Itโs harder to avoid a lambda in the unary transform case. Most of
the named C++ Standard Library arithmetic function objects are binary.
Currying them into unary functions in C++ requires either making a
lambda (which defeats the purpose somewhat) or using something like
<code>std::bind</code> (which is verbose). On the other hand, using a
projection still has the benefit of separating the โselectionโ part of
the transform from the โcomputationโ part.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span>std<span class="op">::</span>from_range, std<span class="op">::</span>views<span class="op">::</span>repeat<span class="op">(</span><span class="dv">0</span>, <span class="dv">3</span><span class="op">))</span>;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> expected<span class="op">{</span><span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">12</span><span class="op">}</span>;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Unary transform without projection</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, out<span class="op">.</span>begin<span class="op">()</span>, <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>x<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span>; <span class="op">})</span>;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Unary transform with projection</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, out<span class="op">.</span>begin<span class="op">()</span>, <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span>; <span class="op">}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Unary transform with projection and &quot;curried&quot; plus</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>ranges<span class="op">::</span>transform<span class="op">(</span>v1, out<span class="op">.</span>begin<span class="op">()</span>, std<span class="op">::</span>bind<span class="op">(</span>std<span class="op">::</span>plus<span class="op">{}</span>, <span class="dv">1</span><span class="op">)</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>out <span class="op">==</span> expected<span class="op">)</span>;</span></code></pre></div>
<h4 data-number="4.1.3.7" id="reduce-transforms-and-projections"><span class="header-section-number">4.1.3.7</span> <code>reduce</code>:
transforms and projections<a href="#reduce-transforms-and-projections" class="self-link"></a></h4>
<p>We return to the <code>reduce</code> examples we showed above, but
this time, we focus on their readability.</p>
<h5 data-number="4.1.3.7.1" id="unary-transform_reduce"><span class="header-section-number">4.1.3.7.1</span> Unary
<code>transform_reduce</code><a href="#unary-transform_reduce" class="self-link"></a></h5>
<p>A <code>ranges::reduce</code> that takes a projection is functionally
equivalent to unary <code>transform_reduce</code> without a projection.
If ranges algorithms take projections whenever possible, then the name
<code>transform_reduce</code> is redundant here. Readers should know
that any extra function argument of a ranges algorithm is most likely a
projection. Either way โ <code>reduce</code> with projection, or unary
<code>transform_reduce</code> โ is straightforward to read, and
separates selection (<code>get_element&lt;0&gt;</code>) from computation
(<code>std::plus</code>).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">// reduce with projection get_element&lt;0&gt;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_proj <span class="op">=</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span>v1, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_proj <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">// transform_reduce with transform get_element&lt;0&gt;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_xform <span class="op">=</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span>v1, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>;</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_xform <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">// reduce with transform_view (no projection)</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_xv <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>, init, std<span class="op">::</span>plus<span class="op">{})</span>;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_xv <span class="op">==</span> <span class="dv">26</span><span class="op">)</span>;</span></code></pre></div>
<p>On the other hand, ranges algorithms take projections whenever
possible, and <code>std::ranges::transform</code> takes a projection.
Why canโt <code>transform_reduce</code> take a projection? For unary
<code>transform_reduce</code>, this arguably makes the order of
operations less clear. The projection happens first, but most users
would have to think about that. A lambda or named function would improve
readability.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> bar <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>string s;</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, std<span class="op">::</span>string, bar<span class="op">&gt;&gt;</span> v<span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <span class="dv">5</span>,   <span class="st">&quot;five&quot;</span>, <span class="op">{</span><span class="st">&quot;x&quot;</span>, <span class="dv">13</span><span class="op">}}</span>,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <span class="dv">7</span>,  <span class="st">&quot;seven&quot;</span>, <span class="op">{</span><span class="st">&quot;y&quot;</span>, <span class="dv">17</span><span class="op">}}</span>,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">11</span>, <span class="st">&quot;eleven&quot;</span>, <span class="op">{</span><span class="st">&quot;z&quot;</span>, <span class="dv">19</span><span class="op">}}}</span>;</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">// first get bar, then get bar::i</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  v, init, std<span class="op">::</span>plus<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{}</span>, get_element<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;{})</span>;</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_proj <span class="op">==</span> <span class="dv">52</span><span class="op">)</span>;</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">// first get bar, then get bar::i</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> getter <span class="op">=</span> <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{}(</span>get_element<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;{}(</span>t<span class="op">))</span>;</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_no_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  v, init, std<span class="op">::</span>plus<span class="op">{}</span>, getter<span class="op">)</span>;</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_no_proj <span class="op">==</span> <span class="dv">52</span><span class="op">)</span>;</span></code></pre></div>
<h5 data-number="4.1.3.7.2" id="binary-transform_reduce"><span class="header-section-number">4.1.3.7.2</span> Binary
<code>transform_reduce</code><a href="#binary-transform_reduce" class="self-link"></a></h5>
<p>Expressing binary <code>transform_reduce</code> using only
<code>reduce</code> requires <code>zip_transform_view</code> or
something like it. The <code>reduce</code>-only version is more verbose.
On the other hand, itโs a toss-up which version is easier to understand.
Users either need to learn what a โzip transform viewโ does, or they
need to learn about <code>transform_reduce</code> and know which of the
two function arguments does what. They may also find it troublesome that
<code>zip_view</code> and <code>zip_transform_view</code> are not
pipeable: there is no <code>{v1, v2} | views::zip</code> syntax, for
example.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span>std<span class="op">::</span>string, <span class="dt">int</span><span class="op">&gt;&gt;</span> v2<span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="st">&quot;thirteen&quot;</span>, <span class="dv">13</span><span class="op">}</span>, <span class="op">{</span><span class="st">&quot;seventeen&quot;</span>, <span class="dv">17</span><span class="op">}</span>, <span class="op">{</span><span class="st">&quot;nineteen&quot;</span>, <span class="dv">19</span><span class="op">}}</span>;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>; </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span>std<span class="op">::</span>from_range, std<span class="op">::</span>views<span class="op">::</span>repeat<span class="op">(</span><span class="dv">0</span>, <span class="dv">3</span><span class="op">))</span>;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_bztv <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>reduce<span class="op">(</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>zip_transform<span class="op">(</span>std<span class="op">::</span>multiplies<span class="op">{}</span>,</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>,</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v2, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{}))</span>,</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  init, std<span class="op">::</span>plus<span class="op">{})</span>;</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_bztv <span class="op">==</span> <span class="dv">396</span><span class="op">)</span>;</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_no_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>,</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v2, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{})</span>,</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  out<span class="op">.</span>begin<span class="op">()</span>, init, std<span class="op">::</span>plus<span class="op">{}</span>, std<span class="op">::</span>multiplies<span class="op">{})</span>;</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_no_proj <span class="op">==</span> <span class="dv">396</span><span class="op">)</span>;</span></code></pre></div>
<p>C++17 binary <code>transform_reduce</code> does not take a
projection. Instead, it takes a binary transform function, that combines
elements from the two input ranges into a single element. The algorithm
then reduces these elements using the binary reduce function and the
initial value. Itโs perhaps misleading that this binary function is
called a โtransformโ; itโs really a kind of reduction on corresponding
elements of the two input ranges.</p>
<p>One can imagine a ranges analog of C++17 binary
<code>transform_reduce</code> that takes two projection functions, as in
the example below. Itโs not too hard for a casual reader to tell that
the last two arguments of <code>reduce</code> apply to each of the input
sequences in turn, but thatโs still more consecutive function arguments
than any other algorithm in the C++ Standard Library. Without
projections, users would need to resort to <code>transform_view</code>,
but this more verbose syntax makes it more clear which functions do
what.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{}</span>;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, foo, std<span class="op">::</span>string<span class="op">&gt;&gt;</span> v1<span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="dv">5</span>, <span class="op">{}</span>, <span class="st">&quot;five&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">7</span>, <span class="op">{}</span>, <span class="st">&quot;seven&quot;</span><span class="op">}</span>, <span class="op">{</span><span class="dv">11</span>, <span class="op">{}</span>, <span class="st">&quot;eleven&quot;</span><span class="op">}}</span>;</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>std<span class="op">::</span>pair<span class="op">&lt;</span>std<span class="op">::</span>string, <span class="dt">int</span><span class="op">&gt;&gt;</span> v2<span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="st">&quot;thirteen&quot;</span>, <span class="dv">13</span><span class="op">}</span>, <span class="op">{</span><span class="st">&quot;seventeen&quot;</span>, <span class="dv">17</span><span class="op">}</span>, <span class="op">{</span><span class="st">&quot;nineteen&quot;</span>, <span class="dv">19</span><span class="op">}}</span>;</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="dt">int</span> init <span class="op">=</span> <span class="dv">3</span>; </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> out<span class="op">(</span>std<span class="op">::</span>from_range, std<span class="op">::</span>views<span class="op">::</span>repeat<span class="op">(</span><span class="dv">0</span>, <span class="dv">3</span><span class="op">))</span>;</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">// With projections</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span>v1, v2, out<span class="op">.</span>begin<span class="op">()</span>, init,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>plus<span class="op">{}</span>, std<span class="op">::</span>multiplies<span class="op">{}</span>, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{}</span>, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{})</span>;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_proj <span class="op">==</span> <span class="dv">396</span><span class="op">)</span>;</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Without projections</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result_no_proj <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>transform_reduce<span class="op">(</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v1, get_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{})</span>,</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>v2, get_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;{})</span>,</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  out<span class="op">.</span>begin<span class="op">()</span>, init, std<span class="op">::</span>plus<span class="op">{}</span>, std<span class="op">::</span>multiplies<span class="op">{})</span>;</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>result_no_proj <span class="op">==</span> <span class="dv">396</span><span class="op">)</span>;</span></code></pre></div>
<h4 data-number="4.1.3.8" id="mixed-guidance-from-the-current-ranges-library"><span class="header-section-number">4.1.3.8</span> Mixed guidance from the
current ranges library<a href="#mixed-guidance-from-the-current-ranges-library" class="self-link"></a></h4>
<p>The current ranges library offers only mixed guidance for deciding
whether <code>*reduce</code> algorithms should take projections.</p>
<p>The various <code>fold_*</code> algorithms take no projections.
Section 4.6 of <a href="https://wg21.link/P2322R6">P2322R6</a> explains
that the <code>fold_left_first</code> algorithm does not take a
projection in order to avoid an extra copy of the leftmost value, that
would be required in order to support projections with a range whose
iterators yield proxy reference types like
<code>tuple&lt;T&amp;&gt;</code> (as <code>views::zip</code> does).
P2322R6 clarifies that <code>fold_left_first</code>,
<code>fold_right_last</code>, and <code>fold_left_first_with_iter</code>
all have this issue. However, the remaining two <code>fold_*</code>
algorithms <code>fold_left</code> and <code>fold_right</code> do not.
This is because they never need to materialize an input value; they can
just project each element at iterator <code>iter</code> via
<code>invoke(proj, *iter)</code>, and feed that directly into the binary
operation. The author of P2322R6 has elected to omit projections for all
five <code>fold_*</code> algorithms, so that they have a consistent
interface.</p>
<p>A ranges version of <code>reduce</code> does not have
<code>fold_left_first</code>โs design issue. C++17 algorithms in the
<code>reduce</code> family can copy results as much as they like, so
that would be less of a concern here. However, if we ever wanted a
<code>ranges::reduce_first</code> algorithm, then the consistency
argument would arise.</p>
<h4 data-number="4.1.3.9" id="transform_view-not-always-trivially-copyable-even-when-function-object-is"><span class="header-section-number">4.1.3.9</span>
<code>*transform_view</code> not always trivially copyable even when
function object is<a href="#transform_view-not-always-trivially-copyable-even-when-function-object-is" class="self-link"></a></h4>
<p>Use of <code>transform_view</code> and
<code>zip_transform_view</code> can make it harder for implementations
to parallelize ranges algorithms. The problem is that both views might
not necessarily be trivially copyable, even if their function object is.
If a range isnโt trivially copyable, then the implementation must do
more work beyond just a <code>memcpy</code> or equivalent in order to
get copies of the range to different parallel execution units.</p>
<p>Here is an example
(<a href="https://godbolt.org/z/vYnzGd3js">Compiler Explorer
link</a>).</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Function object type that acts just like f2 below.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> F3 <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y;</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>vector v<span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span>;</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// operator= is defaulted; lambda type is trivially copyable</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> f1 <span class="op">=</span> <span class="op">[]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span>;</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>f1<span class="op">)&gt;)</span>;</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Capture means that lambda&#39;s operator= is deleted,</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// but lambda type is still trivially copyable</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> f2 <span class="op">=</span> <span class="op">[</span>y <span class="op">=</span> <span class="dv">1</span><span class="op">]</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y;</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>f2<span class="op">)&gt;)</span>;</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">// decltype(view1) is trivially copyable</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> view1 <span class="op">=</span> v <span class="op">|</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>f1<span class="op">)</span>;</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>view1<span class="op">)&gt;)</span>;</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">// decltype(view2) is NOT trivially copyable, even though f2 is</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> view2 <span class="op">=</span> v <span class="op">|</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>f2<span class="op">)</span>; </span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(!</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>view2<span class="op">)&gt;)</span>;</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">// view3 is trivally copyable, though it behaves just like view2.</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>  F3 f3<span class="op">{}</span>;</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> view3 <span class="op">=</span> v <span class="op">|</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>f3<span class="op">)</span>;</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_trivially_copyable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>view3<span class="op">)&gt;)</span>;</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Both lambdas <code>f1</code> and <code>f2</code> are trivially
copyable, but <code>std::views::transform(f2)</code> is <em>not</em>
trivally copyable. The wording for both <code>transform_view</code> and
<code>zip_transform_view</code> expresses the input function object of
type <code>F</code> as stored in an exposition-only
<em><code>movable-box&lt;F&gt;</code></em> member. <code>f2</code> has a
capture that gives it a <code>=delete</code>d copy assignment operator.
Nevertheless, <code>f2</code> is still trivially copyable, because each
of its default copy and move operations is either trivial or deleted,
and its destructor is nontrivial and deleted.</p>
<p>The problem is <em><code>movable-box</code></em>. As
[range.move.wrap] 1.3 explains, since
<code>copyable&lt;decltype(f2)&gt;</code> is not modeled,
<em><code>movable-box</code></em><code>&lt;decltype(f2)&gt;</code>
provides a nontrivial, not deleted copy assignment operator. This makes
<em><code>movable-box</code></em><code>&lt;decltype(f2)&gt;</code>, and
therefore <code>transform_view</code> and
<code>zip_transform_view</code>, not trivially copyable.</p>
<p>This feels like a wording bug. <code>f2</code> is a struct with one
member, an <code>int</code>, and a call operator. Why canโt I
<code>memcpy</code> <code>views::transform(f2)</code> wherever I need it
to go? Even worse, <code>f3</code> is a struct just like
<code>f2</code>, yet <code>views::transform(f3)</code> is trivially
copyable.</p>
<p>Implementations can work around this in different ways. For example,
an implementation of <code>std::ranges::reduce</code> could have a
specialization for the range being
<code>zip_transform_view&lt;F, V1, V2&gt;</code> that reaches inside the
<code>zip_transform_view</code>, pulls out the function object and
views, and calls the equivalent of binary <code>transform_reduce</code>
with them. However, the ranges library generally wasnโt designed to make
such transformations easy to implement in portable C++. Views generally
donโt expose their members โ an issue that hinders all kinds of
optimizations. (For instance, it should be possible for compilers to
transform <code>cartesian_product_view</code> of bounded
<code>iota_view</code> into OpenACC or OpenMP multidimensional nested
loops for easier optimization, but <code>cartesian_product_view</code>
does not have a standard way to get at its member view(s).) As a result,
an approach based on specializing algorithms for specific view types
means that implementations cannot straightforwardly depend on a
third-party ranges implementation for their views. Parallel algorithm
implementers generally prefer to minimize coupling of actual parallel
algorithms with Standard Library features that donโt directly relate to
parallel execution.</p>
<h4 data-number="4.1.3.10" id="review"><span class="header-section-number">4.1.3.10</span> Review<a href="#review" class="self-link"></a></h4>
<p>Letโs review what we learned from the above discussion.</p>
<ol type="1">
<li><p>In general and particularly for <code>ranges::transform</code>,
projections improve readability and expose optimization potential, by
separating the selection part of an algorithm from the computation
part.</p></li>
<li><p>None of the existing <code>fold_*</code> ranges algorithms (the
closest things the Standard Library currently has to
<code>ranges::reduce</code>) take projections.</p></li>
<li><p>Ranges <code>reduce</code> with a projection and unary
<code>transform_reduce</code> without a projection have the same
functionality, without much usability or implementation difference.
Ditto for <code>{in,ex}clusive_scan</code> with a projection and
<code>transform_{in,ex}clusive_scan</code> without.</p></li>
<li><p>Expressing binary <code>transform_reduce</code> using only
<code>reduce</code> requires <code>zip_transform_view</code>
<em>always</em>, even if the two input ranges are contiguous ranges of
<code>int</code>. This hinders readability and potentially also
performance.</p></li>
<li><p>A ranges version of binary <code>transform_reduce</code> that
takes projections is harder to use and read than a version without
projections. However, a version without projections would need
<code>transform_view</code> in order to offer the same functionality.
This potentially hinders performance.</p></li>
</ol>
<h4 data-number="4.1.3.11" id="conclusions"><span class="header-section-number">4.1.3.11</span> Conclusions<a href="#conclusions" class="self-link"></a></h4>
<p>We propose</p>
<ul>
<li><p>providing both unary and binary
<code>ranges::transform_reduce</code> as well as
<code>ranges::reduce</code>,</p></li>
<li><p>providing <code>ranges::transform_{in,ex}clusive_scan</code> as
well as <code>ranges::{in,ex}clusive_scan</code>, and</p></li>
<li><p><em>not</em> providing projections for any of these
algorithms.</p></li>
</ul>
<p>We conclude this based on a chain of reasoning, starting with binary
<code>transform_reduce</code>.</p>
<ol type="1">
<li><p>We want binary <code>transform_reduce</code> for usability and
performance reasons. (The โtransformโ of a binary
<code>transform_reduce</code> is <em>not</em> the same thing as a
projection.)</p></li>
<li><p>Itโs inconsistent to have binary <code>transform_reduce</code>
without unary <code>transform_reduce</code>.</p></li>
<li><p>Projections tend to hinder usability of both unary and binary
<code>transform_reduce</code>. If we have unary
<code>transform_reduce</code>, we donโt need <code>reduce</code> with a
projection.</p></li>
<li><p>We already have <code>fold_*</code> (effectively special cases of
<code>reduce</code>) without projections, even though some of the
<code>fold_*</code> algorithms <em>could</em> have had
projections.</p></li>
<li><p>If we have other <code>*reduce</code> algorithms without
projections as well, then the most consistent thing would be for
<em>no</em> reduction algorithms to have projections.</p></li>
<li><p>Itโs more consistent for the various <code>*scan</code>
algorithms to look and act like their <code>*reduce</code> counterparts,
so we provide <code>ranges::transform_{in,ex}clusive_scan</code> as well
as <code>ranges::{in,ex}clusive_scan</code>, and do not provide
projections for any of them.</p></li>
</ol>
<h3 data-number="4.1.4" id="the-lost-algorithm-noncommutative-parallel-reduction"><span class="header-section-number">4.1.4</span> โThe lost algorithmโ:
Noncommutative parallel reduction?<a href="#the-lost-algorithm-noncommutative-parallel-reduction" class="self-link"></a></h3>
<p>The Standard lacks an analog of <code>reduce</code> that can assume
associativity but not commutativity of binary operations. One author of
this proposal refers to this as โthe lost algorithmโ (in e.g.,
<a href="https://adspthepodcast.com/2021/05/14/Episode-25.html">Episode
25 of โASDP: The Podcastโ</a>). To elaborate: The current numeric
algorithms express a variety of permissions to reorder binary
operations.</p>
<ol type="1">
<li><p><code>accumulate</code> and <code>partial_sum</code> both
precisely specify the order of binary operations as sequential, from
left to right. This works even if the binary operation is neither
associative nor commutative.</p></li>
<li><p>The various <code>*_scan</code> algorithms can reorder binary
operations as if they are associative (they may replace
<code>a + (b + c)</code> with <code>(a + b) + c</code>), but not as if
they are commutative (they may replace <code>a + b</code> with
<code>b + a</code>).</p></li>
<li><p><code>reduce</code> can reorder binary operations as if they are
both associative and commutative.</p></li>
</ol>
<p>Whatโs missing here is a parallel analog of <code>reduce</code> with
the assumptions of <code>*_scan</code>, that is, a reduction that can
assume associativity but not commutativity of binary operations.
Parallel reduction operations with these assumptions exist in other
programming models. For example, MPI (the Message Passing Interface for
distributed-memory parallel communication) has a function
<code>MPI_Create_op</code> for defining custom reduction operators from
a userโs function. <code>MPI_Create_op</code> has a parameter that
specifies whether MPI may assume that the userโs function is
commutative.</p>
<p>Users could get a parallel algorithm by calling <code>*_scan</code>
with an extra output sequence, and using only the last element. However,
this requires extra storage.</p>
<p>A concepts-based approach like P1813R0โs could permit specializing
<code>reduce</code> on whether the user asserts that the binary
operation is commutative. P1813R0 does not attempt to do this; it merely
specializes <code>reduce</code> on whether the associative and
commutative operation has a two-sided identity element. Furthermore,
P1813R0 does not offer a way for users to assert that an operation is
associative or commutative, because the <code>magma</code>
(nonassociative) and <code>semigroup</code> (associative) concepts do
not differ syntactically. One could imagine a refinement of this design
that includes a trait for users to specialize on the type of their
binary operation, say <code>is_commutative&lt;BinaryOp&gt;</code>. This
would be analogous to the <code>two_sided_identity</code> trait in
P1813R0 that lets users declare that their set forms a monoid, a
refinement of <code>semigroup</code> with a two-sided identity
element.</p>
<p>This proposal does not attempt to fill this gap in the Standard
parallel algorithms, but would welcome a separate proposal to do so. We
think the right way would be to propose a new algorithm with a distinct
name. A reasonable choice of name would be <code>fold</code> (just
<code>fold</code> by itself, not <code>fold_left</code> or
<code>fold_right</code>).</p>
<h3 data-number="4.1.5" id="algorithms-with-a-ranges-proposal-in-flight"><span class="header-section-number">4.1.5</span> Algorithms with a ranges
proposal in flight<a href="#algorithms-with-a-ranges-proposal-in-flight" class="self-link"></a></h3>
<p>We do not propose a <code>partial_sum</code> algorithm. This
algorithm performs operations sequentially. Its parallel analogs are
<code>inclusive_scan</code> and <code>exclusive_scan</code>, which we
propose here. For the non-parallel ranges version that returns a
stateful binary operator,
<a href="https://wg21.link/P2760R1">P2760R1</a> suggests a view instead
of an algorithm. <a href="https://wg21.link/P3351R2">P3351R2</a>,
โ<code>views::scan</code>,โ proposes this view. P3351R2 is currently in
SG9 (Ranges Study Group) review.</p>
<h3 data-number="4.1.6" id="algorithms-that-do-not-need-ranges-versions"><span class="header-section-number">4.1.6</span> Algorithms that do not need
ranges versions<a href="#algorithms-that-do-not-need-ranges-versions" class="self-link"></a></h3>
<p>The following algorithms do not need ranges versions, since they can
be replaced with existing views and ranges algorithms.</p>
<h4 data-number="4.1.6.1" id="iota"><span class="header-section-number">4.1.6.1</span> <code>iota</code><a href="#iota" class="self-link"></a></h4>
<p>C++23 has <code>iota_view</code>, the view version of
<code>iota</code>. One can replace the <code>iota</code> algorithm with
<code>iota_view</code> and <code>ranges::copy</code>. In fact, one could
argue that <code>iota_view</code> is the perfect use case for a view:
instead of storing the entire range, users can represent it compactly
with two integers. There also should be no optimization concerns with
parallel algorithms over an <code>iota_view</code>. For example, the
Standard specifies <code>iota_view</code> in a way that does not hinder
it from being trivially copyable, as long as its input types are. The
iterator type of <code>iota_view</code> is a random access iterator for
reasonable lower bound types (e.g., integers).</p>
<h4 data-number="4.1.6.2" id="accumulate"><span class="header-section-number">4.1.6.2</span> <code>accumulate</code><a href="#accumulate" class="self-link"></a></h4>
<p>The <code>accumulate</code> algorithm performs operations
sequentially. Its parallel version is <code>reduce</code>, which we
propose here. The non-parallel version has been translated in C++23 into
<code>fold_left</code>.</p>
<h4 data-number="4.1.6.3" id="inner_product"><span class="header-section-number">4.1.6.3</span>
<code>inner_product</code><a href="#inner_product" class="self-link"></a></h4>
<p>The <code>inner_product</code> algorithm performs operations
sequentially. It can be replaced with a ranges version of
<code>transform_reduce</code>. P2214R2 argues specifically against
adding a ranges analog of <code>inner_product</code>, because it is less
fundamental than other algorithms, and because itโs not clear how to
incorporate projections.</p>
<h4 data-number="4.1.6.4" id="adjacent_difference"><span class="header-section-number">4.1.6.4</span>
<code>adjacent_difference</code><a href="#adjacent_difference" class="self-link"></a></h4>
<p><code>adjacent_difference</code> can be replaced with a combination
of <code>adjacent_transform_view</code> (which was adopted in C++23) and
<code>ranges::copy</code>. On the other hand, we argue elsewhere in this
proposal that views (such as <code>adjacent_transform_view</code>) that
use a <em><code>movable-box</code></em><code>&lt;F&gt;</code> member to
represent a function object may have performance issues, due to
<em><code>movable-box&lt;F&gt;</code></em> being not trivially copyable
even for some cases where <code>F</code> is trivially copyable. On the
other hand, the existing <code>adjacent_difference</code> use case could
be covered with the trivially copyable <code>std::minus</code> function
object.</p>
<p>In our experience, adjacent differences or their generalization are
often used in combination with other ranges. For example,
finite-difference methods (such as Runge-Kutta schemes) for solving
time-dependent differential equations may need to add together multiple
ranges, each of which is an adjacent difference possibly composed with
other functions. If users want to express that as a one-pass algorithm,
they might need to combine more than two input ranges, possibly using a
combination of <code>transform_view</code>s and
<code>adjacent_transform_view</code>s. This ultimately would be hard to
express as a single โ<code>ranges::adjacent_transform</code>โ algorithm
invocation. Furthermore, <code>ranges::adjacent_transform</code> is
necessarily single-dimensional. It could not be used straightforwardly
for finite-difference methods for solving partial differential
equations, for example. All this makes an
<code>adjacent_transform</code> algorithm a lower-priority task.</p>
<h3 data-number="4.1.7" id="we-dont-propose-reduce_first"><span class="header-section-number">4.1.7</span> We donโt propose
<code>reduce_first</code><a href="#we-dont-propose-reduce_first" class="self-link"></a></h3>
<p>Section 5.1 of <a href="https://wg21.link/P2760R1">P2760R1</a> asks
whether there should be a <code>reduce_first</code> algorithm, analogous
to <code>fold_left_first</code>, for binary operations that lack a
natural identity element to serve as the initial value. An example would
be <code>min</code> on a range of <code>int</code> values, where callers
would have no way to tell if <code>INT_MAX</code> represents a value in
the range, or an arbitrary stand-in for the (nonexistent) identity
element. We do not propose <code>reduce_first</code> for the following
reasons.</p>
<ol type="1">
<li><p>P3179R8 already proposes parallel ranges overloads of
<code>min_element</code>, <code>max_element</code>, and
<code>minmax_element</code>.</p></li>
<li><p><code>fold_left_first</code> and <code>fold_right_last</code>
makes more sense, because these algorithms are ordered. It matters which
element of the sequence the user extracts. <code>reduce</code> is
unordered, so thereโs no reason to privilege one element over another.
Why should it be the first one?</p></li>
<li><p>Users can always extract the first element from the sequence and
use it as the initial value in <code>reduce</code>.</p></li>
</ol>
<p>The decision to add <code>reduce_first</code> depends on whether
<code>reduce</code> takes a projection. The <code>reduce_first</code>
algorithm could not straightforwardly support projections. If
<code>reduce</code> takes a projection, then it would be inconsistent
with <code>reduce_first</code>. The only reason <code>fold_left</code>
and <code>fold_right</code> do not take projections is for consistency
with <code>fold_left_first</code>, <code>fold_left_with_iter</code>, and
<code>fold_right_last</code>, which cannot take projections. The only
way for us to leave <code>reduce_first</code> for a later proposal is if
<code>reduce</code> does not take a projection.</p>
<h3 data-number="4.1.8" id="we-dont-propose-reduce_with_iter"><span class="header-section-number">4.1.8</span> We donโt propose
<code>reduce_with_iter</code><a href="#we-dont-propose-reduce_with_iter" class="self-link"></a></h3>
<p>A <code>reduce_with_iter</code> algorithm would look like
<code>fold_left_with_iter</code>, but would permit reordering of binary
operations. It would return both an iterator to one past the last
element, and the computed value. A hypothetical
<code>reduce_with_iter</code> algorithm would also return an iterator to
one past the last element, and the computed value, but would share
<code>reduce</code>โs permission to reorder binary operations.</p>
<p>We do not propose the analogous <code>reduce_with_iter</code> here,
though we would not oppose someone else proposing it. That algorithm
would serve users who are writing code generic enough to work with
single-pass input iterators, <em>and</em> who want to expose potential
binary operation reordering opportunities.</p>
<p>Just like <code>fold_left</code>, the <code>reduce</code> algorithm
should return just the computed value. Section 4.4 of
<a href="https://wg21.link/P2322R6">P2322R6</a> argues that this makes
it easier to use, and improves consistency with other ranges algorithms
like <code>ranges::count</code> and <code>ranges::any_of</code>. It is
also consistent with P3179R8. The algorithms
<code>fold_left_with_iter</code> and
<code>fold_left_first_with_iter</code> exist for users who want both the
iterator and the value. Section 4.4 of P2322R6 further elaborates that
<code>fold_left</code> should not be specified in terms of
<code>fold_left_with_iter</code>, for performance reasons: it would
โincur an extra move of the accumulated result, due to lack of copy
elision (we have different return types).โ The <code>*_with_iter</code>
algorithms are separate algorithms that need separate
specifications.</p>
<h3 data-number="4.1.9" id="summary-algorithms-that-we-propose-here"><span class="header-section-number">4.1.9</span> Summary: Algorithms that we
propose here<a href="#summary-algorithms-that-we-propose-here" class="self-link"></a></h3>
<p>We propose providing parallel and non-parallel overloads of</p>
<ul>
<li><p>unary and binary <code>ranges::transform_reduce</code> as well as
<code>ranges::reduce</code>,</p></li>
<li><p><code>ranges::transform_{in,ex}clusive_scan</code> as well as
<code>ranges::{in,ex}clusive_scan</code>, and</p></li>
<li><p>the convenience wrappers <code>ranges::sum(r)</code> as
<code>ranges::reduce(r, plus{}, range_value_t&lt;R&gt;())</code> and
<code>ranges::product(r)</code> as
<code>ranges::reduce(r, multiplies{}, range_value_t&lt;R&gt;(1))</code>,
as proposed in <a href="https://wg21.link/P2760R1">P2760R1</a>.</p></li>
</ul>
<h2 data-number="4.2" id="range-categories-and-return-types"><span class="header-section-number">4.2</span> Range categories and return
types<a href="#range-categories-and-return-types" class="self-link"></a></h2>
<ul>
<li><p>Our parallel algorithms take sized random access ranges.</p></li>
<li><p>Our non-parallel algorithms take sized forward ranges.</p></li>
<li><p>Our scansโ return type is an alias of
<code>in_out_result</code>.</p></li>
<li><p>Our reductions just return the reduction value, not
<code>in_value_result</code> with an input iterator.</p></li>
</ul>
<p>P3179R8 does not aim for perfect consistency with the range
categories accepted by existing ranges algorithms. The algorithms
proposed by P3179R8 differ in the following ways.</p>
<ol type="1">
<li><p>P3179R8 uses a range, not an iterator, as the output parameter
(see Section 2.7).</p></li>
<li><p>P3179R8 requires that the ranges be sized (see Section
2.8).</p></li>
<li><p>P3179R8 requires random access ranges (see Section 2.6).</p></li>
</ol>
<p>Of these differences, (1) and (2) could apply generally to all ranges
algorithms, so we adopt them for this proposal.</p>
<p>Regarding (1), this would make our proposal the first to add
non-parallel range-as-output ranges algorithms to the Standard. For
arguments in favor of non-parallel algorithms taking a range as output,
please refer to <a href="https://wg21.link/P3490R0">P3490R0</a>,
โJustification for ranges as the output of parallel range algorithms.โ
(Despite the title, it has things to say about non-parallel algorithms
too.) Taking a range as output would prevent use of existing output-only
iterators that do not have a separate sized sentinel type, like
<code>std::back_insert_iterator</code>. However, all the algorithms we
propose require at least forward iterators (see below). P3490R0 shows
that it is possible for both iterator-as-output and range-as-output
overloads to coexist, so we follow P3179R8 by not proposing
iterator-as-output algorithms here.</p>
<p>Regarding (2), we make the parallel algorithms proposed here take
sized random access ranges, as P3179R8 does. For consistency, we also
propose that the output ranges be sized. As a result, any parallel
algorithms with an output range need to return both an iterator to one
past the last element of the input, and an iterator to one past the last
element of the input. This tells callers whether there was enough room
in the output, and if not, where to start when processing the rest of
the input. This includes all the <code>*{ex,in}clusive_scan</code>
algorithms we propose.</p>
<p>Difference (3) relates to P3179R8 only proposing parallel algorithms.
It would make sense for us to relax this requirement for the
non-parallel algorithms we propose. This leaves us with two
possibilities:</p>
<ul>
<li><p>(single-pass) input and output ranges, the most general;
or</p></li>
<li><p>(multipass) forward ranges.</p></li>
</ul>
<p>The various reduction and scan algorithms we propose can combine the
elements of the range in any order. For this reason, we make the
non-parallel algorithms take (multipass) forward ranges, even though
this is not consistent with the existing non-parallel
<code>&lt;numeric&gt;</code> algorithms. If users have single-pass
iterators, they should just call one of the <code>fold_*</code>
algorithms, or use the <code>views::scan</code> proposed elsewhere. This
has the benefit of letting us specify <code>ranges::reduce</code> to
return just the value. We donโt propose a separate algorithm
<code>reduce_with_iter</code>, as we explain elsewhere in this
proposal.</p>
<h2 data-number="4.3" id="constexpr-parallel-algorithms"><span class="header-section-number">4.3</span> Constexpr parallel
algorithms?<a href="#constexpr-parallel-algorithms" class="self-link"></a></h2>
<p><a href="https://wg21.link/p2902r1">P2902R1</a> proposes to add
<code>constexpr</code> to the parallel algorithms. P3179R8 does not
object to this; see Section 2.10. We continue the approach of P3179R8 in
not opposing P2902R1โs approach, but also not depending on it.</p>
<h2 data-number="4.4" id="rangesreduce-design"><span class="header-section-number">4.4</span> <code>ranges::reduce</code>
design<a href="#rangesreduce-design" class="self-link"></a></h2>
<p>In this section, we focus on <code>ranges::reduce</code>โs design.
The discussion here applies generally to the other algorithms we
propose.</p>
<h3 data-number="4.4.1" id="no-default-parameters"><span class="header-section-number">4.4.1</span> No default parameters<a href="#no-default-parameters" class="self-link"></a></h3>
<p>Section 5.1 of P2760R1 states:</p>
<blockquote>
<p>One thing is clear: <code>ranges::reduce</code> should <em>not</em>
take a default binary operation <em>nor</em> a default initial
parameter. The user needs to supply both.</p>
</blockquote>
<p>This motivates the convenience wrappers</p>
<ul>
<li><p><code>ranges::sum(r)</code> for
<code>ranges::reduce(r, plus{}, range_value_t&lt;R&gt;())</code>,
and</p></li>
<li><p><code>ranges::product(r)</code> for
<code>ranges::reduce(r, multiplies{}, range_value_t&lt;R&gt;(1))</code>.</p></li>
</ul>
<p>One argument <em>for</em> a default initial value in
<code>std::reduce</code> is that <code>int</code> literals like
<code>0</code> or <code>1</code> do not behave in the expected way with
a sequence of <code>float</code> or <code>double</code>. For
<code>ranges::reduce</code>, however, making its return value type
imitate <code>ranges::fold_left</code> instead of
<code>std::reduce</code> fixes that.</p>
<h3 data-number="4.4.2" id="for-return-type-imitate-rangesfold_left-not-stdreduce"><span class="header-section-number">4.4.2</span> For return type, imitate
<code>ranges::fold_left</code>, not <code>std::reduce</code><a href="#for-return-type-imitate-rangesfold_left-not-stdreduce" class="self-link"></a></h3>
<p>Both <code>std::reduce</code> and <code>std::ranges::fold_left</code>
return the reduction result as a single value. However, they deduce the
return type differently. For <code>ranges::reduce</code>, we deduce the
return type like <code>std::ranges::fold_left</code> does, instead of
always returning the initial value type <code>T</code> like
<code>std::reduce</code>.</p>
<p><a href="https://wg21.link/P2322R6">P2322R6</a>,
โ<code>ranges::fold</code>,โ added the various <code>fold_*</code>
ranges algorithms to C++23. This proposal explains why
<code>std::ranges::fold_left</code> may return a different reduction
type than <code>std::reduce</code> for the same input range, initial
value, and binary operation. Consider the following example, adapted
from Section 3 of P2322R6
(<a href="https://godbolt.org/z/3q71EMTPa">Compiler Explorer
link</a>).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="fl">0.25</span>, <span class="fl">0.75</span><span class="op">}</span>;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>reduce<span class="op">(</span>v<span class="op">.</span>begin<span class="op">()</span>, v<span class="op">.</span>end<span class="op">()</span>, <span class="dv">1</span>, std<span class="op">::</span>plus<span class="op">())</span>;</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)</span>, <span class="dt">int</span><span class="op">&gt;)</span>;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>r <span class="op">==</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>fold_left<span class="op">(</span>v, <span class="dv">1</span>, std<span class="op">::</span>plus<span class="op">())</span>;</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)</span>, <span class="dt">double</span><span class="op">&gt;)</span>;</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>r <span class="op">==</span> <span class="fl">2.0</span><span class="op">)</span>;</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span>;  </span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>std::reduce</code> part of the example expresses a common
user error. <code>ranges::fold_*</code> instead returns โthe decayed
result of invoking the binary operation with <code>T</code> (the initial
value) and the reference type of the range.โ For the above example, this
likely expresses what the user meant. It also works for other common
cases, like proxy reference types with an unambiguous conversion to a
common type with the initial value.</p>
<p>Itโs notable that <code>reduce</code>-like <code>mdspan</code>
algorithms in [linalg] โ <code>dot</code>,
<code>vector_sum_of_squares</code>, <code>vector_two_norm</code>,
<code>vector_abs_sum</code>, <code>matrix_frob_norm</code>,
<code>matrix_one_norm</code>, and <code>matrix_inf_norm</code> โ all
have the same return type behavior as C++17 <code>std::reduce</code>.
However, the authors of [linalg] expect typical users of their library
to prefer complete control of the return type, even if it means they
have to type <code>1.0</code> instead of <code>1</code>. These [linalg]
algorithms also have more precise wording about precision of
intermediate terms in sums when the element types and the initial value
are all floating-point types or specializations of <code>complex</code>.
(See e.g., [linalg.algs.blas1.dot] 7.) For ranges reduction algorithms,
we expect a larger audience of users and thus prefer consistency with
<code>fold_*</code>โs return type.</p>
<h2 data-number="4.5" id="constraining-parallel-ranges-numeric-algorithms"><span class="header-section-number">4.5</span> Constraining parallel ranges
numeric algorithms<a href="#constraining-parallel-ranges-numeric-algorithms" class="self-link"></a></h2>
<ol type="1">
<li><p>We use the same constraints as <code>fold_left</code> and
<code>fold_right</code> to constrain the binary operator of
<code>reduce</code> and <code>*_scan</code>.</p></li>
<li><p>We imitate C++17 parallel algorithms and [linalg]
(<a href="https://wg21.link/P1673R13">P1673R13</a>) by using
<em>GENERALIZED_NONCOMMUTATIVE_SUM</em> and <em>GENERALIZED_SUM</em> to
describe the behavior of <code>reduce</code> and
<code>*_scan</code>.</p></li>
<li><p>Otherwise, we follow the approach of
<a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a> (โC++
Parallel Range Algorithmsโ).</p></li>
</ol>
<p><a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a>,
which is in the last stages of wording review, defines parallel versions
of many ranges algorithms in the C++ Standard Library. (The โparallel
version of an algorithmโ is an overload of an algorithm whose first
parameter is an execution policy.) That proposal restricts itself to
adding parallel versions of existing ranges algorithms. P3179R8
explicitly defers adding overloads to the numeric algorithms in
<a href="https://eel.is/c++draft/numeric.ops">[numeric.ops]</a>, because
these do not yet have ranges versions. Our proposal fills that gap.</p>
<p>WG21 did not have time to propose ranges-based numeric algorithms
with the initial set of ranges algorithms in C++20.
<a href="https://wg21.link/P1813R0">P1813R0</a>, โA Concept Design for
the Numeric Algorithms,โ points out the challenge of defining ranges
versions of the existing parallel numeric algorithms. What makes this
task less straightforward is that the specification of the parallel
numeric algorithms permits them to reorder binary operations like
addition. This matters because many useful number types do not have
associative addition. Lack of associativity is not just a floating-point
rounding error issue; one example is saturating integer arithmetic.
Ranges algorithms are constrained by concepts, but itโs not clear even
if itโs a good idea to define concepts that can express permission to
reorder terms in a sum.</p>
<p>C++17 takes the approach of saying that parallel numeric algorithms
can reorder the binary operations however they like, but does not say
whether any reordering would give the same results as any other
reordering. The Standard expresses this through the wording โmacrosโ
<em>GENERALIZED_NONCOMMUTATIVE_SUM</em> and <em>GENERALIZED_SUM</em>. (A
wording macro is a parameterized abbreviation for a longer sequence of
wording in the Standard. We put โmacrosโ in double quotes because they
are not necessarily preprocessor macros. They might not even be
implementable as such.) Algorithms become ill-formed, no diagnostic
required (IFNDR) if the element types do not define the required
operations. P1813R0 instead defines C++ concepts that represent
algebraic structures, all of which involve a set with a closed binary
operation. Some of the structures require that the operation be
associative and/or commutative. P1813R0 uses those concepts to constrain
the algorithms. This means that the algorithms will not be selected for
overload resolution if the element types do not define the required
operations. It further means that algorithms could (at least in theory)
dispatch based on properties like whether the element typeโs binary
operation is commutative. The concepts include both syntactic and
semantic constraints.</p>
<p>WG21 has not expressed a consensus on P1813R0โs approach. LEWGI
reviewed P1813R0 at the Belfast meeting in November 2019, but did not
forward the proposal and wanted to see it again. Two other proposals
express something more like WG21โs consensus on constraining the numeric
algorithms: <a href="https://wg21.link/P2214R2">P2214R2</a>, โA Plan for
C++23 Ranges,โ and <a href="https://wg21.link/P1673R13">P1673R13</a>, โA
free function linear algebra interface based on the BLAS,โ which defines
mdspan-based analogs of the numeric algorithms. Section 5.1.1 of P2214R2
points out that P1813R0โs approach would overconstrain
<code>fold</code>; P2214R2 instead suggests just constraining the
operation to be binary invocable. This was ultimately the approach taken
by the Standard through the exposition-only concepts
<em><code>indirectly-binary-left-foldable</code></em> and
<em><code>indirectly-binary-right-foldable</code></em>. Section 5.1.2 of
P2214R2 says that <code>reduce</code> โcalls for the kinds of
constraints that P1813R0 is proposing.โ</p>
<p><a href="https://wg21.link/P1673R13">P1673R13</a>, which was adopted
into the Working Draft for C++26 as [linalg], took an entirely different
approach for its set of <code>mdspan</code>-based numeric algorithms.
Section 10.8, โConstraining matrix and vector element types and
scalars,โ explains the argument. Here is a summary.</p>
<ol type="1">
<li><p>Requirements like associativity are too strict to be useful for
practical types. The only number types in the Standard with associative
addition are unsigned integers. Itโs not just a rounding error โepsilonโ
issue; sums of saturating integers can have infinite error if one
assumes associativity.</p></li>
<li><p>โThe algorithm may reorder sumsโ (which is what we want to say)
means something different than โaddition on the terms in the sum is
associativeโ (which is not true for many number types of interest). That
is, permission for an algorithm to reparenthesize sums is not the same
as a concept constraining the terms in the sum.</p></li>
<li><p>P1813R0 defines concepts that generalize a mathematical group.
These are only useful for describing a single set of numbers, that is,
one type. This excludes useful features like mixed precision (e.g.,
where the result type in <code>reduce</code> differs from the rangeโs
element type) and types that use expression templates. One could imagine
generalizing this to a set of types that have a common type, but this
can be too restrictive; Section 5.1.1 of
<a href="https://wg21.link/P2214R2">P2214R2</a> gives an example
involving two types in a fold that do not have a common type.</p></li>
</ol>
<p>P1673R13 says that algorithms have complete freedom to create
temporary copies or value-initialized temporary objects, rearrange
addends and partial sums arbitrarily, or perform assignments in any
order, as long as this would produce the result specified by the
algorithmโs <em>Effects</em> and <em>Remarks</em> when operating on
elements of a semiring. The <code>linalg::dot</code>
([linalg.algs.blas1.dot]) and <code>linalg::vector_abs_sum</code>
([linalg.algs.blas1.asum]) algorithms specifically define the returned
result(s) in terms of <em>GENERALIZED_SUM</em>. Those algorithms do that
because they need to constrain the precision of intermediate terms in
the sum (so they need to define those terms). In our case, the Standard
already uses <em>GENERALIZED_SUM</em> and
<em>GENERALIZED_NONCOMMUTATIVE_SUM</em> to define iterator-based C++17
algorithms like <code>reduce</code>, <code>inclusive_scan</code>, and
<code>exclusive_scan</code>. We can just adapt this wording to talk
about ranges instead of iterators. This lets us imitate the approach of
<a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a> in
adding ranges overloads.</p>
<p>Our approach combines the syntactic constraints used for the
<code>fold_*</code> family of algorithms, with the semantic approach of
P1673R13 and the C++17 parallel numeric algorithms. For example, we
constrain <code>reduce</code>โs binary operation with both
<em><code>indirectly-binary-left-foldable</code></em> and
<em><code>indirectly-binary-right-foldable</code></em>. (This expresses
that if the binary operation is called with an argument of the initial
valueโs type <code>T</code>, then that argument can be in either the
first or second position.) We express what <code>reduce</code> does
using <em>GENERALIZED_SUM</em>.</p>
<h1 data-number="5" id="implementation"><span class="header-section-number">5</span> Implementation<a href="#implementation" class="self-link"></a></h1>
<p>TODO</p>
<p>The oneDPL library has deployment experience.</p>
<h1 data-number="6" id="wording"><span class="header-section-number">6</span> Wording<a href="#wording" class="self-link"></a></h1>
<blockquote>
<p>Text in blockquotes is not proposed wording, but rather instructions
for generating proposed wording.</p>
<p>Assume that
<a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a> has
been applied to the Working Draft.</p>
</blockquote>
<h2 data-number="6.1" id="update-feature-test-macro"><span class="header-section-number">6.1</span> Update feature test macro<a href="#update-feature-test-macro" class="self-link"></a></h2>
<blockquote>
<p>In [version.syn], increase the value of the
<code>__cpp_lib_parallel_algorithm</code> macro by replacing YYYMML
below with the integer literal encoding the appropriate year (YYYY) and
month (MM).</p>
</blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define __cpp_lib_parallel_algorithm </span>YYYYMML<span class="pp"> </span><span class="co">// also in &lt;algorithm&gt;</span></span></code></pre></div>
<h2 data-number="6.2" id="change-numeric.ops.overview"><span class="header-section-number">6.2</span> Change [numeric.ops.overview]<a href="#change-numeric.ops.overview" class="self-link"></a></h2>
<blockquote>
<p>Change [numeric.ops.overview] (the <code>&lt;numeric&gt;</code>
header synopsis) as follows.</p>
</blockquote>
<h3 data-number="6.2.1" id="add-declaration-of-exposition-only-concepts"><span class="header-section-number">6.2.1</span> Add declaration of
exposition-only concepts<a href="#add-declaration-of-exposition-only-concepts" class="self-link"></a></h3>
<blockquote>
<p>Add declarations of exposition-only concepts
<em><code>indirectly-binary-foldable-impl</code></em> and
<em><code>indirectly-binary-foldable</code></em> to
[numeric.ops.overview] (the <code>&lt;numeric&gt;</code> header
synopsis) as follows.</p>
</blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    template&lt;class F, class T, class I, class U&gt;</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>      concept <em>indirectly-binary-left-foldable-impl</em> =  // <em>exposition only</em></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        movable&lt;T&gt; &amp;&amp; movable&lt;U&gt; &amp;&amp;</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        convertible_to&lt;T, U&gt; &amp;&amp; invocable&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt;&gt;;</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb14"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>template&lt;class F, class T, class I, class U&gt;</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  concept <em>indirectly-binary-foldable-impl</em> =       // <em>exposition only</em></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    movable&lt;T&gt; &amp;&amp; movable&lt;U&gt; &amp;&amp;</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    convertible_to&lt;T, U&gt; &amp;&amp;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    invocable&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    invocable&lt;F&amp;, iter_reference_t&lt;I&gt;, U&gt; &amp;&amp;</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, U&gt;&gt;;</span></code></pre></div>

</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    template&lt;class F, class T, class I&gt;</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>      concept <em>indirectly-binary-left-foldable</em> =      // <em>exposition only</em></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        copy_constructible&lt;F&gt; &amp;&amp; indirectly_readable&lt;I&gt; &amp;&amp;</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        invocable&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        convertible_to&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>               decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <em>indirectly-binary-left-foldable-impl</em>&lt;F, T, I,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>                        decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    template&lt;class F, class T, class I&gt;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      concept <em>indirectly-binary-right-foldable</em> =    // <em>exposition only</em></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        indirectly-binary-left-foldable&lt;<em>flipped</em>&lt;F&gt;, T, I&gt;;</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>template&lt;class F, class T, class I&gt;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  concept <em>indirectly-binary-foldable</em> =           // <em>exposition only</em></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    copy_constructible&lt;F&gt; &amp;&amp; indirectly_readable&lt;I&gt; &amp;&amp;</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    invocable&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    convertible_to&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;,</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>      decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    invocable&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt; &amp;&amp;</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    convertible_to&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;,</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>      decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <em>indirectly-binary-foldable-impl</em>&lt;F, T, I,</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>      decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;;</span></code></pre></div>

</div>
<div class="sourceCode" id="cb17"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>             indirectly-binary-left-foldable&lt;T, I&gt; F&gt;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      constexpr auto fold_left(I first, S last, T init, F f);</span></code></pre></div>
<h3 data-number="6.2.2" id="add-declarations-of-parallel-ranges-reduce-overloads"><span class="header-section-number">6.2.2</span> Add declarations of parallel
ranges <code>reduce</code> overloads<a href="#add-declarations-of-parallel-ranges-reduce-overloads" class="self-link"></a></h3>
<blockquote>
<p>Add declarations of ranges overloads of <code>reduce</code>,
<code>sum</code>, and <code>product</code> algorithms to
[numeric.ops.overview] (the <code>&lt;numeric&gt;</code> header
synopsis) as follows.</p>
</blockquote>
<p>TODO: Check that using <code>projected&lt;I, Proj&gt;</code> instead
of <code>I</code> in <em><code>indirectly-binary-foldable</code></em> is
the right way to handle projections.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  template&lt;class ExecutionPolicy, class ForwardIterator, class T, class BinaryOperation&gt;</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    T reduce(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>             ForwardIterator first, ForwardIterator last, T init, BinaryOperation binary_op);</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  namespace ranges {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of reduce</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  template&lt;random_access_iterator I,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>           class T,</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>           class Proj = identity,</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em>&lt;T, projected&lt;I, Proj&gt;&gt; F&gt;</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>      constexpr auto reduce(I first, S last, T init, F binary_op,</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>                            Proj proj = {}) -&gt; /* <em>see below</em> */;</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  template&lt;random_access_iterator I,</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>           class Proj = identity,</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em>&lt;T, projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; F&gt;</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>      constexpr auto reduce(R&amp;&amp; r, T init, F binary_op,</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>                            Proj proj = {}) -&gt; /* <em>see below</em> */;</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of reduce</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>           class T,</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>           class Proj = identity,</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em>&lt;T, projected&lt;I, Proj&gt;&gt; F&gt;</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>      auto reduce(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>                  I first, S last, T init, F binary_op,</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>                  Proj proj = {}) -&gt; /* <em>see below</em> */;</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>           class T,</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>           class Proj = identity,</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em>&lt;T, projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; F&gt;</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>      auto reduce(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>                  R&amp;&amp; r, T init, F binary_op,</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>                  Proj proj = {}) -&gt; /* <em>see below</em> */;</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of sum</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>  template&lt;random_access_iterator I,</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>      constexpr auto sum(I first, S last, Proj proj = {})</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>sized-random-access-range</em> R&gt;</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>      constexpr auto sum(R&amp;&amp; r, Proj proj = {})</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of sum</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>      auto sum(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>               I first, S last, Proj proj = {})</span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>           class T,</span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a>      auto sum(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>               R&amp;&amp; r, Proj proj = {})</span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of product</span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a>  template&lt;random_access_iterator I,</span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a>      constexpr auto product(I first, S last, Proj proj = {})</span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>sized-random-access-range</em> R&gt;</span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a>      constexpr auto product(R&amp;&amp; r, Proj proj = {})</span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of product</span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a>      auto product(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a>                   I first, S last, Proj proj = {})</span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a>      auto product(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a>                   R&amp;&amp; r, Proj proj = {})</span>
<span id="cb19-100"><a href="#cb19-100" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb19-101"><a href="#cb19-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-102"><a href="#cb19-102" aria-hidden="true" tabindex="-1"></a>  } // namespace ranges</span></code></pre></div>

</div>
<div class="sourceCode" id="cb20"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  // [inner.product], inner product</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  template&lt;class InputIterator1, class InputIterator2, class T&gt;</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>                              InputIterator2 first2, T init);</span></code></pre></div>
<h3 data-number="6.2.3" id="add-declarations-of-parallel-ranges-inclusive_scan"><span class="header-section-number">6.2.3</span> Add declarations of parallel
ranges <code>inclusive_scan</code><a href="#add-declarations-of-parallel-ranges-inclusive_scan" class="self-link"></a></h3>
<p>TODO</p>
<h3 data-number="6.2.4" id="add-declarations-of-parallel-ranges-exclusive_scan"><span class="header-section-number">6.2.4</span> Add declarations of parallel
ranges <code>exclusive_scan</code><a href="#add-declarations-of-parallel-ranges-exclusive_scan" class="self-link"></a></h3>
<p>TODO</p>
<h3 data-number="6.2.5" id="add-wording-for-algorithms"><span class="header-section-number">6.2.5</span> Add wording for algorithms<a href="#add-wording-for-algorithms" class="self-link"></a></h3>
<p>TODO</p>
</div>
</div>
</body>
</html>
