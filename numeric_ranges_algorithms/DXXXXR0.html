<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-05-19" />
  <title>Parallel and non-parallel numeric range algorithms</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
</style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ background-color: #f6f8fa; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { } 
code span.al { color: #ff0000; } 
code span.an { } 
code span.at { } 
code span.bn { color: #9f6807; } 
code span.bu { color: #9f6807; } 
code span.cf { color: #00607c; } 
code span.ch { color: #9f6807; } 
code span.cn { } 
code span.co { color: #008000; font-style: italic; } 
code span.cv { color: #008000; font-style: italic; } 
code span.do { color: #008000; } 
code span.dt { color: #00607c; } 
code span.dv { color: #9f6807; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #9f6807; } 
code span.fu { } 
code span.im { } 
code span.in { color: #008000; } 
code span.kw { color: #00607c; } 
code span.op { color: #af1915; } 
code span.ot { } 
code span.pp { color: #6f4e37; } 
code span.re { } 
code span.sc { color: #9f6807; } 
code span.ss { color: #9f6807; } 
code span.st { color: #9f6807; } 
code span.va { } 
code span.vs { color: #9f6807; } 
code span.wa { color: #008000; font-weight: bold; } 
code.diff {color: #898887}
code.diff span.va {color: #00AA00}
code.diff span.st {color: #bf0303}
</style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Parallel and non-parallel
numeric range algorithms</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>DXXXXR0</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2025-05-19</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      SG1,SG9,LEWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Ruslan Arutyunyan<br>&lt;<a href="mailto:ruslan.arutyunyan@intel.com" class="email">ruslan.arutyunyan@intel.com</a>&gt;<br>
      Mark Hoemmen<br>&lt;<a href="mailto:mhoemmen@nvidia.com" class="email">mhoemmen@nvidia.com</a>&gt;<br>
      Bryce Adelstein Lelbach<br>&lt;<a href="mailto:brycelelbach@gmail.com" class="email">brycelelbach@gmail.com</a>&gt;<br>
      Abhilash Majumder<br>&lt;<a href="mailto:abmajumder@nvidia.com" class="email">abmajumder@nvidia.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#authors" id="toc-authors"><span class="toc-section-number">1</span> Authors</a></li>
<li><a href="#revision-history" id="toc-revision-history"><span class="toc-section-number">2</span> Revision history</a></li>
<li><a href="#abstract" id="toc-abstract"><span class="toc-section-number">3</span> Abstract</a></li>
<li><a href="#design" id="toc-design"><span class="toc-section-number">4</span> Design</a>
<ul>
<li><a href="#constraining-parallel-ranges-numeric-algorithms" id="toc-constraining-parallel-ranges-numeric-algorithms"><span class="toc-section-number">4.1</span> Constraining parallel ranges
numeric algorithms</a></li>
<li><a href="#the-lost-algorithm-noncommutative-parallel-reduction" id="toc-the-lost-algorithm-noncommutative-parallel-reduction"><span class="toc-section-number">4.2</span> “The lost algorithm”:
Noncommutative parallel reduction?</a></li>
<li><a href="#what-algorithms-to-include" id="toc-what-algorithms-to-include"><span class="toc-section-number">4.3</span> What algorithms to include?</a>
<ul>
<li><a href="#current-set-of-numeric-algorithms" id="toc-current-set-of-numeric-algorithms"><span class="toc-section-number">4.3.1</span> Current set of numeric
algorithms</a></li>
<li><a href="#algorithms-that-already-have-ranges-versions" id="toc-algorithms-that-already-have-ranges-versions"><span class="toc-section-number">4.3.2</span> Algorithms that already have
ranges versions</a></li>
<li><a href="#algorithms-with-a-ranges-proposal-in-flight" id="toc-algorithms-with-a-ranges-proposal-in-flight"><span class="toc-section-number">4.3.3</span> Algorithms with a ranges
proposal in flight</a></li>
<li><a href="#algorithms-that-do-not-need-ranges-versions" id="toc-algorithms-that-do-not-need-ranges-versions"><span class="toc-section-number">4.3.4</span> Algorithms that do not need
ranges versions</a></li>
<li><a href="#we-dont-propose-reduce_first" id="toc-we-dont-propose-reduce_first"><span class="toc-section-number">4.3.5</span> We don’t propose
<code>reduce_first</code></a></li>
<li><a href="#we-dont-propose-reduce_with_iter" id="toc-we-dont-propose-reduce_with_iter"><span class="toc-section-number">4.3.6</span> We don’t propose
<code>reduce_with_iter</code></a></li>
<li><a href="#algorithms-that-we-propose-here" id="toc-algorithms-that-we-propose-here"><span class="toc-section-number">4.3.7</span> Algorithms that we propose
here</a></li>
</ul></li>
<li><a href="#range-categories-and-return-types" id="toc-range-categories-and-return-types"><span class="toc-section-number">4.4</span> Range categories and return
types</a></li>
<li><a href="#constexpr-parallel-algorithms" id="toc-constexpr-parallel-algorithms"><span class="toc-section-number">4.5</span> Constexpr parallel
algorithms?</a></li>
<li><a href="#rangesreduce-design" id="toc-rangesreduce-design"><span class="toc-section-number">4.6</span> <code>ranges::reduce</code>
design</a>
<ul>
<li><a href="#no-default-parameters" id="toc-no-default-parameters"><span class="toc-section-number">4.6.1</span> No default parameters</a></li>
<li><a href="#return-type" id="toc-return-type"><span class="toc-section-number">4.6.2</span> Return type?</a></li>
<li><a href="#support-projections" id="toc-support-projections"><span class="toc-section-number">4.6.3</span> Support projections</a></li>
</ul></li>
</ul></li>
<li><a href="#implementation" id="toc-implementation"><span class="toc-section-number">5</span> Implementation</a></li>
<li><a href="#wording" id="toc-wording"><span class="toc-section-number">6</span> Wording</a>
<ul>
<li><a href="#update-feature-test-macro" id="toc-update-feature-test-macro"><span class="toc-section-number">6.1</span> Update feature test macro</a></li>
<li><a href="#change-numeric.ops.overview" id="toc-change-numeric.ops.overview"><span class="toc-section-number">6.2</span> Change [numeric.ops.overview]</a>
<ul>
<li><a href="#add-declaration-of-exposition-only-concepts" id="toc-add-declaration-of-exposition-only-concepts"><span class="toc-section-number">6.2.1</span> Add declaration of
exposition-only concepts</a></li>
<li><a href="#add-declarations-of-parallel-ranges-reduce-overloads" id="toc-add-declarations-of-parallel-ranges-reduce-overloads"><span class="toc-section-number">6.2.2</span> Add declarations of parallel
ranges <code>reduce</code> overloads</a></li>
<li><a href="#add-declarations-of-parallel-ranges-inclusive_scan" id="toc-add-declarations-of-parallel-ranges-inclusive_scan"><span class="toc-section-number">6.2.3</span> Add declarations of parallel
ranges <code>inclusive_scan</code></a></li>
<li><a href="#add-declarations-of-parallel-ranges-exclusive_scan" id="toc-add-declarations-of-parallel-ranges-exclusive_scan"><span class="toc-section-number">6.2.4</span> Add declarations of parallel
ranges <code>exclusive_scan</code></a></li>
<li><a href="#add-wording-for-algorithms" id="toc-add-wording-for-algorithms"><span class="toc-section-number">6.2.5</span> Add wording for
algorithms</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 data-number="1" id="authors"><span class="header-section-number">1</span> Authors<a href="#authors" class="self-link"></a></h1>
<ul>
<li><p>Ruslan Arutyunyan (Intel)</p></li>
<li><p>Mark Hoemmen (NVIDIA)</p></li>
<li><p>Bryce Adelstein Lelbach (NVIDIA)</p></li>
<li><p>Abhilash Majumder (NVIDIA)</p></li>
</ul>
<h1 data-number="2" id="revision-history"><span class="header-section-number">2</span> Revision history<a href="#revision-history" class="self-link"></a></h1>
<ul>
<li>Revision 0 to be submitted 2025-??-??</li>
</ul>
<h1 data-number="3" id="abstract"><span class="header-section-number">3</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>We propose adding both parallel and non-parallel ranges overloads of
the following numeric algorithms: <code>reduce</code>,
<code>inclusive_scan</code>, and <code>exclusive_scan</code>. We also
propose adding convenience wrappers <code>ranges::sum</code> and
<code>ranges::product</code> for special cases of <code>reduce</code>
with addition and multiplication, respectively.</p>
<h1 data-number="4" id="design"><span class="header-section-number">4</span> Design<a href="#design" class="self-link"></a></h1>
<h2 data-number="4.1" id="constraining-parallel-ranges-numeric-algorithms"><span class="header-section-number">4.1</span> Constraining parallel ranges
numeric algorithms<a href="#constraining-parallel-ranges-numeric-algorithms" class="self-link"></a></h2>
<ol type="1">
<li><p>We use the same constraints as <code>fold_left</code> and
<code>fold_right</code> to constrain the binary operator of
<code>reduce</code> and <code>*_scan</code>.</p></li>
<li><p>We imitate C++17 parallel algorithms and [linalg]
(<a href="https://wg21.link/P1673R13">P1673R13</a>) by using
<em>GENERALIZED_NONCOMMUTATIVE_SUM</em> and <em>GENERALIZED_SUM</em> to
describe the behavior of <code>reduce</code> and
<code>*_scan</code>.</p></li>
<li><p>Otherwise, we follow the approach of
<a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a> (“C++
Parallel Range Algorithms”).</p></li>
</ol>
<p><a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a>,
which is in the last stages of wording review, defines parallel versions
of many ranges algorithms in the C++ Standard Library. (The “parallel
version of an algorithm” is an overload of an algorithm whose first
parameter is an execution policy.) That proposal restricts itself to
adding parallel versions of existing ranges algorithms. P3179R8
explicitly defers adding overloads to the numeric algorithms in
<a href="https://eel.is/c++draft/numeric.ops">[numeric.ops]</a>, because
these do not yet have ranges versions. Our proposal fills that gap.</p>
<p>WG21 did not have time to propose ranges-based numeric algorithms
with the initial set of ranges algorithms in C++20.
<a href="https://wg21.link/P1813R0">P1813R0</a>, “A Concept Design for
the Numeric Algorithms,” points out the challenge of defining ranges
versions of the existing parallel numeric algorithms. What makes this
task less straightforward is that the specification of the parallel
numeric algorithms permits them to reorder binary operations like
addition. This matters because many useful number types do not have
associative addition. Lack of associativity is not just a floating-point
rounding error issue; one example is saturating integer arithmetic.
Ranges algorithms are constrained by concepts, but it’s not clear even
if it’s a good idea to define concepts that can express permission to
reorder terms in a sum.</p>
<p>C++17 takes the approach of saying that parallel numeric algorithms
can reorder the binary operations however they like, but does not say
whether any reordering would give the same results as any other
reordering. The Standard expresses this through the wording “macros”
<em>GENERALIZED_NONCOMMUTATIVE_SUM</em> and <em>GENERALIZED_SUM</em>. (A
wording macro is a parameterized abbreviation for a longer sequence of
wording in the Standard. We put “macros” in double quotes because they
are not necessarily preprocessor macros. They might not even be
implementable as such.) Algorithms become ill-formed, no diagnostic
required (IFNDR) if the element types do not define the required
operations. P1813R0 instead defines C++ concepts that represent
algebraic structures, all of which involve a set with a closed binary
operation. Some of the structures require that the operation be
associative and/or commutative. P1813R0 uses those concepts to constrain
the algorithms. This means that the algorithms will not be selected for
overload resolution if the element types do not define the required
operations. It further means that algorithms could (at least in theory)
dispatch based on properties like whether the element type’s binary
operation is commutative. The concepts include both syntactic and
semantic constraints.</p>
<p>WG21 has not expressed a consensus on P1813R0’s approach. LEWGI
reviewed P1813R0 at the Belfast meeting in November 2019, but did not
forward the proposal and wanted to see it again. Two other proposals
express something more like WG21’s consensus on constraining the numeric
algorithms: <a href="https://wg21.link/P2214R2">P2214R2</a>, “A Plan for
C++23 Ranges,” and <a href="https://wg21.link/P1673R13">P1673R13</a>, “A
free function linear algebra interface based on the BLAS,” which defines
mdspan-based analogs of the numeric algorithms. Section 5.1.1 of P2214R2
points out that P1813R0’s approach would overconstrain
<code>fold</code>; P2214R2 instead suggests just constraining the
operation to be binary invocable. This was ultimately the approach taken
by the Standard through the exposition-only concepts
<em><code>indirectly-binary-left-foldable</code></em> and
<em><code>indirectly-binary-right-foldable</code></em>. Section 5.1.2 of
P2214R2 says that <code>reduce</code> “calls for the kinds of
constraints that P1813R0 is proposing.”</p>
<p><a href="https://wg21.link/P1673R13">P1673R13</a>, which was adopted
into the Working Draft for C++26 as [linalg], took an entirely different
approach for its set of <code>mdspan</code>-based numeric algorithms.
Section 10.8, “Constraining matrix and vector element types and
scalars,” explains the argument. Here is a summary.</p>
<ol type="1">
<li><p>Requirements like associativity are too strict to be useful for
practical types. The only number types in the Standard with associative
addition are unsigned integers. It’s not just a rounding error “epsilon”
issue; sums of saturating integers can have infinite error if one
assumes associativity.</p></li>
<li><p>“The algorithm may reorder sums” (which is what we want to say)
means something different than “addition on the terms in the sum is
associative” (which is not true for many number types of interest). That
is, permission for an algorithm to reparenthesize sums is not the same
as a concept constraining the terms in the sum.</p></li>
<li><p>P1813R0 defines concepts that generalize a mathematical group.
These are only useful for describing a single set of numbers, that is,
one type. This excludes useful features like mixed precision (e.g.,
where the result type in <code>reduce</code> differs from the range’s
element type) and types that use expression templates. One could imagine
generalizing this to a set of types that have a common type, but this
can be too restrictive; Section 5.1.1 of
<a href="https://wg21.link/P2214R2">P2214R2</a> gives an example
involving two types in a fold that do not have a common type.</p></li>
</ol>
<p>P1673R13 says that algorithms have complete freedom to create
temporary copies or value-initialized temporary objects, rearrange
addends and partial sums arbitrarily, or perform assignments in any
order, as long as this would produce the result specified by the
algorithm’s <em>Effects</em> and <em>Remarks</em> when operating on
elements of a semiring. The <code>linalg::dot</code>
([linalg.algs.blas1.dot]) and <code>linalg::vector_abs_sum</code>
([linalg.algs.blas1.asum]) algorithms specifically define the returned
result(s) in terms of <em>GENERALIZED_SUM</em>. Those algorithms do that
because they need to constrain the precision of intermediate terms in
the sum (so they need to define those terms). In our case, the Standard
already uses <em>GENERALIZED_SUM</em> and
<em>GENERALIZED_NONCOMMUTATIVE_SUM</em> to define ranges algorithms like
<code>reduce</code>, <code>inclusive_scan</code>, and
<code>exclusive_scan</code>. We can just adapt this wording to talk
about ranges instead of iterators. This lets us imitate the approach of
<a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a> in
adding ranges overloads.</p>
<p>Our approach combines the syntactic constraints used for the
<code>fold_*</code> family of algorithms, with the semantic approach of
P1673R13 and the C++17 parallel numeric algorithms. For example, we
constrain <code>reduce</code>’s binary operation with both
<em><code>indirectly-binary-left-foldable</code></em> and
<em><code>indirectly-binary-right-foldable</code></em>. (This expresses
that if the binary operation is called with an argument of the initial
value’s type <code>T</code>, then that argument can be in either the
first or second position.) We express what <code>reduce</code> does
using <em>GENERALIZED_SUM</em>.</p>
<h2 data-number="4.2" id="the-lost-algorithm-noncommutative-parallel-reduction"><span class="header-section-number">4.2</span> “The lost algorithm”:
Noncommutative parallel reduction?<a href="#the-lost-algorithm-noncommutative-parallel-reduction" class="self-link"></a></h2>
<p>The Standard lacks an analog of <code>reduce</code> that can assume
associativity but not commutativity of binary operations. One author of
this proposal refers to this as the “the lost algorithm” (in e.g.,
<a href="https://adspthepodcast.com/2021/05/14/Episode-25.html">Episode
25 of “ASDP: The Podcast”</a>). To elaborate: The current numeric
algorithms express a variety of permissions to reorder binary
operations.</p>
<ol type="1">
<li><p><code>accumulate</code> and <code>partial_sum</code> both
precisely specify the order of binary operations as sequential, from
left to right. This works even if the binary operation is neither
associative nor commutative.</p></li>
<li><p>The various <code>*_scan</code> algorithms can reorder binary
operations as if they are associative (they may replace
<code>a + (b + c)</code> with <code>(a + b) + c</code>), but not as if
they are commutative (they may replace <code>a + b</code> with
<code>b + a</code>).</p></li>
<li><p><code>reduce</code> can reorder binary operations as if they are
both associative and commutative.</p></li>
</ol>
<p>What’s missing here is a parallel analog of <code>reduce</code> with
the assumptions of <code>*_scan</code>, that is, a reduction that can
assume associativity but not commutativity of binary operations.
Parallel reduction operations with these assumptions exist in other
programming models. For example, MPI (the Message Passing Interface for
distributed-memory parallel communication) has a function
<code>MPI_Create_op</code> for defining custom reduction operators from
a user’s function. <code>MPI_Create_op</code> has a parameter that
specifies whether MPI may assume that the user’s function is
commutative.</p>
<p>Users could get a parallel algorithm by calling <code>*_scan</code>
with an extra output sequence, and using only the last element. However,
this requires extra storage.</p>
<p>A concepts-based approach like P1813R0’s could permit specializing
<code>reduce</code> on whether the user asserts that the binary
operation is commutative. P1813R0 does not attempt to do this; it merely
specializes <code>reduce</code> on whether the associative and
commutative operation has a two-sided identity element. Furthermore,
P1813R0 does not offer a way for users to assert that an operation is
associative or commutative, because the <code>magma</code>
(nonassociative) and <code>semigroup</code> (associative) concepts do
not differ syntactically. One could imagine a refinement of this design
that includes a trait for users to specialize on the type of their
binary operation, say <code>is_commutative&lt;BinaryOp&gt;</code>. This
would be analogous to the <code>two_sided_identity</code> trait in
P1813R0 that lets users declare that their set forms a monoid, a
refinement of <code>semigroup</code> with a two-sided identity
element.</p>
<p>This proposal does not attempt to fill this gap in the Standard
parallel algorithms, but would welcome a separate proposal to do so. We
think the right way would be to propose a new algorithm with a distinct
name. A reasonable choice of name would be <code>fold</code> (just
<code>fold</code> by itself, not <code>fold_left</code> or
<code>fold_right</code>).</p>
<h2 data-number="4.3" id="what-algorithms-to-include"><span class="header-section-number">4.3</span> What algorithms to include?<a href="#what-algorithms-to-include" class="self-link"></a></h2>
<p>We propose ranges overloads (both parallel and nonparallel) of only
three algorithms: <code>reduce</code>, <code>inclusive_scan</code>, and
<code>exclusive_scan</code>. We also propose parallel and non-parallel
convenience wrappers <code>ranges::sum(r)</code> as
<code>ranges::reduce(r, plus{}, range_value_t&lt;R&gt;())</code> and
<code>ranges::product(r)</code> as
<code>ranges::reduce(r, multiplies{}, range_value_t&lt;R&gt;(1))</code>.</p>
<h3 data-number="4.3.1" id="current-set-of-numeric-algorithms"><span class="header-section-number">4.3.1</span> Current set of numeric
algorithms<a href="#current-set-of-numeric-algorithms" class="self-link"></a></h3>
<p><a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a>,
“C++ Parallel Range Algorithms,” is in the last stages of wording review
as of the publication date. P3179R8 explicitly defers adding ranges
versions of the numeric algorithms. This proposal does that. As such, we
focus on the numeric algorithms, that is, the 11 algorithms in
<a href="https://eel.is/c++draft/numeric.ops">[numeric.ops]</a>.</p>
<ul>
<li><p><code>iota</code></p></li>
<li><p><code>accumulate</code></p></li>
<li><p><code>inner_product</code></p></li>
<li><p><code>partial_sum</code></p></li>
<li><p><code>adjacent_difference</code></p></li>
<li><p><code>reduce</code></p></li>
<li><p><code>inclusive_scan</code></p></li>
<li><p><code>exclusive_scan</code></p></li>
<li><p><code>transform_reduce</code></p></li>
<li><p><code>transform_inclusive_scan</code></p></li>
<li><p><code>transform_exclusive_scan</code></p></li>
</ul>
<p>We don’t have to add ranges versions of all these algorithms. Several
already have a ranges version in C++23, possibly with a different name.
Some others could be omitted because they have straightforward
replacements using existing views and other ranges algorithms. We base
our algorithm selection decisions on
<a href="https://wg21.link/P2214R2">P2214R2</a>, “A Plan for C++23
Ranges,” and <a href="https://wg21.link/P2760R1">P2760R1</a>, “A Plan
for C++26 Ranges.” As P2214R2 explains, “one of the big motivations for
Ranges was the ability to actually compose algorithms.” It’s idiomatic
for ranges to use views and projections where possible, instead of
creating new algorithms. For P2214, see in particular Section 5. (Note
that the table at the start of the section lists <code>shift_left</code>
and <code>shift_right</code>. These are not numeric algorithms, and
<a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a> adds
parallel ranges versions of them.)</p>
<h3 data-number="4.3.2" id="algorithms-that-already-have-ranges-versions"><span class="header-section-number">4.3.2</span> Algorithms that already have
ranges versions<a href="#algorithms-that-already-have-ranges-versions" class="self-link"></a></h3>
<p>The following numeric algorithms already have ranges versions in
C++23.</p>
<ul>
<li><p><code>iota</code> already has a ranges version in C++23. P3179R8
adds a parallel version.</p></li>
<li><p><code>accumulate</code> performs operations sequentially. Its
parallel version is <code>reduce</code>, which we propose here. The
non-parallel version has been translated in C++23 into
<code>fold_left</code>.</p></li>
</ul>
<h3 data-number="4.3.3" id="algorithms-with-a-ranges-proposal-in-flight"><span class="header-section-number">4.3.3</span> Algorithms with a ranges
proposal in flight<a href="#algorithms-with-a-ranges-proposal-in-flight" class="self-link"></a></h3>
<p>The following algorithm has a proposal in flight to add a ranges
analog.</p>
<ul>
<li><code>partial_sum</code> performs operations sequentially. Its
parallel analogs are <code>inclusive_scan</code> and
<code>exclusive_scan</code>, which we propose here. For the non-parallel
ranges version that returns a stateful binary operator,
<a href="https://wg21.link/P2760R1">P2760R1</a> suggests a view instead
of an algorithm. <a href="https://wg21.link/P3351R2">P3351R2</a>,
“<code>views::scan</code>,” proposes this view. P3351R2 is currently in
SG9 (Ranges Study Group) review.</li>
</ul>
<h3 data-number="4.3.4" id="algorithms-that-do-not-need-ranges-versions"><span class="header-section-number">4.3.4</span> Algorithms that do not need
ranges versions<a href="#algorithms-that-do-not-need-ranges-versions" class="self-link"></a></h3>
<p>The following algorithms do not need ranges versions, since they can
be replaced with existing views and ranges algorithms.</p>
<h4 data-number="4.3.4.1" id="inner_product"><span class="header-section-number">4.3.4.1</span>
<code>inner_product</code><a href="#inner_product" class="self-link"></a></h4>
<p><code>inner_product</code> performs operations sequentially. It can
be replaced with existing views and ranges algorithms, e.g.,
<code>ranges::fold_left(views::zip_transform(std::multiplies(), x, y), 0.0, std::plus())</code>.
P2214R2 argues against adding a ranges analog of
<code>inner_product</code>, because it is less fundamental than other
algorithms, and because it’s not clear how to incorporate
projections.</p>
<h4 data-number="4.3.4.2" id="adjacent_difference"><span class="header-section-number">4.3.4.2</span>
<code>adjacent_difference</code><a href="#adjacent_difference" class="self-link"></a></h4>
<p><code>adjacent_difference</code> can be replaced with a combination
of <code>adjacent_transform_view</code> (which was adopted in C++23) and
<code>ranges::copy</code>. In our experience, adjacent differences or
their generalization are often used in combination with other ranges.
For example, finite-difference methods for solving time-dependent
differential equations may need to add together multiple ranges, each of
which is an adjacent difference possibly composed with other functions.
One could represent the spatial finite difference scheme for a partial
differential equation as a weighted sum of adjacent differences in each
spatial degree of freedom. Thus, for us a view would make more sense
than a “terminal” algorithm. The actual algorithm is a transform or copy
from a complicated view into an output range.</p>
<h4 data-number="4.3.4.3" id="transform_"><span class="header-section-number">4.3.4.3</span> <code>transform_*</code><a href="#transform_" class="self-link"></a></h4>
<p><code>transform_reduce</code>, <code>transform_inclusive_scan</code>,
and <code>transform_exclusive_scan</code> can be replaced in two
different ways: either</p>
<ol type="1">
<li>by a combination of <code>transform_view</code> and the
non-<code>transform</code> algorithm; or</li>
<li>by having the algorithm take an optional projection, as ranges
algorithms typically do.</li>
</ol>
<p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html#algorithms-should-take-invokable-projections">Section
13.2 of N4128</a> explains why ranges algorithms take optional
projections “everywhere it makes sense.”</p>
<blockquote>
<p>Wherever appropriate, algorithms should optionally take INVOKE-able
<em>projections</em> that are applied to each element in the input
sequence(s). This, in effect, allows users to trivially transform each
input sequence for the sake of that single algorithm invocation.</p>
</blockquote>
<p>P2214R2 points out that
<code>ranges::transform_inclusive_scan(r, o, f, g)</code> can be
rewritten as
<code>ranges::inclusive_scan(r | views::transform(g), o, f)</code>, and
that the latter saves users from needing to remember which of
<code>f</code> and <code>g</code> is the transform (unary) operation,
and which is the binary operation. Making the ranges version of the
algorithm take an optional projection would be exactly equivalent to
adding a <code>transform_*</code> version that does not take a
projection: e.g., <code>ranges::inclusive_scan(r, o, f, g)</code> with
<code>g</code> as the projection would do exactly the same thing as
<code>ranges::transform_inclusive_scan(r, o, f, g)</code> with
<code>g</code> as the transform operation.</p>
<h3 data-number="4.3.5" id="we-dont-propose-reduce_first"><span class="header-section-number">4.3.5</span> We don’t propose
<code>reduce_first</code><a href="#we-dont-propose-reduce_first" class="self-link"></a></h3>
<p>Section 5.1 of <a href="https://wg21.link/P2760R1">P2760R1</a> asks
whether there should be a <code>reduce_first</code> algorithm, analogous
to <code>fold_left_first</code>, for binary operations that lack a
natural identity element to serve as the initial value. An example would
be <code>min</code> on a range of <code>int</code> values, where callers
would have no way to tell if <code>INT_MAX</code> represents a value in
the range, or an arbitrary stand-in for the (nonexistent) identity
element. We do not propose <code>reduce_first</code> for the following
reasons.</p>
<ol type="1">
<li><p>P3179R8 already proposes parallel ranges overloads of
<code>min_element</code>, <code>max_element</code>, and
<code>minmax_element</code>.</p></li>
<li><p><code>fold_left_first</code> and <code>fold_right_last</code>
makes more sense, because these algorithms are ordered. It matters which
element of the sequence the user extracts. <code>reduce</code> is
unordered, so there’s no reason to privilege one element over another.
Why should it be the first one?</p></li>
<li><p>Users can always extract the first element from the sequence and
use it as the initial value in <code>reduce</code>.</p></li>
</ol>
<p>We have to decide in this proposal whether to add
<code>reduce_first</code>, because of projections. As we explain below,
it makes sense for <code>reduce</code> to take an optional projection.
However, <code>reduce_first</code> could not straightforwardly support
projections. If <code>reduce</code> takes an optional projection, then
it would be inconsistent with <code>reduce_first</code>. The only reason
<code>fold_left</code> and <code>fold_right</code> do not take
projections is for consistency with <code>fold_left_first</code> and
<code>fold_right_last</code>, which cannot take projections. The only
way for us to leave <code>reduce_first</code> for a later proposal is if
<code>reduce</code> does not take a projection.</p>
<h3 data-number="4.3.6" id="we-dont-propose-reduce_with_iter"><span class="header-section-number">4.3.6</span> We don’t propose
<code>reduce_with_iter</code><a href="#we-dont-propose-reduce_with_iter" class="self-link"></a></h3>
<p>A <code>reduce_with_iter</code> algorithm would look like
<code>fold_left_with_iter</code>, but would permit reordering of binary
operations. It would return both an iterator to one past the last
element, and the computed value. A hypothetical
<code>reduce_with_iter</code> algorithm would also return an iterator to
one past the last element, and the computed value, but would share
<code>reduce</code>’s permission to reorder binary operations.</p>
<p>We do not propose the analogous <code>reduce_with_iter</code> here,
though we would not oppose someone else proposing it. That algorithm
would serve users who are writing code generic enough to work with
single-pass input iterators, <em>and</em> who want to expose potential
binary operation reordering opportunities.</p>
<p>Just like <code>fold_left</code>, the <code>reduce</code> algorithm
should return just the computed value. Section 4.4 of
<a href="https://wg21.link/P2322R6">P2322R6</a> argues that this makes
it easier to use, and improves consistency with other ranges algorithms
like <code>ranges::count</code> and <code>ranges::any_of</code>. It is
also consistent with P3179R8. The algorithms
<code>fold_left_with_iter</code> and
<code>fold_left_first_with_iter</code> exist for users who want both the
iterator and the value. Section 4.4 of P2322R6 further elaborates that
<code>fold_left</code> should not be specified in terms of
<code>fold_left_with_iter</code>, for performance reasons: it would
“incur an extra move of the accumulated result, due to lack of copy
elision (we have different return types).” The <code>*_with_iter</code>
algorithms are separate algorithms that need separate
specifications.</p>
<h3 data-number="4.3.7" id="algorithms-that-we-propose-here"><span class="header-section-number">4.3.7</span> Algorithms that we propose
here<a href="#algorithms-that-we-propose-here" class="self-link"></a></h3>
<p>This leaves three algorithms, which we propose here:
<code>reduce</code>, <code>inclusive_scan</code>, and
<code>exclusive_scan</code>.
<a href="https://wg21.link/P2760R1">P2760R1</a> proposes convenience
wrappers <code>ranges::sum(r)</code> as
<code>ranges::reduce(r, plus{}, range_value_t&lt;R&gt;())</code> and
<code>ranges::product(r)</code> as
<code>ranges::reduce(r, multiplies{}, range_value_t&lt;R&gt;(1))</code>;
we propose parallel and non-parallel overloads of these here as
well.</p>
<h2 data-number="4.4" id="range-categories-and-return-types"><span class="header-section-number">4.4</span> Range categories and return
types<a href="#range-categories-and-return-types" class="self-link"></a></h2>
<p>We make the parallel algorithms proposed here take sized random
access ranges. As a result, any parallel algorithms with an output range
need to return an iterator to one past the last element of the input, in
case there wasn’t enough room in the output. We make the non-parallel
algorithms take (single-pass) sized <code>input_range</code> and
<code>output_range</code>, for consistency with the C++17 parallel
algorithms that only require <em>LegacyInputIterator</em> and
<em>LegacyOutputIterator</em>. This suggests making the algorithms with
output ranges – <code>inclusive_scan</code> and
<code>exclusive_scan</code> – return both input and output iterators.
This is consistent both with the existing non-parallel ranges algorithms
and with P3179R8 (e.g., <code>ranges::transform</code>).</p>
<p>The <code>reduce</code> algorithm only takes an input range. For the
non-parallel overloads, this suggests that it should return both the
computed value and the iterator to one past the last element of the
input. As we explain above, though, it would be more consistent with
both the existing ranges algorithms and P3179R8 for <code>reduce</code>
to return a single value. We don’t propose a separate algorithm
<code>reduce_with_iter</code> here, though we would not oppose someone
else doing so.</p>
<p>P3179R8 does not aim for perfect consistency with the range
categories accepted by existing ranges algorithms. The algorithms
proposed by P3179R8 differ in the following ways.</p>
<ol type="1">
<li><p>P3179R8 uses a range, not an iterator, as the output parameter
(see Section 2.7).</p></li>
<li><p>P3179R8 requires that the ranges be sized (see Section
2.8).</p></li>
<li><p>P3179R8 requires random access ranges (see Section 2.6).</p></li>
</ol>
<p>Of these differences, (1) and (2) could apply generally to all ranges
algorithms, so we adopt them for this proposal. This would make our
proposal the first to add non-parallel range-as-output ranges algorithms
to the Standard. For arguments in favor of non-parallel algorithms
taking a range as output, please refer to
<a href="https://wg21.link/P3490R0">P3490R0</a>, “Justification for
ranges as the output of parallel range algorithms.” (Despite the title,
it has things to say about non-parallel algorithms too.) Taking a range
as output would prevent use of existing output-only iterators that do
not have a separate sized sentinel type, like
<code>std::back_insert_iterator</code>. Such iterators would only work
with the non-parallel algorithms. P3490R0 shows that it is possible for
both iterator-as-output and range-as-output overloads to coexist, so we
follow P3179R8 by not proposing iterator-as-output algorithms here.</p>
<p>Difference (1) relates to P3179R8 only proposing parallel algorithms.
It would make sense for us to relax this requirement for the
non-parallel algorithms we propose. This leaves us with two
possibilities:</p>
<ul>
<li><p>(single-pass) input and output ranges, the most general;
or</p></li>
<li><p>(multipass) forward ranges.</p></li>
</ul>
<p>C++17’s non-parallel <code>reduce</code> and <code>*_scan</code> only
require (single-pass) input ranges. One could argue that this is overly
general. Since <code>reduce</code> and <code>*_scan</code> permit
reordering of binary operations, why should they permit iterators with a
required or preferred ordering? On the other hand, the point of using
<code>reduce</code> is for the user to grant permission to reorder
binary operations. It’s still <em>correct</em> to call non-parallel
<code>reduce</code> and <code>*_scan</code> with single-pass input
ranges. Users might write a generic function that could work with any
input ranges, but they want to expose potential optimizations if they
call it with random access ranges.</p>
<p>The argument for non-parallel <code>reduce</code> and
<code>*_scan</code> taking maximally generic range categories seems to
contradict P3179R8’s argument for making the parallel algorithms require
random access ranges. It’s <em>correct</em> to call C++17 parallel
algorithms with forward iterators. However, calling a parallel algorithm
expresses a different set of expectations. The kinds of users who
explicitly opt into parallelism care more about performance, so they are
more likely to be unhappy if opting in has a high risk of making their
code slower. Forward ranges require higher-overhead and therefore
riskier parallelization strategies, like copying the range or
per-element task parallelism.</p>
<h2 data-number="4.5" id="constexpr-parallel-algorithms"><span class="header-section-number">4.5</span> Constexpr parallel
algorithms?<a href="#constexpr-parallel-algorithms" class="self-link"></a></h2>
<p><a href="https://wg21.link/p2902r1">P2902R1</a> proposes to add
<code>constexpr</code> to the parallel algorithms. P3179R8 does not
object to this; see Section 2.10. We continue the approach of P3179R8 in
not opposing P2902R1’s approach, but also not depending on it.</p>
<h2 data-number="4.6" id="rangesreduce-design"><span class="header-section-number">4.6</span> <code>ranges::reduce</code>
design<a href="#rangesreduce-design" class="self-link"></a></h2>
<h3 data-number="4.6.1" id="no-default-parameters"><span class="header-section-number">4.6.1</span> No default parameters<a href="#no-default-parameters" class="self-link"></a></h3>
<p>“One thing is clear: <code>ranges::reduce</code> should <em>not</em>
take a default binary operation <em>nor</em> a default initial
parameter. The user needs to supply both” – Section 5.1 of P2760R1. This
motivates the convenience wrappers</p>
<ul>
<li><p><code>ranges::sum(r)</code> for
<code>ranges::reduce(r, plus{}, range_value_t&lt;R&gt;())</code>,
and</p></li>
<li><p><code>ranges::product(r)</code> for
<code>ranges::reduce(r, multiplies{}, range_value_t&lt;R&gt;(1))</code>.</p></li>
</ul>
<p>One argument <em>for</em> a default initial value in
<code>std::reduce</code> is that <code>int</code> literals like
<code>0</code> or <code>1</code> do not behave in the expected way with
a sequence of <code>float</code> or <code>double</code>. Changing the
return value type behavior of <code>ranges::reduce</code> to imitate
<code>ranges::fold_left</code> instead of <code>std::reduce</code> fixes
that.</p>
<h3 data-number="4.6.2" id="return-type"><span class="header-section-number">4.6.2</span> Return type?<a href="#return-type" class="self-link"></a></h3>
<h4 data-number="4.6.2.1" id="imitate-rangesfold_left-not-stdreduce"><span class="header-section-number">4.6.2.1</span> Imitate
<code>ranges::fold_left</code>, not <code>std::reduce</code><a href="#imitate-rangesfold_left-not-stdreduce" class="self-link"></a></h4>
<p>For <code>ranges::reduce</code>, we deduce the return type (of the
reduction result, a single value) in the same way that
<code>std::ranges::fold_left</code>, instead of always returning the
initial value type <code>T</code> like <code>std::reduce</code>.</p>
<p><a href="https://wg21.link/P2322R6">P2322R6</a>,
“<code>ranges::fold</code>,” added the various <code>fold_*</code>
ranges algorithms to C++23. This proposal explains why
<code>std::ranges::fold_left</code> may return a different reduction
type than <code>std::reduce</code> for the same input range, initial
value, and binary operation. Consider the following example, adapted
from Section 3 of P2322R6
(<a href="https://godbolt.org/z/3q71EMTPa">Compiler Explorer
link</a>).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="fl">0.25</span>, <span class="fl">0.75</span><span class="op">}</span>;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>reduce<span class="op">(</span>v<span class="op">.</span>begin<span class="op">()</span>, v<span class="op">.</span>end<span class="op">()</span>, <span class="dv">1</span>, std<span class="op">::</span>plus<span class="op">())</span>;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)</span>, <span class="dt">int</span><span class="op">&gt;)</span>;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>r <span class="op">==</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>fold_left<span class="op">(</span>v, <span class="dv">1</span>, std<span class="op">::</span>plus<span class="op">())</span>;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)</span>, <span class="dt">double</span><span class="op">&gt;)</span>;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>r <span class="op">==</span> <span class="fl">2.0</span><span class="op">)</span>;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span>;  </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>std::reduce</code> part of the example expresses a common
user error. <code>ranges::fold_*</code> instead returns “the decayed
result of invoking the binary operation with <code>T</code> (the initial
value) and the reference type of the range.” For the above example, this
likely expresses what the user meant. It also works for other common
cases, like proxy reference types with an unambiguous conversion to a
common type with the initial value.</p>
<h4 data-number="4.6.2.2" id="return-just-the-value-not-in_value_result-like-fold_"><span class="header-section-number">4.6.2.2</span> Return just the value, not
<code>in_value_result</code> like <code>fold_*</code><a href="#return-just-the-value-not-in_value_result-like-fold_" class="self-link"></a></h4>
<p>The reason for an algorithm to return the input iterator is because
it’s an <code>input_iterator</code> – that is, it doesn’t offer the
multipass guarantee, so the state of the iterator may matter to the
caller. The parallel algorithms take forward iterators at least, so this
question only applies to non-parallel algorithms. Our view is that
<code>reduce</code> can combine the elements of the range in any order,
so if users have iterators that aren’t random access iterators, they
probably should just call <code>fold_left</code>. As a result, we
specify <code>ranges::reduce</code> just to return the value, not to
return <code>in_value_result</code> like <code>fold_left</code>.</p>
<h3 data-number="4.6.3" id="support-projections"><span class="header-section-number">4.6.3</span> Support projections<a href="#support-projections" class="self-link"></a></h3>
<p>We propose that <code>ranges::reduce</code> take a projection
parameter, unlike <code>ranges::fold_left</code>.</p>
<p>As we explain above, the optional projection makes
<code>transform_*</code> versions of the algorithms superfluous. The
projection <em>is</em> the transform function.</p>
<p><code>ranges::fold_left</code> does not take a projection. Section
4.6 of <a href="https://wg21.link/P2322R6">P2322R6</a> explains that the
only reason for this is consistency with
<code>ranges::fold_left_first</code>. The latter does not take a
projection in order to avoid an extra copy of the leftmost value, that
would be required in order to support projections with a range whose
iterators yield proxy reference types like
<code>tuple&lt;T&amp;&gt;</code> (as <code>views::zip</code> does).
P2322R6 clarifies that <code>ranges::fold_left</code> does not have this
problem, because it never needs to materialize an input value; it can
just project each element at iterator <code>iter</code> via
<code>invoke(proj, *iter)</code>, and feed that directly into the binary
operation. If we never want a <code>ranges::reduce_first</code>, then
<code>ranges::reduce</code> does not have <code>fold_left_first</code>’s
design issue and can thus take a projection.</p>
<h1 data-number="5" id="implementation"><span class="header-section-number">5</span> Implementation<a href="#implementation" class="self-link"></a></h1>
<p>TODO</p>
<p>The oneDPL library has deployment experience.</p>
<h1 data-number="6" id="wording"><span class="header-section-number">6</span> Wording<a href="#wording" class="self-link"></a></h1>
<blockquote>
<p>Text in blockquotes is not proposed wording, but rather instructions
for generating proposed wording.</p>
<p>Assume that
<a href="https://isocpp.org/files/papers/P3179R8.html">P3179R8</a> has
been applied to the Working Draft.</p>
</blockquote>
<h2 data-number="6.1" id="update-feature-test-macro"><span class="header-section-number">6.1</span> Update feature test macro<a href="#update-feature-test-macro" class="self-link"></a></h2>
<blockquote>
<p>In [version.syn], increase the value of the
<code>__cpp_lib_parallel_algorithm</code> macro by replacing YYYMML
below with the integer literal encoding the appropriate year (YYYY) and
month (MM).</p>
</blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define __cpp_lib_parallel_algorithm </span>YYYYMML<span class="pp"> </span><span class="co">// also in &lt;algorithm&gt;</span></span></code></pre></div>
<h2 data-number="6.2" id="change-numeric.ops.overview"><span class="header-section-number">6.2</span> Change [numeric.ops.overview]<a href="#change-numeric.ops.overview" class="self-link"></a></h2>
<blockquote>
<p>Change [numeric.ops.overview] (the <code>&lt;numeric&gt;</code>
header synopsis) as follows.</p>
</blockquote>
<h3 data-number="6.2.1" id="add-declaration-of-exposition-only-concepts"><span class="header-section-number">6.2.1</span> Add declaration of
exposition-only concepts<a href="#add-declaration-of-exposition-only-concepts" class="self-link"></a></h3>
<blockquote>
<p>Add declarations of exposition-only concepts
<em><code>indirectly-binary-foldable-impl</code></em> and
<em><code>indirectly-binary-foldable</code></em> to
[numeric.ops.overview] (the <code>&lt;numeric&gt;</code> header
synopsis) as follows.</p>
</blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    template&lt;class F, class T, class I, class U&gt;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>      concept <em>indirectly-binary-left-foldable-impl</em> =  // <em>exposition only</em></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        movable&lt;T&gt; &amp;&amp; movable&lt;U&gt; &amp;&amp;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        convertible_to&lt;T, U&gt; &amp;&amp; invocable&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt;&gt;;</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>template&lt;class F, class T, class I, class U&gt;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  concept <em>indirectly-binary-foldable-impl</em> =       // <em>exposition only</em></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    movable&lt;T&gt; &amp;&amp; movable&lt;U&gt; &amp;&amp;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    convertible_to&lt;T, U&gt; &amp;&amp;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    invocable&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    invocable&lt;F&amp;, iter_reference_t&lt;I&gt;, U&gt; &amp;&amp;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, U&gt;&gt;;</span></code></pre></div>

</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    template&lt;class F, class T, class I&gt;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>      concept <em>indirectly-binary-left-foldable</em> =      // <em>exposition only</em></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        copy_constructible&lt;F&gt; &amp;&amp; indirectly_readable&lt;I&gt; &amp;&amp;</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        invocable&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        convertible_to&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>               decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <em>indirectly-binary-left-foldable-impl</em>&lt;F, T, I,</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                        decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    template&lt;class F, class T, class I&gt;</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>      concept <em>indirectly-binary-right-foldable</em> =    // <em>exposition only</em></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        indirectly-binary-left-foldable&lt;<em>flipped</em>&lt;F&gt;, T, I&gt;;</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>template&lt;class F, class T, class I&gt;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  concept <em>indirectly-binary-foldable</em> =           // <em>exposition only</em></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    copy_constructible&lt;F&gt; &amp;&amp; indirectly_readable&lt;I&gt; &amp;&amp;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    invocable&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt; &amp;&amp;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    convertible_to&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    invocable&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt; &amp;&amp;</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    convertible_to&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>      decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;&gt; &amp;&amp;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <em>indirectly-binary-foldable-impl</em>&lt;F, T, I,</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>      decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;;</span></code></pre></div>

</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>             indirectly-binary-left-foldable&lt;T, I&gt; F&gt;</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      constexpr auto fold_left(I first, S last, T init, F f);</span></code></pre></div>
<h3 data-number="6.2.2" id="add-declarations-of-parallel-ranges-reduce-overloads"><span class="header-section-number">6.2.2</span> Add declarations of parallel
ranges <code>reduce</code> overloads<a href="#add-declarations-of-parallel-ranges-reduce-overloads" class="self-link"></a></h3>
<blockquote>
<p>Add declarations of ranges overloads of <code>reduce</code>,
<code>sum</code>, and <code>product</code> algorithms to
[numeric.ops.overview] (the <code>&lt;numeric&gt;</code> header
synopsis) as follows.</p>
</blockquote>
<p>TODO: Check that using <code>projected&lt;I, Proj&gt;</code> instead
of <code>I</code> in <em><code>indirectly-binary-foldable</code></em> is
the right way to handle projections.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  template&lt;class ExecutionPolicy, class ForwardIterator, class T, class BinaryOperation&gt;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    T reduce(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>             ForwardIterator first, ForwardIterator last, T init, BinaryOperation binary_op);</span></code></pre></div>
<div class="add" style="color: #00AA00">

<div class="sourceCode" id="cb9"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  namespace ranges {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of reduce</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  template&lt;random_access_iterator I,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>           class T,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>           class Proj = identity,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em>&lt;T, projected&lt;I, Proj&gt;&gt; F&gt;</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>      constexpr auto reduce(I first, S last, T init, F binary_op,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                            Proj proj = {}) -&gt; /* <em>see below</em> */;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  template&lt;random_access_iterator I,</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>           class Proj = identity,</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em>&lt;T, projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; F&gt;</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>      constexpr auto reduce(R&amp;&amp; r, T init, F binary_op,</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>                            Proj proj = {}) -&gt; /* <em>see below</em> */;</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of reduce</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>           class T,</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>           class Proj = identity,</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em>&lt;T, projected&lt;I, Proj&gt;&gt; F&gt;</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>      auto reduce(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>                  I first, S last, T init, F binary_op,</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>                  Proj proj = {}) -&gt; /* <em>see below</em> */;</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>           class T,</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>           class Proj = identity,</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>           <em>indirectly-binary-foldable</em>&lt;T, projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; F&gt;</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>      auto reduce(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>                  R&amp;&amp; r, T init, F binary_op,</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>                  Proj proj = {}) -&gt; /* <em>see below</em> */;</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of sum</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>  template&lt;random_access_iterator I,</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>      constexpr auto sum(I first, S last, Proj proj = {})</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>sized-random-access-range</em> R&gt;</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>      constexpr auto sum(R&amp;&amp; r, Proj proj = {})</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of sum</span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>      auto sum(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>               I first, S last, Proj proj = {})</span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>           class T,</span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>      auto sum(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>               R&amp;&amp; r, Proj proj = {})</span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>  // Non-parallel overloads of product</span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>  template&lt;random_access_iterator I,</span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>      constexpr auto product(I first, S last, Proj proj = {})</span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>sized-random-access-range</em> R&gt;</span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>      constexpr auto product(R&amp;&amp; r, Proj proj = {})</span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>  // Parallel overloads of product</span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>           random_access_iterator I,</span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>           sized_sentinel_for&lt;I&gt; S,</span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>      auto product(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>                   I first, S last, Proj proj = {})</span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a>  template&lt;<em>execution-policy</em> ExecutionPolicy,</span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a>           <em>sized-random-access-range</em> R,</span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a>           class Proj = identity&gt;</span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a>    requires /* <em>see below</em> */</span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a>      auto product(ExecutionPolicy&amp;&amp; exec, // <em>freestanding-deleted, see [algorithms.parallel.overloads]</em></span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a>                   R&amp;&amp; r, Proj proj = {})</span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a>        -&gt; /* <em>see below</em> */;</span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a>  } // namespace ranges</span></code></pre></div>

</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  // [inner.product], inner product</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  template&lt;class InputIterator1, class InputIterator2, class T&gt;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                              InputIterator2 first2, T init);</span></code></pre></div>
<h3 data-number="6.2.3" id="add-declarations-of-parallel-ranges-inclusive_scan"><span class="header-section-number">6.2.3</span> Add declarations of parallel
ranges <code>inclusive_scan</code><a href="#add-declarations-of-parallel-ranges-inclusive_scan" class="self-link"></a></h3>
<p>TODO</p>
<h3 data-number="6.2.4" id="add-declarations-of-parallel-ranges-exclusive_scan"><span class="header-section-number">6.2.4</span> Add declarations of parallel
ranges <code>exclusive_scan</code><a href="#add-declarations-of-parallel-ranges-exclusive_scan" class="self-link"></a></h3>
<p>TODO</p>
<h3 data-number="6.2.5" id="add-wording-for-algorithms"><span class="header-section-number">6.2.5</span> Add wording for algorithms<a href="#add-wording-for-algorithms" class="self-link"></a></h3>
<p>TODO</p>
</div>
</div>
</body>
</html>
